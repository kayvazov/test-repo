const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./ActionSheet.stories-BrdygiOL.js","./transition-BbYjgdWJ.js","./useTheme-Cy0CkrhV.js","./_commonjsHelpers-BFTU3MAI.js","./portal-xOeomrXK.js","./focus-management-CfDY3olH.js","./keyboard-Y5Ohh0Ec.js","./open-closed-n-oNVJpd.js","./disposables-JZe9QuOV.js","./micro-task-DeZ0-2Kb.js","./index-DHjp26mP.js","./useHideData-p5xj-pxn.js","./Button-CtUqJ2yf.js","./Button-l6bwth-t.css","./ActionSheet-0aCLi6SO.js","./ActionSheet-CzgNSYPU.css","./Alert.stories-CpJT-eKq.js","./Alert-Cz2VvQwu.js","./Alert-C-nya4wq.css","./AmountCombobx.stories-B757sUKM.js","./FormField-DC7p7h4Z.js","./FormField-2sFYYhN5.css","./AmountCombobox-C9ylVrxz.js","./AmountInput-B4GxmzhL.js","./useMask-G9TE6bCD.js","./ChevronDownIcon-CrpolITG.js","./AmountInput-BX9ayVT1.css","./listbox-xfprdXMl.js","./form-B5TVLiQV.js","./use-resolve-button-type-BRMzcgpv.js","./calculate-active-index-BtXYA8d0.js","./ChevronUpDownIcon-BNkXqcI5.js","./AmountCombobox-BYUz7hVN.css","./AmountInput.stories-RpIDorpj.js","./Amount.stories-Bp8mPoat.js","./Amount-CH7S0hrn.js","./constants-BNWoBBcu.js","./Amount-tEPcphAl.css","./Article.stories-DBs1fiyo.js","./Article-CwxEqUtA.js","./Article-DefkOeJp.css","./Badge.stories-Dkn1jSSs.js","./Badge-BEx1WZDd.js","./Badge-BbHotRiK.css","./Animation.stories-DT3_zt2O.js","./Button.stories-C8O9bm2A.js","./ButtonGroup.stories-BodARW8d.js","./ButtonGroup-D41YfLMb.js","./ButtonGroup-Zih2Wo8u.css","./ButtonTokenSystem.stories-tKssrJ_L.js","./Card.stories-JpsHvv46.js","./CardToolbar-CqVcfSP5.js","./CardToolbar-uT-145at.css","./ClampText.stories-BtyXCtkC.js","./ClampText-pShlc9wm.js","./ClampText-BxdkhVJ4.css","./Combobox.stories-Br8lKMsg.js","./ComboboxOption-BiQzpX90.js","./CheckIcon-CfIKdVGN.js","./ComboboxOption-BNlhvLoR.css","./CopyInput.stories-wZ10vnqQ.js","./CopyInput-Durcp8G_.js","./useClipboard-D24cvHBF.js","./CopyInput-TjFS-I1D.css","./CountryFlagIcon.stories-SPsaYMBg.js","./CountryFlagIcon-CDE82R4S.js","./dynamic-import-helper-uMTE3ehW.js","./CountryFlagIcon-D4dEUNbl.css","./Drawer.stories-DYWdXnJj.js","./DrawerHeader-Dc_JcqTg.js","./XMarkIcon-B0gCI5_N.js","./DrawerHeader-2FThQ-Rm.css","./DropZone.stories-CZ2PIq7_.js","./DropZone-C9W-KNp2.js","./DropZone-5XAtCJE8.css","./Dropdown.stories-Do8xpRFa.js","./DropdownBody-CawdB6hu.js","./DropdownBody-ZTH3MJ7E.css","./FileInput.stories-C1B7U5na.js","./FileInputPreview-7p4lQs8r.js","./FileInputPreview-C4fH2hLF.css","./FormField.stories-Dtb7F88a.js","./FormTextarea.stories-ZImbog20.js","./FormTextareaLabel-C-Ky4ZoC.js","./FormTextareaLabel-158_wjcs.css","./FriendlyNumber.stories-CSz1zGeX.js","./FriendlyNumber-CfyrG48u.js","./Hint.stories-CV8CIFq-.js","./Hint-DY9b0z9j.js","./Tooltip-CW07EFtD.js","./Tooltip-BpGmzer_.css","./Hint-jwZgbdP8.css","./InputText.stories-CuMdKeur.js","./InputText-CKbj8-5W.js","./InputText-BDts0sLf.css","./ModalDialog.stories-2yaVXekh.js","./Picture-CXbZeXjf.js","./Pagination-CpQqROxt.js","./Pagination-DBUZcHkE.css","./PhoneInput-BLkL-bbH.js","./PhoneInput-CFL0rCLo.css","./ProgressBar-BqQIwWuq.js","./ProgressBar-DIVVJOFC.css","./Radio-BPg1-YTu.js","./Radio-fvvo4Rf5.css","./Select-BrvdAO34.js","./Select-CfQM4Fxz.css","./SelectOption-D8MCSwFb.js","./SelectOption-r6aWczRI.css","./Skeleton-VdahnwcK.js","./Skeleton-Bgc5df2f.css","./Spinner-CAmBDD7O.js","./Spinner-DvLU8Zva.css","./SvgIcon-CB4xQEt9.js","./Switcher-Bt8YX7H1.js","./switch-DT6ond_T.js","./Switcher-_5gP182y.css","./SwitcherWithText-DGKNliJy.js","./SwitcherWithText-DVv5zlqa.css","./Tabs-lgfu6fdG.js","./Tabs-Dllnwfdr.css","./TextMark-DHD5g9tQ.js","./Ticker-BVIv48bh.js","./Ticker-DGKEJUbQ.css","./ProgressField-D6jbIE0e.js","./CheckCircleIcon-D4s67Pui.js","./ProgressField-Crmwio4L.css","./ModalDialog-DdDhw9fa.css","./Pagination.stories-8ijiT4xl.js","./PhoneInput.stories-CAF1pp-M.js","./Picture.stories-BdRrY6Cf.js","./ProgressBar.stories-YstESm5w.js","./ProgressField.stories-mixRq0JX.js","./QuantityField.stories-DdGZcTao.js","./QuantityField-CeEj1XZA.css","./Radio.stories-tfLvuAes.js","./Select.stories-B5ZPWf4H.js","./Skeleton.stories-CCaBgJ8J.js","./Spinner.stories-CSFm6nJQ.js","./SvgIcon.stories-BXF3K825.js","./Switcher.stories-3KlrfZpE.js","./SwitcherWithText.stories-DwavZzyQ.js","./Tabs.stories-CGiy-uvC.js","./TextMark.stories-2_6J687d.js","./Ticker.stories-DtVhnZhF.js","./Tooltip.stories-BmMzn-mA.js"])))=>i.map(i=>d[i]);
true&&(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
}());

var define_process_env_default = {};
var z5 = Object.create;
var xi = Object.defineProperty;
var G5 = Object.getOwnPropertyDescriptor;
var W5 = Object.getOwnPropertyNames;
var Y5 = Object.getPrototypeOf, K5 = Object.prototype.hasOwnProperty;
var o = (e, t) => xi(e, "name", { value: t, configurable: true }), wi = /* @__PURE__ */ ((e) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
  get: (t, r) => (typeof require < "u" ? require : t)[r]
}) : e)(function(e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
});
var X5 = (e, t) => () => (e && (t = e(e = 0)), t);
var y$1 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), st$1 = (e, t) => {
  for (var r in t)
    xi(e, r, { get: t[r], enumerable: true });
}, pS = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of W5(t))
      !K5.call(e, i) && i !== r && xi(e, i, { get: () => t[i], enumerable: !(n = G5(t, i)) || n.enumerable });
  return e;
};
var Ne = (e, t, r) => (r = e != null ? z5(Y5(e)) : {}, pS(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? xi(r, "default", { value: e, enumerable: true }) : r,
  e
)), J5 = (e) => pS(xi({}, "__esModule", { value: true }), e);
var i_ = y$1((mg) => {
  Object.defineProperty(mg, "__esModule", { value: true }), mg.isEqual = /* @__PURE__ */ function() {
    var e = Object.prototype.toString, t = Object.getPrototypeOf, r = Object.getOwnPropertySymbols ? function(n) {
      return Object.keys(n).concat(Object.getOwnPropertySymbols(n));
    } : Object.keys;
    return function(n, i) {
      return (/* @__PURE__ */ o(function s(a, l, u) {
        var c, d, p, f = e.call(a), m = e.call(l);
        if (a === l) return true;
        if (a == null || l == null) return false;
        if (u.indexOf(a) > -1 && u.indexOf(l) > -1) return true;
        if (u.push(a, l), f != m || (c = r(a), d = r(l), c.length != d.length || c.some(function(h) {
          return !s(a[h], l[h], u);
        }))) return false;
        switch (f.slice(8, -1)) {
          case "Symbol":
            return a.valueOf() == l.valueOf();
          case "Date":
          case "Number":
            return +a == +l || +a != +a && +l != +l;
          case "RegExp":
          case "Function":
          case "String":
          case "Boolean":
            return "" + a == "" + l;
          case "Set":
          case "Map":
            c = a.entries(), d = l.entries();
            do
              if (!s((p = c.next()).value, d.next().value, u)) return false;
            while (!p.done);
            return true;
          case "ArrayBuffer":
            a = new Uint8Array(a), l = new Uint8Array(l);
          case "DataView":
            a = new Uint8Array(a.buffer), l = new Uint8Array(l.buffer);
          case "Float32Array":
          case "Float64Array":
          case "Int8Array":
          case "Int16Array":
          case "Int32Array":
          case "Uint8Array":
          case "Uint16Array":
          case "Uint32Array":
          case "Uint8ClampedArray":
          case "Arguments":
          case "Array":
            if (a.length != l.length) return false;
            for (p = 0; p < a.length; p++) if ((p in a || p in l) && (p in a != p in l || !s(a[p], l[p], u))) return false;
            return true;
          case "Object":
            return s(t(a), t(l), u);
          default:
            return false;
        }
      }, "n"))(n, i, []);
    };
  }();
});
var qP = y$1((T_e, OP) => {
  OP.exports = (e) => {
    let t = e.match(/^[ \t]*(?=\S)/gm);
    return t ? t.reduce((r, n) => Math.min(r, n.length), 1 / 0) : 0;
  };
});
var MP = y$1((R_e, IP) => {
  var ZW = qP();
  IP.exports = (e) => {
    let t = ZW(e);
    if (t === 0)
      return e;
    let r = new RegExp(`^[ \\t]{${t}}`, "gm");
    return e.replace(r, "");
  };
});
var jP = y$1((S_e, NP) => {
  NP.exports = (e, t = 1, r) => {
    if (r = {
      indent: " ",
      includeEmptyLines: false,
      ...r
    }, typeof e != "string")
      throw new TypeError(
        `Expected \`input\` to be a \`string\`, got \`${typeof e}\``
      );
    if (typeof t != "number")
      throw new TypeError(
        `Expected \`count\` to be a \`number\`, got \`${typeof t}\``
      );
    if (typeof r.indent != "string")
      throw new TypeError(
        `Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``
      );
    if (t === 0)
      return e;
    let n = r.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return e.replace(n, r.indent.repeat(t));
  };
});
var rE = y$1((__e, kP) => {
  var e8 = MP(), t8 = jP();
  kP.exports = (e, t = 0, r) => t8(e8(e), t, r);
});
var u0 = y$1((Ul) => {
  Object.defineProperty(Ul, "__esModule", {
    value: true
  });
  Ul.default = void 0;
  function k8() {
    var e = this, t = 0, r = {
      "@@iterator": /* @__PURE__ */ o(function() {
        return r;
      }, "iterator"),
      next: /* @__PURE__ */ o(function() {
        if (t < e.length) {
          var i = e[t];
          return t = t + 1, {
            done: false,
            value: i
          };
        } else
          return {
            done: true
          };
      }, "next")
    };
    return r;
  }
  o(k8, "iteratorProxy");
  Ul.default = k8;
});
var Oo = y$1((pE) => {
  Object.defineProperty(pE, "__esModule", {
    value: true
  });
  pE.default = D8;
  var L8 = F8(u0());
  function F8(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(F8, "_interopRequireDefault");
  function dE(e) {
    "@babel/helpers - typeof";
    return dE = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, dE(e);
  }
  o(dE, "_typeof");
  function D8(e, t) {
    return typeof Symbol == "function" && dE(Symbol.iterator) === "symbol" && Object.defineProperty(e, Symbol.iterator, {
      value: L8.default.bind(t)
    }), e;
  }
  o(D8, "iterationDecorator");
});
var d0 = y$1((Vl) => {
  Object.defineProperty(Vl, "__esModule", {
    value: true
  });
  Vl.default = void 0;
  var $8 = B8(Oo());
  function B8(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(B8, "_interopRequireDefault");
  function fE(e, t) {
    return z8(e) || V8(e, t) || U8(e, t) || H8();
  }
  o(fE, "_slicedToArray");
  function H8() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  o(H8, "_nonIterableRest");
  function U8(e, t) {
    if (e) {
      if (typeof e == "string") return c0(e, t);
      var r = {}.toString.call(e).slice(8, -1);
      return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? c0(e, t) : void 0;
    }
  }
  o(U8, "_unsupportedIterableToArray");
  function c0(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
    return n;
  }
  o(c0, "_arrayLikeToArray");
  function V8(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
      var n, i, s, a, l = [], u = true, c = false;
      try {
        if (s = (r = r.call(e)).next, t === 0) {
          if (Object(r) !== r) return;
          u = false;
        } else for (; !(u = (n = s.call(r)).done) && (l.push(n.value), l.length !== t); u = true) ;
      } catch (d) {
        c = true, i = d;
      } finally {
        try {
          if (!u && r.return != null && (a = r.return(), Object(a) !== a)) return;
        } finally {
          if (c) throw i;
        }
      }
      return l;
    }
  }
  o(V8, "_iterableToArrayLimit");
  function z8(e) {
    if (Array.isArray(e)) return e;
  }
  o(z8, "_arrayWithHoles");
  var qo = [["aria-activedescendant", {
    type: "id"
  }], ["aria-atomic", {
    type: "boolean"
  }], ["aria-autocomplete", {
    type: "token",
    values: ["inline", "list", "both", "none"]
  }], ["aria-braillelabel", {
    type: "string"
  }], ["aria-brailleroledescription", {
    type: "string"
  }], ["aria-busy", {
    type: "boolean"
  }], ["aria-checked", {
    type: "tristate"
  }], ["aria-colcount", {
    type: "integer"
  }], ["aria-colindex", {
    type: "integer"
  }], ["aria-colspan", {
    type: "integer"
  }], ["aria-controls", {
    type: "idlist"
  }], ["aria-current", {
    type: "token",
    values: ["page", "step", "location", "date", "time", true, false]
  }], ["aria-describedby", {
    type: "idlist"
  }], ["aria-description", {
    type: "string"
  }], ["aria-details", {
    type: "id"
  }], ["aria-disabled", {
    type: "boolean"
  }], ["aria-dropeffect", {
    type: "tokenlist",
    values: ["copy", "execute", "link", "move", "none", "popup"]
  }], ["aria-errormessage", {
    type: "id"
  }], ["aria-expanded", {
    type: "boolean",
    allowundefined: true
  }], ["aria-flowto", {
    type: "idlist"
  }], ["aria-grabbed", {
    type: "boolean",
    allowundefined: true
  }], ["aria-haspopup", {
    type: "token",
    values: [false, true, "menu", "listbox", "tree", "grid", "dialog"]
  }], ["aria-hidden", {
    type: "boolean",
    allowundefined: true
  }], ["aria-invalid", {
    type: "token",
    values: ["grammar", false, "spelling", true]
  }], ["aria-keyshortcuts", {
    type: "string"
  }], ["aria-label", {
    type: "string"
  }], ["aria-labelledby", {
    type: "idlist"
  }], ["aria-level", {
    type: "integer"
  }], ["aria-live", {
    type: "token",
    values: ["assertive", "off", "polite"]
  }], ["aria-modal", {
    type: "boolean"
  }], ["aria-multiline", {
    type: "boolean"
  }], ["aria-multiselectable", {
    type: "boolean"
  }], ["aria-orientation", {
    type: "token",
    values: ["vertical", "undefined", "horizontal"]
  }], ["aria-owns", {
    type: "idlist"
  }], ["aria-placeholder", {
    type: "string"
  }], ["aria-posinset", {
    type: "integer"
  }], ["aria-pressed", {
    type: "tristate"
  }], ["aria-readonly", {
    type: "boolean"
  }], ["aria-relevant", {
    type: "tokenlist",
    values: ["additions", "all", "removals", "text"]
  }], ["aria-required", {
    type: "boolean"
  }], ["aria-roledescription", {
    type: "string"
  }], ["aria-rowcount", {
    type: "integer"
  }], ["aria-rowindex", {
    type: "integer"
  }], ["aria-rowspan", {
    type: "integer"
  }], ["aria-selected", {
    type: "boolean",
    allowundefined: true
  }], ["aria-setsize", {
    type: "integer"
  }], ["aria-sort", {
    type: "token",
    values: ["ascending", "descending", "none", "other"]
  }], ["aria-valuemax", {
    type: "number"
  }], ["aria-valuemin", {
    type: "number"
  }], ["aria-valuenow", {
    type: "number"
  }], ["aria-valuetext", {
    type: "string"
  }]], mE = {
    entries: /* @__PURE__ */ o(function() {
      return qo;
    }, "entries"),
    forEach: /* @__PURE__ */ o(function(t) {
      for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = 0, i = qo; n < i.length; n++) {
        var s = fE(i[n], 2), a = s[0], l = s[1];
        t.call(r, l, a, qo);
      }
    }, "forEach"),
    get: /* @__PURE__ */ o(function(t) {
      var r = qo.filter(function(n) {
        return n[0] === t;
      })[0];
      return r && r[1];
    }, "get"),
    has: /* @__PURE__ */ o(function(t) {
      return !!mE.get(t);
    }, "has"),
    keys: /* @__PURE__ */ o(function() {
      return qo.map(function(t) {
        var r = fE(t, 1), n = r[0];
        return n;
      });
    }, "keys"),
    values: /* @__PURE__ */ o(function() {
      return qo.map(function(t) {
        var r = fE(t, 2), n = r[1];
        return n;
      });
    }, "values")
  }; Vl.default = (0, $8.default)(mE, mE.entries());
});
var f0 = y$1((zl) => {
  Object.defineProperty(zl, "__esModule", {
    value: true
  });
  zl.default = void 0;
  var G8 = W8(Oo());
  function W8(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(W8, "_interopRequireDefault");
  function hE(e, t) {
    return J8(e) || X8(e, t) || K8(e, t) || Y8();
  }
  o(hE, "_slicedToArray");
  function Y8() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  o(Y8, "_nonIterableRest");
  function K8(e, t) {
    if (e) {
      if (typeof e == "string") return p0(e, t);
      var r = {}.toString.call(e).slice(8, -1);
      return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? p0(e, t) : void 0;
    }
  }
  o(K8, "_unsupportedIterableToArray");
  function p0(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
    return n;
  }
  o(p0, "_arrayLikeToArray");
  function X8(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
      var n, i, s, a, l = [], u = true, c = false;
      try {
        if (s = (r = r.call(e)).next, t === 0) {
          if (Object(r) !== r) return;
          u = false;
        } else for (; !(u = (n = s.call(r)).done) && (l.push(n.value), l.length !== t); u = true) ;
      } catch (d) {
        c = true, i = d;
      } finally {
        try {
          if (!u && r.return != null && (a = r.return(), Object(a) !== a)) return;
        } finally {
          if (c) throw i;
        }
      }
      return l;
    }
  }
  o(X8, "_iterableToArrayLimit");
  function J8(e) {
    if (Array.isArray(e)) return e;
  }
  o(J8, "_arrayWithHoles");
  var Io = [["a", {
    reserved: false
  }], ["abbr", {
    reserved: false
  }], ["acronym", {
    reserved: false
  }], ["address", {
    reserved: false
  }], ["applet", {
    reserved: false
  }], ["area", {
    reserved: false
  }], ["article", {
    reserved: false
  }], ["aside", {
    reserved: false
  }], ["audio", {
    reserved: false
  }], ["b", {
    reserved: false
  }], ["base", {
    reserved: true
  }], ["bdi", {
    reserved: false
  }], ["bdo", {
    reserved: false
  }], ["big", {
    reserved: false
  }], ["blink", {
    reserved: false
  }], ["blockquote", {
    reserved: false
  }], ["body", {
    reserved: false
  }], ["br", {
    reserved: false
  }], ["button", {
    reserved: false
  }], ["canvas", {
    reserved: false
  }], ["caption", {
    reserved: false
  }], ["center", {
    reserved: false
  }], ["cite", {
    reserved: false
  }], ["code", {
    reserved: false
  }], ["col", {
    reserved: true
  }], ["colgroup", {
    reserved: true
  }], ["content", {
    reserved: false
  }], ["data", {
    reserved: false
  }], ["datalist", {
    reserved: false
  }], ["dd", {
    reserved: false
  }], ["del", {
    reserved: false
  }], ["details", {
    reserved: false
  }], ["dfn", {
    reserved: false
  }], ["dialog", {
    reserved: false
  }], ["dir", {
    reserved: false
  }], ["div", {
    reserved: false
  }], ["dl", {
    reserved: false
  }], ["dt", {
    reserved: false
  }], ["em", {
    reserved: false
  }], ["embed", {
    reserved: false
  }], ["fieldset", {
    reserved: false
  }], ["figcaption", {
    reserved: false
  }], ["figure", {
    reserved: false
  }], ["font", {
    reserved: false
  }], ["footer", {
    reserved: false
  }], ["form", {
    reserved: false
  }], ["frame", {
    reserved: false
  }], ["frameset", {
    reserved: false
  }], ["h1", {
    reserved: false
  }], ["h2", {
    reserved: false
  }], ["h3", {
    reserved: false
  }], ["h4", {
    reserved: false
  }], ["h5", {
    reserved: false
  }], ["h6", {
    reserved: false
  }], ["head", {
    reserved: true
  }], ["header", {
    reserved: false
  }], ["hgroup", {
    reserved: false
  }], ["hr", {
    reserved: false
  }], ["html", {
    reserved: true
  }], ["i", {
    reserved: false
  }], ["iframe", {
    reserved: false
  }], ["img", {
    reserved: false
  }], ["input", {
    reserved: false
  }], ["ins", {
    reserved: false
  }], ["kbd", {
    reserved: false
  }], ["keygen", {
    reserved: false
  }], ["label", {
    reserved: false
  }], ["legend", {
    reserved: false
  }], ["li", {
    reserved: false
  }], ["link", {
    reserved: true
  }], ["main", {
    reserved: false
  }], ["map", {
    reserved: false
  }], ["mark", {
    reserved: false
  }], ["marquee", {
    reserved: false
  }], ["menu", {
    reserved: false
  }], ["menuitem", {
    reserved: false
  }], ["meta", {
    reserved: true
  }], ["meter", {
    reserved: false
  }], ["nav", {
    reserved: false
  }], ["noembed", {
    reserved: true
  }], ["noscript", {
    reserved: true
  }], ["object", {
    reserved: false
  }], ["ol", {
    reserved: false
  }], ["optgroup", {
    reserved: false
  }], ["option", {
    reserved: false
  }], ["output", {
    reserved: false
  }], ["p", {
    reserved: false
  }], ["param", {
    reserved: true
  }], ["picture", {
    reserved: true
  }], ["pre", {
    reserved: false
  }], ["progress", {
    reserved: false
  }], ["q", {
    reserved: false
  }], ["rp", {
    reserved: false
  }], ["rt", {
    reserved: false
  }], ["rtc", {
    reserved: false
  }], ["ruby", {
    reserved: false
  }], ["s", {
    reserved: false
  }], ["samp", {
    reserved: false
  }], ["script", {
    reserved: true
  }], ["section", {
    reserved: false
  }], ["select", {
    reserved: false
  }], ["small", {
    reserved: false
  }], ["source", {
    reserved: true
  }], ["spacer", {
    reserved: false
  }], ["span", {
    reserved: false
  }], ["strike", {
    reserved: false
  }], ["strong", {
    reserved: false
  }], ["style", {
    reserved: true
  }], ["sub", {
    reserved: false
  }], ["summary", {
    reserved: false
  }], ["sup", {
    reserved: false
  }], ["table", {
    reserved: false
  }], ["tbody", {
    reserved: false
  }], ["td", {
    reserved: false
  }], ["textarea", {
    reserved: false
  }], ["tfoot", {
    reserved: false
  }], ["th", {
    reserved: false
  }], ["thead", {
    reserved: false
  }], ["time", {
    reserved: false
  }], ["title", {
    reserved: true
  }], ["tr", {
    reserved: false
  }], ["track", {
    reserved: true
  }], ["tt", {
    reserved: false
  }], ["u", {
    reserved: false
  }], ["ul", {
    reserved: false
  }], ["var", {
    reserved: false
  }], ["video", {
    reserved: false
  }], ["wbr", {
    reserved: false
  }], ["xmp", {
    reserved: false
  }]], yE = {
    entries: /* @__PURE__ */ o(function() {
      return Io;
    }, "entries"),
    forEach: /* @__PURE__ */ o(function(t) {
      for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = 0, i = Io; n < i.length; n++) {
        var s = hE(i[n], 2), a = s[0], l = s[1];
        t.call(r, l, a, Io);
      }
    }, "forEach"),
    get: /* @__PURE__ */ o(function(t) {
      var r = Io.filter(function(n) {
        return n[0] === t;
      })[0];
      return r && r[1];
    }, "get"),
    has: /* @__PURE__ */ o(function(t) {
      return !!yE.get(t);
    }, "has"),
    keys: /* @__PURE__ */ o(function() {
      return Io.map(function(t) {
        var r = hE(t, 1), n = r[0];
        return n;
      });
    }, "keys"),
    values: /* @__PURE__ */ o(function() {
      return Io.map(function(t) {
        var r = hE(t, 2), n = r[1];
        return n;
      });
    }, "values")
  }; zl.default = (0, G8.default)(yE, yE.entries());
});
var m0 = y$1((Gl) => {
  Object.defineProperty(Gl, "__esModule", {
    value: true
  });
  Gl.default = void 0;
  var Q8 = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  }; Gl.default = Q8;
});
var h0 = y$1((Wl) => {
  Object.defineProperty(Wl, "__esModule", {
    value: true
  });
  Wl.default = void 0;
  var Z8 = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  }; Wl.default = Z8;
});
var y0 = y$1((Yl) => {
  Object.defineProperty(Yl, "__esModule", {
    value: true
  });
  Yl.default = void 0;
  var eY = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null
    },
    relatedConcepts: [{
      concept: {
        name: "input"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  }; Yl.default = eY;
});
var b0 = y$1((Kl) => {
  Object.defineProperty(Kl, "__esModule", {
    value: true
  });
  Kl.default = void 0;
  var tY = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Kl.default = tY;
});
var g0 = y$1((Xl) => {
  Object.defineProperty(Xl, "__esModule", {
    value: true
  });
  Xl.default = void 0;
  var rY = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuemax": null,
      "aria-valuemin": null,
      "aria-valuenow": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }; Xl.default = rY;
});
var v0 = y$1((Jl) => {
  Object.defineProperty(Jl, "__esModule", {
    value: true
  });
  Jl.default = void 0;
  var nY = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {
      "aria-atomic": null,
      "aria-busy": null,
      "aria-controls": null,
      "aria-current": null,
      "aria-describedby": null,
      "aria-details": null,
      "aria-dropeffect": null,
      "aria-flowto": null,
      "aria-grabbed": null,
      "aria-hidden": null,
      "aria-keyshortcuts": null,
      "aria-label": null,
      "aria-labelledby": null,
      "aria-live": null,
      "aria-owns": null,
      "aria-relevant": null,
      "aria-roledescription": null
    },
    relatedConcepts: [{
      concept: {
        name: "role"
      },
      module: "XHTML"
    }, {
      concept: {
        name: "type"
      },
      module: "Dublin Core"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: []
  }; Jl.default = nY;
});
var E0 = y$1((Ql) => {
  Object.defineProperty(Ql, "__esModule", {
    value: true
  });
  Ql.default = void 0;
  var oY = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "frontmatter"
      },
      module: "DTB"
    }, {
      concept: {
        name: "level"
      },
      module: "DTB"
    }, {
      concept: {
        name: "level"
      },
      module: "SMIL"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }; Ql.default = oY;
});
var x0 = y$1((Zl) => {
  Object.defineProperty(Zl, "__esModule", {
    value: true
  });
  Zl.default = void 0;
  var iY = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }; Zl.default = iY;
});
var w0 = y$1((eu) => {
  Object.defineProperty(eu, "__esModule", {
    value: true
  });
  eu.default = void 0;
  var sY = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
  }; eu.default = sY;
});
var T0 = y$1((tu) => {
  Object.defineProperty(tu, "__esModule", {
    value: true
  });
  tu.default = void 0;
  var aY = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  }; tu.default = aY;
});
var R0 = y$1((ru) => {
  Object.defineProperty(ru, "__esModule", {
    value: true
  });
  ru.default = void 0;
  var lY = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  }; ru.default = lY;
});
var S0 = y$1((nu) => {
  Object.defineProperty(nu, "__esModule", {
    value: true
  });
  nu.default = void 0;
  var uY = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-modal": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  }; nu.default = uY;
});
var _0 = y$1((ou) => {
  Object.defineProperty(ou, "__esModule", {
    value: true
  });
  ou.default = void 0;
  var cY = At(m0()), dY = At(h0()), pY = At(y0()), fY = At(b0()), mY = At(g0()), hY = At(v0()), yY = At(E0()), bY = At(x0()), gY = At(w0()), vY = At(T0()), EY = At(R0()), xY = At(S0());
  function At(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(At, "_interopRequireDefault");
  var wY = [["command", cY.default], ["composite", dY.default], ["input", pY.default], ["landmark", fY.default], ["range", mY.default], ["roletype", hY.default], ["section", yY.default], ["sectionhead", bY.default], ["select", gY.default], ["structure", vY.default], ["widget", EY.default], ["window", xY.default]]; ou.default = wY;
});
var C0 = y$1((iu) => {
  Object.defineProperty(iu, "__esModule", {
    value: true
  });
  iu.default = void 0;
  var TY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-atomic": "true",
      "aria-live": "assertive"
    },
    relatedConcepts: [{
      concept: {
        name: "alert"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; iu.default = TY;
});
var P0 = y$1((su) => {
  Object.defineProperty(su, "__esModule", {
    value: true
  });
  su.default = void 0;
  var RY = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "alert"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
  }; su.default = RY;
});
var A0 = y$1((au) => {
  Object.defineProperty(au, "__esModule", {
    value: true
  });
  au.default = void 0;
  var SY = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "Device Independence Delivery Unit"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }; au.default = SY;
});
var O0 = y$1((lu) => {
  Object.defineProperty(lu, "__esModule", {
    value: true
  });
  lu.default = void 0;
  var _Y = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "article"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "document"]]
  }; lu.default = _Y;
});
var q0 = y$1((uu) => {
  Object.defineProperty(uu, "__esModule", {
    value: true
  });
  uu.default = void 0;
  var CY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        constraints: ["scoped to the body element"],
        name: "header"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; uu.default = CY;
});
var I0 = y$1((cu) => {
  Object.defineProperty(cu, "__esModule", {
    value: true
  });
  cu.default = void 0;
  var PY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "blockquote"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; cu.default = PY;
});
var M0 = y$1((du) => {
  Object.defineProperty(du, "__esModule", {
    value: true
  });
  du.default = void 0;
  var AY = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-pressed": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "button"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "image"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "reset"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "submit"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "button"
      },
      module: "HTML"
    }, {
      concept: {
        name: "trigger"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  }; du.default = AY;
});
var N0 = y$1((pu) => {
  Object.defineProperty(pu, "__esModule", {
    value: true
  });
  pu.default = void 0;
  var OY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "caption"
      },
      module: "HTML"
    }],
    requireContextRole: ["figure", "grid", "table"],
    requiredContextRole: ["figure", "grid", "table"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; pu.default = OY;
});
var j0 = y$1((fu) => {
  Object.defineProperty(fu, "__esModule", {
    value: true
  });
  fu.default = void 0;
  var qY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-colindex": null,
      "aria-colspan": null,
      "aria-rowindex": null,
      "aria-rowspan": null
    },
    relatedConcepts: [{
      concept: {
        constraints: ["ancestor table element has table role"],
        name: "td"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; fu.default = qY;
});
var k0 = y$1((mu) => {
  Object.defineProperty(mu, "__esModule", {
    value: true
  });
  mu.default = void 0;
  var IY = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "checkbox"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "option"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input"]]
  }; mu.default = IY;
});
var L0 = y$1((hu) => {
  Object.defineProperty(hu, "__esModule", {
    value: true
  });
  hu.default = void 0;
  var MY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "code"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; hu.default = MY;
});
var F0 = y$1((yu) => {
  Object.defineProperty(yu, "__esModule", {
    value: true
  });
  yu.default = void 0;
  var NY = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-sort": null
    },
    relatedConcepts: [{
      concept: {
        name: "th"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "scope",
          value: "col"
        }],
        name: "th"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "scope",
          value: "colgroup"
        }],
        name: "th"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
  }; yu.default = NY;
});
var D0 = y$1((bu) => {
  Object.defineProperty(bu, "__esModule", {
    value: true
  });
  bu.default = void 0;
  var jY = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-autocomplete": null,
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-expanded": "false",
      "aria-haspopup": "listbox"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "email"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "search"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "tel"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "text"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "multiple"
        }, {
          constraints: ["undefined"],
          name: "size"
        }],
        constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-controls": null,
      "aria-expanded": "false"
    },
    superClass: [["roletype", "widget", "input"]]
  }; bu.default = jY;
});
var $0 = y$1((gu) => {
  Object.defineProperty(gu, "__esModule", {
    value: true
  });
  gu.default = void 0;
  var kY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        constraints: ["scoped to the body element", "scoped to the main element"],
        name: "aside"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-label"
        }],
        constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
        name: "aside"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-labelledby"
        }],
        constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
        name: "aside"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; gu.default = kY;
});
var B0 = y$1((vu) => {
  Object.defineProperty(vu, "__esModule", {
    value: true
  });
  vu.default = void 0;
  var LY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        constraints: ["scoped to the body element"],
        name: "footer"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; vu.default = LY;
});
var H0 = y$1((Eu) => {
  Object.defineProperty(Eu, "__esModule", {
    value: true
  });
  Eu.default = void 0;
  var FY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dd"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Eu.default = FY;
});
var U0 = y$1((xu) => {
  Object.defineProperty(xu, "__esModule", {
    value: true
  });
  xu.default = void 0;
  var DY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "del"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; xu.default = DY;
});
var V0 = y$1((wu) => {
  Object.defineProperty(wu, "__esModule", {
    value: true
  });
  wu.default = void 0;
  var $Y = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dialog"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "window"]]
  }; wu.default = $Y;
});
var z0 = y$1((Tu) => {
  Object.defineProperty(Tu, "__esModule", {
    value: true
  });
  Tu.default = void 0;
  var BY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      module: "DAISY Guide"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "list"]]
  }; Tu.default = BY;
});
var G0 = y$1((Ru) => {
  Object.defineProperty(Ru, "__esModule", {
    value: true
  });
  Ru.default = void 0;
  var HY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "Device Independence Delivery Unit"
      }
    }, {
      concept: {
        name: "html"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }; Ru.default = HY;
});
var W0 = y$1((Su) => {
  Object.defineProperty(Su, "__esModule", {
    value: true
  });
  Su.default = void 0;
  var UY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "em"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Su.default = UY;
});
var Y0 = y$1((_u) => {
  Object.defineProperty(_u, "__esModule", {
    value: true
  });
  _u.default = void 0;
  var VY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["article"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "list"]]
  }; _u.default = VY;
});
var K0 = y$1((Cu) => {
  Object.defineProperty(Cu, "__esModule", {
    value: true
  });
  Cu.default = void 0;
  var zY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "figure"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Cu.default = zY;
});
var X0 = y$1((Pu) => {
  Object.defineProperty(Pu, "__esModule", {
    value: true
  });
  Pu.default = void 0;
  var GY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-label"
        }],
        name: "form"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-labelledby"
        }],
        name: "form"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "name"
        }],
        name: "form"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; Pu.default = GY;
});
var J0 = y$1((Au) => {
  Object.defineProperty(Au, "__esModule", {
    value: true
  });
  Au.default = void 0;
  var WY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "a"
      },
      module: "HTML"
    }, {
      concept: {
        name: "area"
      },
      module: "HTML"
    }, {
      concept: {
        name: "aside"
      },
      module: "HTML"
    }, {
      concept: {
        name: "b"
      },
      module: "HTML"
    }, {
      concept: {
        name: "bdo"
      },
      module: "HTML"
    }, {
      concept: {
        name: "body"
      },
      module: "HTML"
    }, {
      concept: {
        name: "data"
      },
      module: "HTML"
    }, {
      concept: {
        name: "div"
      },
      module: "HTML"
    }, {
      concept: {
        constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
        name: "footer"
      },
      module: "HTML"
    }, {
      concept: {
        constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
        name: "header"
      },
      module: "HTML"
    }, {
      concept: {
        name: "hgroup"
      },
      module: "HTML"
    }, {
      concept: {
        name: "i"
      },
      module: "HTML"
    }, {
      concept: {
        name: "pre"
      },
      module: "HTML"
    }, {
      concept: {
        name: "q"
      },
      module: "HTML"
    }, {
      concept: {
        name: "samp"
      },
      module: "HTML"
    }, {
      concept: {
        name: "section"
      },
      module: "HTML"
    }, {
      concept: {
        name: "small"
      },
      module: "HTML"
    }, {
      concept: {
        name: "span"
      },
      module: "HTML"
    }, {
      concept: {
        name: "u"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }; Au.default = WY;
});
var Q0 = y$1((Ou) => {
  Object.defineProperty(Ou, "__esModule", {
    value: true
  });
  Ou.default = void 0;
  var YY = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-multiselectable": null,
      "aria-readonly": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
  }; Ou.default = YY;
});
var Z0 = y$1((qu) => {
  Object.defineProperty(qu, "__esModule", {
    value: true
  });
  qu.default = void 0;
  var KY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-selected": null
    },
    relatedConcepts: [{
      concept: {
        constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
        name: "td"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
  }; qu.default = KY;
});
var eA = y$1((Iu) => {
  Object.defineProperty(Iu, "__esModule", {
    value: true
  });
  Iu.default = void 0;
  var XY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null
    },
    relatedConcepts: [{
      concept: {
        name: "details"
      },
      module: "HTML"
    }, {
      concept: {
        name: "fieldset"
      },
      module: "HTML"
    }, {
      concept: {
        name: "optgroup"
      },
      module: "HTML"
    }, {
      concept: {
        name: "address"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Iu.default = XY;
});
var tA = y$1((Mu) => {
  Object.defineProperty(Mu, "__esModule", {
    value: true
  });
  Mu.default = void 0;
  var JY = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-level": "2"
    },
    relatedConcepts: [{
      concept: {
        name: "h1"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h2"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h3"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h4"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h5"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h6"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-level": "2"
    },
    superClass: [["roletype", "structure", "sectionhead"]]
  }; Mu.default = JY;
});
var rA = y$1((Nu) => {
  Object.defineProperty(Nu, "__esModule", {
    value: true
  });
  Nu.default = void 0;
  var QY = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "alt"
        }],
        name: "img"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "alt"
        }],
        name: "img"
      },
      module: "HTML"
    }, {
      concept: {
        name: "imggroup"
      },
      module: "DTB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Nu.default = QY;
});
var nA = y$1((ju) => {
  Object.defineProperty(ju, "__esModule", {
    value: true
  });
  ju.default = void 0;
  var ZY = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "ins"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; ju.default = ZY;
});
var oA = y$1((ku) => {
  Object.defineProperty(ku, "__esModule", {
    value: true
  });
  ku.default = void 0;
  var e9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "href"
        }],
        name: "a"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "href"
        }],
        name: "area"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  }; ku.default = e9;
});
var iA = y$1((Lu) => {
  Object.defineProperty(Lu, "__esModule", {
    value: true
  });
  Lu.default = void 0;
  var t9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menu"
      },
      module: "HTML"
    }, {
      concept: {
        name: "ol"
      },
      module: "HTML"
    }, {
      concept: {
        name: "ul"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["listitem"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Lu.default = t9;
});
var sA = y$1((Fu) => {
  Object.defineProperty(Fu, "__esModule", {
    value: true
  });
  Fu.default = void 0;
  var r9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-invalid": null,
      "aria-multiselectable": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-orientation": "vertical"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: [">1"],
          name: "size"
        }],
        constraints: ["the size attribute value is greater than 1"],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "multiple"
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        name: "datalist"
      },
      module: "HTML"
    }, {
      concept: {
        name: "list"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["option", "group"], ["option"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  }; Fu.default = r9;
});
var aA = y$1((Du) => {
  Object.defineProperty(Du, "__esModule", {
    value: true
  });
  Du.default = void 0;
  var n9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-level": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
        name: "li"
      },
      module: "HTML"
    }, {
      concept: {
        name: "item"
      },
      module: "XForms"
    }],
    requireContextRole: ["directory", "list"],
    requiredContextRole: ["directory", "list"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Du.default = n9;
});
var lA = y$1(($u) => {
  Object.defineProperty($u, "__esModule", {
    value: true
  });
  $u.default = void 0;
  var o9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-live": "polite"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; $u.default = o9;
});
var uA = y$1((Bu) => {
  Object.defineProperty(Bu, "__esModule", {
    value: true
  });
  Bu.default = void 0;
  var i9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "main"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; Bu.default = i9;
});
var cA = y$1((Hu) => {
  Object.defineProperty(Hu, "__esModule", {
    value: true
  });
  Hu.default = void 0;
  var s9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: [],
    props: {
      "aria-braillelabel": null,
      "aria-brailleroledescription": null,
      "aria-description": null
    },
    relatedConcepts: [{
      concept: {
        name: "mark"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Hu.default = s9;
});
var dA = y$1((Uu) => {
  Object.defineProperty(Uu, "__esModule", {
    value: true
  });
  Uu.default = void 0;
  var a9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Uu.default = a9;
});
var pA = y$1((Vu) => {
  Object.defineProperty(Vu, "__esModule", {
    value: true
  });
  Vu.default = void 0;
  var l9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "math"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Vu.default = l9;
});
var fA = y$1((zu) => {
  Object.defineProperty(zu, "__esModule", {
    value: true
  });
  zu.default = void 0;
  var u9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "vertical"
    },
    relatedConcepts: [{
      concept: {
        name: "MENU"
      },
      module: "JAPI"
    }, {
      concept: {
        name: "list"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }, {
      concept: {
        name: "sidebar"
      },
      module: "DTB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  }; zu.default = u9;
});
var mA = y$1((Gu) => {
  Object.defineProperty(Gu, "__esModule", {
    value: true
  });
  Gu.default = void 0;
  var c9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      concept: {
        name: "toolbar"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
  }; Gu.default = c9;
});
var hA = y$1((Wu) => {
  Object.defineProperty(Wu, "__esModule", {
    value: true
  });
  Wu.default = void 0;
  var d9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "MENU_ITEM"
      },
      module: "JAPI"
    }, {
      concept: {
        name: "listitem"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "option"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  }; Wu.default = d9;
});
var yA = y$1((Yu) => {
  Object.defineProperty(Yu, "__esModule", {
    value: true
  });
  Yu.default = void 0;
  var p9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menuitem"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
  }; Yu.default = p9;
});
var bA = y$1((Ku) => {
  Object.defineProperty(Ku, "__esModule", {
    value: true
  });
  Ku.default = void 0;
  var f9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menuitem"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
  }; Ku.default = f9;
});
var gA = y$1((Xu) => {
  Object.defineProperty(Xu, "__esModule", {
    value: true
  });
  Xu.default = void 0;
  var m9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuetext": null,
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [{
      concept: {
        name: "meter"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-valuenow": null
    },
    superClass: [["roletype", "structure", "range"]]
  }; Xu.default = m9;
});
var vA = y$1((Ju) => {
  Object.defineProperty(Ju, "__esModule", {
    value: true
  });
  Ju.default = void 0;
  var h9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "nav"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; Ju.default = h9;
});
var EA = y$1((Qu) => {
  Object.defineProperty(Qu, "__esModule", {
    value: true
  });
  Qu.default = void 0;
  var y9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: []
  }; Qu.default = y9;
});
var xA = y$1((Zu) => {
  Object.defineProperty(Zu, "__esModule", {
    value: true
  });
  Zu.default = void 0;
  var b9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Zu.default = b9;
});
var wA = y$1((ec) => {
  Object.defineProperty(ec, "__esModule", {
    value: true
  });
  ec.default = void 0;
  var g9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-posinset": null,
      "aria-setsize": null,
      "aria-selected": "false"
    },
    relatedConcepts: [{
      concept: {
        name: "item"
      },
      module: "XForms"
    }, {
      concept: {
        name: "listitem"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "option"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-selected": "false"
    },
    superClass: [["roletype", "widget", "input"]]
  }; ec.default = g9;
});
var TA = y$1((tc) => {
  Object.defineProperty(tc, "__esModule", {
    value: true
  });
  tc.default = void 0;
  var v9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "p"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; tc.default = v9;
});
var RA = y$1((rc) => {
  Object.defineProperty(rc, "__esModule", {
    value: true
  });
  rc.default = void 0;
  var E9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "alt",
          value: ""
        }],
        name: "img"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }; rc.default = E9;
});
var SA = y$1((nc) => {
  Object.defineProperty(nc, "__esModule", {
    value: true
  });
  nc.default = void 0;
  var x9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuetext": null
    },
    relatedConcepts: [{
      concept: {
        name: "progress"
      },
      module: "HTML"
    }, {
      concept: {
        name: "status"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
  }; nc.default = x9;
});
var _A = y$1((oc) => {
  Object.defineProperty(oc, "__esModule", {
    value: true
  });
  oc.default = void 0;
  var w9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "radio"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input"]]
  }; oc.default = w9;
});
var CA = y$1((ic) => {
  Object.defineProperty(ic, "__esModule", {
    value: true
  });
  ic.default = void 0;
  var T9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        name: "list"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["radio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  }; ic.default = T9;
});
var PA = y$1((sc) => {
  Object.defineProperty(sc, "__esModule", {
    value: true
  });
  sc.default = void 0;
  var R9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-label"
        }],
        name: "section"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-labelledby"
        }],
        name: "section"
      },
      module: "HTML"
    }, {
      concept: {
        name: "Device Independence Glossart perceivable unit"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; sc.default = R9;
});
var AA = y$1((ac) => {
  Object.defineProperty(ac, "__esModule", {
    value: true
  });
  ac.default = void 0;
  var S9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-colindex": null,
      "aria-expanded": null,
      "aria-level": null,
      "aria-posinset": null,
      "aria-rowindex": null,
      "aria-selected": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "tr"
      },
      module: "HTML"
    }],
    requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
    requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
    requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
  }; ac.default = S9;
});
var OA = y$1((lc) => {
  Object.defineProperty(lc, "__esModule", {
    value: true
  });
  lc.default = void 0;
  var _9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "tbody"
      },
      module: "HTML"
    }, {
      concept: {
        name: "tfoot"
      },
      module: "HTML"
    }, {
      concept: {
        name: "thead"
      },
      module: "HTML"
    }],
    requireContextRole: ["grid", "table", "treegrid"],
    requiredContextRole: ["grid", "table", "treegrid"],
    requiredOwnedElements: [["row"]],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }; lc.default = _9;
});
var qA = y$1((uc) => {
  Object.defineProperty(uc, "__esModule", {
    value: true
  });
  uc.default = void 0;
  var C9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-sort": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "scope",
          value: "row"
        }],
        name: "th"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "scope",
          value: "rowgroup"
        }],
        name: "th"
      },
      module: "HTML"
    }],
    requireContextRole: ["row", "rowgroup"],
    requiredContextRole: ["row", "rowgroup"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
  }; uc.default = C9;
});
var IA = y$1((cc) => {
  Object.defineProperty(cc, "__esModule", {
    value: true
  });
  cc.default = void 0;
  var P9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-valuetext": null,
      "aria-orientation": "vertical",
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-controls": null,
      "aria-valuenow": null
    },
    superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
  }; cc.default = P9;
});
var MA = y$1((dc) => {
  Object.defineProperty(dc, "__esModule", {
    value: true
  });
  dc.default = void 0;
  var A9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; dc.default = A9;
});
var NA = y$1((pc) => {
  Object.defineProperty(pc, "__esModule", {
    value: true
  });
  pc.default = void 0;
  var O9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "search"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "input", "textbox"]]
  }; pc.default = O9;
});
var jA = y$1((fc) => {
  Object.defineProperty(fc, "__esModule", {
    value: true
  });
  fc.default = void 0;
  var q9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-orientation": "horizontal",
      "aria-valuemax": "100",
      "aria-valuemin": "0",
      "aria-valuenow": null,
      "aria-valuetext": null
    },
    relatedConcepts: [{
      concept: {
        name: "hr"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }; fc.default = q9;
});
var kA = y$1((mc) => {
  Object.defineProperty(mc, "__esModule", {
    value: true
  });
  mc.default = void 0;
  var I9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-valuetext": null,
      "aria-orientation": "horizontal",
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "range"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-valuenow": null
    },
    superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
  }; mc.default = I9;
});
var LA = y$1((hc) => {
  Object.defineProperty(hc, "__esModule", {
    value: true
  });
  hc.default = void 0;
  var M9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-valuetext": null,
      "aria-valuenow": "0"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "number"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
  }; hc.default = M9;
});
var FA = y$1((yc) => {
  Object.defineProperty(yc, "__esModule", {
    value: true
  });
  yc.default = void 0;
  var N9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-atomic": "true",
      "aria-live": "polite"
    },
    relatedConcepts: [{
      concept: {
        name: "output"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; yc.default = N9;
});
var DA = y$1((bc) => {
  Object.defineProperty(bc, "__esModule", {
    value: true
  });
  bc.default = void 0;
  var j9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "strong"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; bc.default = j9;
});
var $A = y$1((gc) => {
  Object.defineProperty(gc, "__esModule", {
    value: true
  });
  gc.default = void 0;
  var k9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "sub"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; gc.default = k9;
});
var BA = y$1((vc) => {
  Object.defineProperty(vc, "__esModule", {
    value: true
  });
  vc.default = void 0;
  var L9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "sup"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; vc.default = L9;
});
var HA = y$1((Ec) => {
  Object.defineProperty(Ec, "__esModule", {
    value: true
  });
  Ec.default = void 0;
  var F9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "button"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox"]]
  }; Ec.default = F9;
});
var UA = y$1((xc) => {
  Object.defineProperty(xc, "__esModule", {
    value: true
  });
  xc.default = void 0;
  var D9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-posinset": null,
      "aria-setsize": null,
      "aria-selected": "false"
    },
    relatedConcepts: [],
    requireContextRole: ["tablist"],
    requiredContextRole: ["tablist"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
  }; xc.default = D9;
});
var VA = y$1((wc) => {
  Object.defineProperty(wc, "__esModule", {
    value: true
  });
  wc.default = void 0;
  var $9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-colcount": null,
      "aria-rowcount": null
    },
    relatedConcepts: [{
      concept: {
        name: "table"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; wc.default = $9;
});
var zA = y$1((Tc) => {
  Object.defineProperty(Tc, "__esModule", {
    value: true
  });
  Tc.default = void 0;
  var B9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-level": null,
      "aria-multiselectable": null,
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      module: "DAISY",
      concept: {
        name: "guide"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["tab"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"]]
  }; Tc.default = B9;
});
var GA = y$1((Rc) => {
  Object.defineProperty(Rc, "__esModule", {
    value: true
  });
  Rc.default = void 0;
  var H9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Rc.default = H9;
});
var WA = y$1((Sc) => {
  Object.defineProperty(Sc, "__esModule", {
    value: true
  });
  Sc.default = void 0;
  var U9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dfn"
      },
      module: "HTML"
    }, {
      concept: {
        name: "dt"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Sc.default = U9;
});
var YA = y$1((_c) => {
  Object.defineProperty(_c, "__esModule", {
    value: true
  });
  _c.default = void 0;
  var V9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-autocomplete": null,
      "aria-errormessage": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-multiline": null,
      "aria-placeholder": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "type"
        }, {
          constraints: ["undefined"],
          name: "list"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "email"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "tel"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "text"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "input"
      },
      module: "XForms"
    }, {
      concept: {
        name: "textarea"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "input"]]
  }; _c.default = V9;
});
var KA = y$1((Cc) => {
  Object.defineProperty(Cc, "__esModule", {
    value: true
  });
  Cc.default = void 0;
  var z9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "time"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Cc.default = z9;
});
var XA = y$1((Pc) => {
  Object.defineProperty(Pc, "__esModule", {
    value: true
  });
  Pc.default = void 0;
  var G9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "status"]]
  }; Pc.default = G9;
});
var JA = y$1((Ac) => {
  Object.defineProperty(Ac, "__esModule", {
    value: true
  });
  Ac.default = void 0;
  var W9 = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      concept: {
        name: "menubar"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"]]
  }; Ac.default = W9;
});
var QA = y$1((Oc) => {
  Object.defineProperty(Oc, "__esModule", {
    value: true
  });
  Oc.default = void 0;
  var Y9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Oc.default = Y9;
});
var ZA = y$1((qc) => {
  Object.defineProperty(qc, "__esModule", {
    value: true
  });
  qc.default = void 0;
  var K9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-multiselectable": null,
      "aria-required": null,
      "aria-orientation": "vertical"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  }; qc.default = K9;
});
var eO = y$1((Ic) => {
  Object.defineProperty(Ic, "__esModule", {
    value: true
  });
  Ic.default = void 0;
  var X9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
  }; Ic.default = X9;
});
var tO = y$1((Mc) => {
  Object.defineProperty(Mc, "__esModule", {
    value: true
  });
  Mc.default = void 0;
  var J9 = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-expanded": null,
      "aria-haspopup": null
    },
    relatedConcepts: [],
    requireContextRole: ["group", "tree"],
    requiredContextRole: ["group", "tree"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-selected": null
    },
    superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
  }; Mc.default = J9;
});
var rO = y$1((Nc) => {
  Object.defineProperty(Nc, "__esModule", {
    value: true
  });
  Nc.default = void 0;
  var Q9 = $(C0()), Z9 = $(P0()), e7 = $(A0()), t7 = $(O0()), r7 = $(q0()), n7 = $(I0()), o7 = $(M0()), i7 = $(N0()), s7 = $(j0()), a7 = $(k0()), l7 = $(L0()), u7 = $(F0()), c7 = $(D0()), d7 = $($0()), p7 = $(B0()), f7 = $(H0()), m7 = $(U0()), h7 = $(V0()), y7 = $(z0()), b7 = $(G0()), g7 = $(W0()), v7 = $(Y0()), E7 = $(K0()), x7 = $(X0()), w7 = $(J0()), T7 = $(Q0()), R7 = $(Z0()), S7 = $(eA()), _7 = $(tA()), C7 = $(rA()), P7 = $(nA()), A7 = $(oA()), O7 = $(iA()), q7 = $(sA()), I7 = $(aA()), M7 = $(lA()), N7 = $(uA()), j7 = $(cA()), k7 = $(dA()), L7 = $(pA()), F7 = $(fA()), D7 = $(mA()), $7 = $(hA()), B7 = $(yA()), H7 = $(bA()), U7 = $(gA()), V7 = $(vA()), z7 = $(EA()), G7 = $(xA()), W7 = $(wA()), Y7 = $(TA()), K7 = $(RA()), X7 = $(SA()), J7 = $(_A()), Q7 = $(CA()), Z7 = $(PA()), eK = $(AA()), tK = $(OA()), rK = $(qA()), nK = $(IA()), oK = $(MA()), iK = $(NA()), sK = $(jA()), aK = $(kA()), lK = $(LA()), uK = $(FA()), cK = $(DA()), dK = $($A()), pK = $(BA()), fK = $(HA()), mK = $(UA()), hK = $(VA()), yK = $(zA()), bK = $(GA()), gK = $(WA()), vK = $(YA()), EK = $(KA()), xK = $(XA()), wK = $(JA()), TK = $(QA()), RK = $(ZA()), SK = $(eO()), _K = $(tO());
  function $(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o($, "_interopRequireDefault");
  var CK = [
    ["alert", Q9.default],
    ["alertdialog", Z9.default],
    ["application", e7.default],
    ["article", t7.default],
    ["banner", r7.default],
    ["blockquote", n7.default],
    ["button", o7.default],
    ["caption", i7.default],
    ["cell", s7.default],
    ["checkbox", a7.default],
    ["code", l7.default],
    ["columnheader", u7.default],
    ["combobox", c7.default],
    ["complementary", d7.default],
    ["contentinfo", p7.default],
    ["definition", f7.default],
    ["deletion", m7.default],
    ["dialog", h7.default],
    ["directory", y7.default],
    ["document", b7.default],
    ["emphasis", g7.default],
    ["feed", v7.default],
    ["figure", E7.default],
    ["form", x7.default],
    ["generic", w7.default],
    ["grid", T7.default],
    ["gridcell", R7.default],
    [
      "group",
      S7.default
    ],
    ["heading", _7.default],
    ["img", C7.default],
    ["insertion", P7.default],
    ["link", A7.default],
    ["list", O7.default],
    ["listbox", q7.default],
    ["listitem", I7.default],
    ["log", M7.default],
    ["main", N7.default],
    ["mark", j7.default],
    ["marquee", k7.default],
    [
      "math",
      L7.default
    ],
    ["menu", F7.default],
    ["menubar", D7.default],
    ["menuitem", $7.default],
    ["menuitemcheckbox", B7.default],
    ["menuitemradio", H7.default],
    ["meter", U7.default],
    ["navigation", V7.default],
    ["none", z7.default],
    ["note", G7.default],
    ["option", W7.default],
    ["paragraph", Y7.default],
    ["presentation", K7.default],
    ["progressbar", X7.default],
    ["radio", J7.default],
    ["radiogroup", Q7.default],
    ["region", Z7.default],
    ["row", eK.default],
    ["rowgroup", tK.default],
    ["rowheader", rK.default],
    ["scrollbar", nK.default],
    ["search", oK.default],
    ["searchbox", iK.default],
    ["separator", sK.default],
    ["slider", aK.default],
    ["spinbutton", lK.default],
    ["status", uK.default],
    ["strong", cK.default],
    ["subscript", dK.default],
    ["superscript", pK.default],
    ["switch", fK.default],
    ["tab", mK.default],
    ["table", hK.default],
    ["tablist", yK.default],
    ["tabpanel", bK.default],
    ["term", gK.default],
    ["textbox", vK.default],
    ["time", EK.default],
    ["timer", xK.default],
    [
      "toolbar",
      wK.default
    ],
    ["tooltip", TK.default],
    ["tree", RK.default],
    ["treegrid", SK.default],
    ["treeitem", _K.default]
  ]; Nc.default = CK;
});
var nO = y$1((jc) => {
  Object.defineProperty(jc, "__esModule", {
    value: true
  });
  jc.default = void 0;
  var PK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "abstract [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; jc.default = PK;
});
var oO = y$1((kc) => {
  Object.defineProperty(kc, "__esModule", {
    value: true
  });
  kc.default = void 0;
  var AK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "acknowledgments [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; kc.default = AK;
});
var iO = y$1((Lc) => {
  Object.defineProperty(Lc, "__esModule", {
    value: true
  });
  Lc.default = void 0;
  var OK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "afterword [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; Lc.default = OK;
});
var sO = y$1((Fc) => {
  Object.defineProperty(Fc, "__esModule", {
    value: true
  });
  Fc.default = void 0;
  var qK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "appendix [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; Fc.default = qK;
});
var aO = y$1((Dc) => {
  Object.defineProperty(Dc, "__esModule", {
    value: true
  });
  Dc.default = void 0;
  var IK = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "referrer [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  }; Dc.default = IK;
});
var lO = y$1(($c) => {
  Object.defineProperty($c, "__esModule", {
    value: true
  });
  $c.default = void 0;
  var MK = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "EPUB biblioentry [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: ["doc-bibliography"],
    requiredContextRole: ["doc-bibliography"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "listitem"]]
  }; $c.default = MK;
});
var uO = y$1((Bc) => {
  Object.defineProperty(Bc, "__esModule", {
    value: true
  });
  Bc.default = void 0;
  var NK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "bibliography [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["doc-biblioentry"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; Bc.default = NK;
});
var cO = y$1((Hc) => {
  Object.defineProperty(Hc, "__esModule", {
    value: true
  });
  Hc.default = void 0;
  var jK = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "biblioref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  }; Hc.default = jK;
});
var dO = y$1((Uc) => {
  Object.defineProperty(Uc, "__esModule", {
    value: true
  });
  Uc.default = void 0;
  var kK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "chapter [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; Uc.default = kK;
});
var pO = y$1((Vc) => {
  Object.defineProperty(Vc, "__esModule", {
    value: true
  });
  Vc.default = void 0;
  var LK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "colophon [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Vc.default = LK;
});
var fO = y$1((zc) => {
  Object.defineProperty(zc, "__esModule", {
    value: true
  });
  zc.default = void 0;
  var FK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "conclusion [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; zc.default = FK;
});
var mO = y$1((Gc) => {
  Object.defineProperty(Gc, "__esModule", {
    value: true
  });
  Gc.default = void 0;
  var DK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "cover [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "img"]]
  }; Gc.default = DK;
});
var hO = y$1((Wc) => {
  Object.defineProperty(Wc, "__esModule", {
    value: true
  });
  Wc.default = void 0;
  var $K = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "credit [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Wc.default = $K;
});
var yO = y$1((Yc) => {
  Object.defineProperty(Yc, "__esModule", {
    value: true
  });
  Yc.default = void 0;
  var BK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "credits [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; Yc.default = BK;
});
var bO = y$1((Kc) => {
  Object.defineProperty(Kc, "__esModule", {
    value: true
  });
  Kc.default = void 0;
  var HK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "dedication [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Kc.default = HK;
});
var gO = y$1((Xc) => {
  Object.defineProperty(Xc, "__esModule", {
    value: true
  });
  Xc.default = void 0;
  var UK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "rearnote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: ["doc-endnotes"],
    requiredContextRole: ["doc-endnotes"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "listitem"]]
  }; Xc.default = UK;
});
var vO = y$1((Jc) => {
  Object.defineProperty(Jc, "__esModule", {
    value: true
  });
  Jc.default = void 0;
  var VK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "rearnotes [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["doc-endnote"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; Jc.default = VK;
});
var EO = y$1((Qc) => {
  Object.defineProperty(Qc, "__esModule", {
    value: true
  });
  Qc.default = void 0;
  var zK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "epigraph [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; Qc.default = zK;
});
var xO = y$1((Zc) => {
  Object.defineProperty(Zc, "__esModule", {
    value: true
  });
  Zc.default = void 0;
  var GK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "epilogue [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; Zc.default = GK;
});
var wO = y$1((ed) => {
  Object.defineProperty(ed, "__esModule", {
    value: true
  });
  ed.default = void 0;
  var WK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "errata [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; ed.default = WK;
});
var TO = y$1((td) => {
  Object.defineProperty(td, "__esModule", {
    value: true
  });
  td.default = void 0;
  var YK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; td.default = YK;
});
var RO = y$1((rd) => {
  Object.defineProperty(rd, "__esModule", {
    value: true
  });
  rd.default = void 0;
  var KK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "footnote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; rd.default = KK;
});
var SO = y$1((nd) => {
  Object.defineProperty(nd, "__esModule", {
    value: true
  });
  nd.default = void 0;
  var XK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "foreword [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; nd.default = XK;
});
var _O = y$1((od) => {
  Object.defineProperty(od, "__esModule", {
    value: true
  });
  od.default = void 0;
  var JK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "glossary [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["definition"], ["term"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; od.default = JK;
});
var CO = y$1((id) => {
  Object.defineProperty(id, "__esModule", {
    value: true
  });
  id.default = void 0;
  var QK = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "glossref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  }; id.default = QK;
});
var PO = y$1((sd) => {
  Object.defineProperty(sd, "__esModule", {
    value: true
  });
  sd.default = void 0;
  var ZK = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "index [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  }; sd.default = ZK;
});
var AO = y$1((ad) => {
  Object.defineProperty(ad, "__esModule", {
    value: true
  });
  ad.default = void 0;
  var eX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "introduction [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; ad.default = eX;
});
var OO = y$1((ld) => {
  Object.defineProperty(ld, "__esModule", {
    value: true
  });
  ld.default = void 0;
  var tX = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "noteref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  }; ld.default = tX;
});
var qO = y$1((ud) => {
  Object.defineProperty(ud, "__esModule", {
    value: true
  });
  ud.default = void 0;
  var rX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "notice [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "note"]]
  }; ud.default = rX;
});
var IO = y$1((cd) => {
  Object.defineProperty(cd, "__esModule", {
    value: true
  });
  cd.default = void 0;
  var nX = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "pagebreak [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "separator"]]
  }; cd.default = nX;
});
var MO = y$1((dd) => {
  Object.defineProperty(dd, "__esModule", {
    value: true
  });
  dd.default = void 0;
  var oX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: [],
    props: {
      "aria-braillelabel": null,
      "aria-brailleroledescription": null,
      "aria-description": null,
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; dd.default = oX;
});
var NO$1 = y$1((pd) => {
  Object.defineProperty(pd, "__esModule", {
    value: true
  });
  pd.default = void 0;
  var iX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: [],
    props: {
      "aria-braillelabel": null,
      "aria-brailleroledescription": null,
      "aria-description": null,
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; pd.default = iX;
});
var jO = y$1((fd) => {
  Object.defineProperty(fd, "__esModule", {
    value: true
  });
  fd.default = void 0;
  var sX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "page-list [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  }; fd.default = sX;
});
var kO = y$1((md) => {
  Object.defineProperty(md, "__esModule", {
    value: true
  });
  md.default = void 0;
  var aX = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "part [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; md.default = aX;
});
var LO = y$1((hd) => {
  Object.defineProperty(hd, "__esModule", {
    value: true
  });
  hd.default = void 0;
  var lX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "preface [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; hd.default = lX;
});
var FO = y$1((yd) => {
  Object.defineProperty(yd, "__esModule", {
    value: true
  });
  yd.default = void 0;
  var uX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "prologue [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }; yd.default = uX;
});
var DO = y$1((bd) => {
  Object.defineProperty(bd, "__esModule", {
    value: true
  });
  bd.default = void 0;
  var cX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "pullquote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["none"]]
  }; bd.default = cX;
});
var $O = y$1((gd) => {
  Object.defineProperty(gd, "__esModule", {
    value: true
  });
  gd.default = void 0;
  var dX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "qna [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }; gd.default = dX;
});
var BO = y$1((vd) => {
  Object.defineProperty(vd, "__esModule", {
    value: true
  });
  vd.default = void 0;
  var pX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "subtitle [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "sectionhead"]]
  }; vd.default = pX;
});
var HO = y$1((Ed) => {
  Object.defineProperty(Ed, "__esModule", {
    value: true
  });
  Ed.default = void 0;
  var fX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "help [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "note"]]
  }; Ed.default = fX;
});
var UO = y$1((xd) => {
  Object.defineProperty(xd, "__esModule", {
    value: true
  });
  xd.default = void 0;
  var mX = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "toc [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  }; xd.default = mX;
});
var VO = y$1((wd) => {
  Object.defineProperty(wd, "__esModule", {
    value: true
  });
  wd.default = void 0;
  var hX = re(nO()), yX = re(oO()), bX = re(iO()), gX = re(sO()), vX = re(aO()), EX = re(lO()), xX = re(uO()), wX = re(cO()), TX = re(dO()), RX = re(pO()), SX = re(fO()), _X = re(mO()), CX = re(hO()), PX = re(yO()), AX = re(bO()), OX = re(gO()), qX = re(vO()), IX = re(EO()), MX = re(
    xO()
  ), NX = re(wO()), jX = re(TO()), kX = re(RO()), LX = re(SO()), FX = re(_O()), DX = re(CO()), $X = re(PO()), BX = re(AO()), HX = re(OO()), UX = re(qO()), VX = re(IO()), zX = re(MO()), GX = re(NO$1()), WX = re(jO()), YX = re(kO()), KX = re(LO()), XX = re(FO()), JX = re(DO()), QX = re(
    $O()
  ), ZX = re(BO()), eJ = re(HO()), tJ = re(UO());
  function re(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(re, "_interopRequireDefault");
  var rJ = [
    ["doc-abstract", hX.default],
    ["doc-acknowledgments", yX.default],
    ["doc-afterword", bX.default],
    ["doc-appendix", gX.default],
    [
      "doc-backlink",
      vX.default
    ],
    ["doc-biblioentry", EX.default],
    ["doc-bibliography", xX.default],
    ["doc-biblioref", wX.default],
    ["doc-chapter", TX.default],
    ["doc-colophon", RX.default],
    ["doc-conclusion", SX.default],
    ["doc-cover", _X.default],
    ["doc-credit", CX.default],
    ["doc-credits", PX.default],
    ["doc-dedication", AX.default],
    ["doc-endnote", OX.default],
    ["doc-endnotes", qX.default],
    ["doc-epigraph", IX.default],
    ["doc-epilogue", MX.default],
    ["doc-errata", NX.default],
    ["doc-example", jX.default],
    ["doc-footnote", kX.default],
    ["doc-foreword", LX.default],
    ["doc-glossary", FX.default],
    ["doc-glossref", DX.default],
    ["doc-index", $X.default],
    ["doc-introduction", BX.default],
    ["doc-noteref", HX.default],
    ["doc-notice", UX.default],
    ["doc-pagebreak", VX.default],
    ["doc-pagefooter", zX.default],
    ["doc-pageheader", GX.default],
    ["doc-pagelist", WX.default],
    ["doc-part", YX.default],
    ["doc-preface", KX.default],
    ["doc-prologue", XX.default],
    ["doc-pullquote", JX.default],
    ["doc-qna", QX.default],
    ["doc-subtitle", ZX.default],
    ["doc-tip", eJ.default],
    ["doc-toc", tJ.default]
  ]; wd.default = rJ;
});
var zO = y$1((Td) => {
  Object.defineProperty(Td, "__esModule", {
    value: true
  });
  Td.default = void 0;
  var nJ = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      module: "GRAPHICS",
      concept: {
        name: "graphics-object"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "img"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "article"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "document"]]
  }; Td.default = nJ;
});
var GO = y$1((Rd) => {
  Object.defineProperty(Rd, "__esModule", {
    value: true
  });
  Rd.default = void 0;
  var oJ = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      module: "GRAPHICS",
      concept: {
        name: "graphics-document"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "group"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "img"
      }
    }, {
      module: "GRAPHICS",
      concept: {
        name: "graphics-symbol"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"]]
  }; Rd.default = oJ;
});
var WO = y$1((Sd) => {
  Object.defineProperty(Sd, "__esModule", {
    value: true
  });
  Sd.default = void 0;
  var iJ = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "img"]]
  }; Sd.default = iJ;
});
var YO = y$1((_d) => {
  Object.defineProperty(_d, "__esModule", {
    value: true
  });
  _d.default = void 0;
  var sJ = bE(zO()), aJ = bE(GO()), lJ = bE(WO());
  function bE(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(bE, "_interopRequireDefault");
  var uJ = [["graphics-document", sJ.default], ["graphics-object", aJ.default], ["graphics-symbol", lJ.default]]; _d.default = uJ;
});
var Pd = y$1((Cd) => {
  Object.defineProperty(Cd, "__esModule", {
    value: true
  });
  Cd.default = void 0;
  var cJ = ls(_0()), dJ = ls(rO()), pJ = ls(VO()), fJ = ls(YO()), mJ = ls(Oo());
  function ls(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(ls, "_interopRequireDefault");
  function gE(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = XO(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var n = 0, i = /* @__PURE__ */ o(function() {
        }, "F");
        return { s: i, n: /* @__PURE__ */ o(function() {
          return n >= e.length ? { done: true } : { done: false, value: e[n++] };
        }, "n"), e: /* @__PURE__ */ o(function(c) {
          throw c;
        }, "e"), f: i };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var s, a = true, l = false;
    return { s: /* @__PURE__ */ o(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ o(function() {
      var c = r.next();
      return a = c.done, c;
    }, "n"), e: /* @__PURE__ */ o(function(c) {
      l = true, s = c;
    }, "e"), f: /* @__PURE__ */ o(function() {
      try {
        a || r.return == null || r.return();
      } finally {
        if (l) throw s;
      }
    }, "f") };
  }
  o(gE, "_createForOfIteratorHelper");
  function as(e, t) {
    return bJ(e) || yJ(e, t) || XO(e, t) || hJ();
  }
  o(as, "_slicedToArray");
  function hJ() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  o(hJ, "_nonIterableRest");
  function XO(e, t) {
    if (e) {
      if (typeof e == "string") return KO(e, t);
      var r = {}.toString.call(e).slice(8, -1);
      return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? KO(e, t) : void 0;
    }
  }
  o(XO, "_unsupportedIterableToArray");
  function KO(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
    return n;
  }
  o(KO, "_arrayLikeToArray");
  function yJ(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
      var n, i, s, a, l = [], u = true, c = false;
      try {
        if (s = (r = r.call(e)).next, t === 0) {
          if (Object(r) !== r) return;
          u = false;
        } else for (; !(u = (n = s.call(r)).done) && (l.push(n.value), l.length !== t); u = true) ;
      } catch (d) {
        c = true, i = d;
      } finally {
        try {
          if (!u && r.return != null && (a = r.return(), Object(a) !== a)) return;
        } finally {
          if (c) throw i;
        }
      }
      return l;
    }
  }
  o(yJ, "_iterableToArrayLimit");
  function bJ(e) {
    if (Array.isArray(e)) return e;
  }
  o(bJ, "_arrayWithHoles");
  var Dr = [].concat(cJ.default, dJ.default, pJ.default, fJ.default);
  Dr.forEach(function(e) {
    var t = as(e, 2), r = t[1], n = gE(r.superClass), i;
    try {
      for (n.s(); !(i = n.n()).done; ) {
        var s = i.value, a = gE(s), l;
        try {
          var u = /* @__PURE__ */ o(function() {
            var d = l.value, p = Dr.filter(function(v) {
              var g = as(v, 1), w = g[0];
              return w === d;
            })[0];
            if (p)
              for (var f = p[1], m = 0, h = Object.keys(f.props); m < h.length; m++) {
                var b = h[m];
                Object.prototype.hasOwnProperty.call(r.props, b) || (r.props[b] = f.props[b]);
              }
          }, "_loop");
          for (a.s(); !(l = a.n()).done; )
            u();
        } catch (c) {
          a.e(c);
        } finally {
          a.f();
        }
      }
    } catch (c) {
      n.e(c);
    } finally {
      n.f();
    }
  });
  var vE = {
    entries: /* @__PURE__ */ o(function() {
      return Dr;
    }, "entries"),
    forEach: /* @__PURE__ */ o(function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = gE(Dr), i;
      try {
        for (n.s(); !(i = n.n()).done; ) {
          var s = as(i.value, 2), a = s[0], l = s[1];
          t.call(r, l, a, Dr);
        }
      } catch (u) {
        n.e(u);
      } finally {
        n.f();
      }
    }, "forEach"),
    get: /* @__PURE__ */ o(function(t) {
      var r = Dr.filter(function(n) {
        return n[0] === t;
      })[0];
      return r && r[1];
    }, "get"),
    has: /* @__PURE__ */ o(function(t) {
      return !!vE.get(t);
    }, "has"),
    keys: /* @__PURE__ */ o(function() {
      return Dr.map(function(t) {
        var r = as(t, 1), n = r[0];
        return n;
      });
    }, "keys"),
    values: /* @__PURE__ */ o(function() {
      return Dr.map(function(t) {
        var r = as(t, 2), n = r[1];
        return n;
      });
    }, "values")
  }; Cd.default = (0, mJ.default)(vE, vE.entries());
});
var nq = y$1((Md) => {
  Object.defineProperty(Md, "__esModule", {
    value: true
  });
  Md.default = void 0;
  var gJ = tq(Oo()), eq = tq(Pd());
  function tq(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(tq, "_interopRequireDefault");
  function EE(e, t) {
    return wJ(e) || xJ(e, t) || EJ(e, t) || vJ();
  }
  o(EE, "_slicedToArray");
  function vJ() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  o(vJ, "_nonIterableRest");
  function EJ(e, t) {
    if (e) {
      if (typeof e == "string") return JO(e, t);
      var r = {}.toString.call(e).slice(8, -1);
      return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? JO(e, t) : void 0;
    }
  }
  o(EJ, "_unsupportedIterableToArray");
  function JO(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
    return n;
  }
  o(JO, "_arrayLikeToArray");
  function xJ(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
      var n, i, s, a, l = [], u = true, c = false;
      try {
        if (s = (r = r.call(e)).next, t === 0) {
          if (Object(r) !== r) return;
          u = false;
        } else for (; !(u = (n = s.call(r)).done) && (l.push(n.value), l.length !== t); u = true) ;
      } catch (d) {
        c = true, i = d;
      } finally {
        try {
          if (!u && r.return != null && (a = r.return(), Object(a) !== a)) return;
        } finally {
          if (c) throw i;
        }
      }
      return l;
    }
  }
  o(xJ, "_iterableToArrayLimit");
  function wJ(e) {
    if (Array.isArray(e)) return e;
  }
  o(wJ, "_arrayWithHoles");
  var $r = [], QO = eq.default.keys();
  for (Ad = 0; Ad < QO.length; Ad++)
    if (Od = QO[Ad], qd = eq.default.get(Od), qd)
      for (xE = [].concat(qd.baseConcepts, qd.relatedConcepts), ZO = /* @__PURE__ */ o(function() {
        var t = xE[Id];
        if (t.module === "HTML") {
          var r = t.concept;
          if (r) {
            var n = $r.filter(function(l) {
              return TJ(l[0], r);
            })[0], i;
            n ? i = n[1] : i = [];
            for (var s = true, a = 0; a < i.length; a++)
              if (i[a] === Od) {
                s = false;
                break;
              }
            s && i.push(Od), n || $r.push([r, i]);
          }
        }
      }, "_loop"), Id = 0; Id < xE.length; Id++)
        ZO();
  var Od, qd, xE, ZO, Id, Ad, wE = {
    entries: /* @__PURE__ */ o(function() {
      return $r;
    }, "entries"),
    forEach: /* @__PURE__ */ o(function(t) {
      for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = 0, i = $r; n < i.length; n++) {
        var s = EE(i[n], 2), a = s[0], l = s[1];
        t.call(r, l, a, $r);
      }
    }, "forEach"),
    get: /* @__PURE__ */ o(function(t) {
      var r = $r.filter(function(n) {
        return t.name === n[0].name && rq(t.attributes, n[0].attributes);
      })[0];
      return r && r[1];
    }, "get"),
    has: /* @__PURE__ */ o(function(t) {
      return !!wE.get(t);
    }, "has"),
    keys: /* @__PURE__ */ o(function() {
      return $r.map(function(t) {
        var r = EE(t, 1), n = r[0];
        return n;
      });
    }, "keys"),
    values: /* @__PURE__ */ o(function() {
      return $r.map(function(t) {
        var r = EE(t, 2), n = r[1];
        return n;
      });
    }, "values")
  };
  function TJ(e, t) {
    return e.name === t.name && RJ(e.constraints, t.constraints) && rq(e.attributes, t.attributes);
  }
  o(TJ, "ariaRoleRelationConceptEquals");
  function RJ(e, t) {
    if (e === void 0 && t !== void 0 || e !== void 0 && t === void 0)
      return false;
    if (e !== void 0 && t !== void 0) {
      if (e.length !== t.length)
        return false;
      for (var r = 0; r < e.length; r++)
        if (e[r] !== t[r])
          return false;
    }
    return true;
  }
  o(RJ, "ariaRoleRelationConstraintsEquals");
  function rq(e, t) {
    if (e === void 0 && t !== void 0 || e !== void 0 && t === void 0)
      return false;
    if (e !== void 0 && t !== void 0) {
      if (e.length !== t.length)
        return false;
      for (var r = 0; r < e.length; r++) {
        if (e[r].name !== t[r].name || e[r].value !== t[r].value || e[r].constraints === void 0 && t[r].constraints !== void 0 || e[r].constraints !== void 0 && t[r].constraints === void 0)
          return false;
        if (e[r].constraints !== void 0 && t[r].constraints !== void 0) {
          if (e[r].constraints.length !== t[r].constraints.length)
            return false;
          for (var n = 0; n < e[r].constraints.length; n++)
            if (e[r].constraints[n] !== t[r].constraints[n])
              return false;
        }
      }
    }
    return true;
  }
  o(rq, "ariaRoleRelationConceptAttributeEquals");
  Md.default = (0, gJ.default)(wE, wE.entries());
});
var lq = y$1((Fd) => {
  Object.defineProperty(Fd, "__esModule", {
    value: true
  });
  Fd.default = void 0;
  var SJ = aq(Oo()), sq = aq(Pd());
  function aq(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(aq, "_interopRequireDefault");
  function TE(e, t) {
    return AJ(e) || PJ(e, t) || CJ(e, t) || _J();
  }
  o(TE, "_slicedToArray");
  function _J() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  o(_J, "_nonIterableRest");
  function CJ(e, t) {
    if (e) {
      if (typeof e == "string") return oq(e, t);
      var r = {}.toString.call(e).slice(8, -1);
      return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? oq(e, t) : void 0;
    }
  }
  o(CJ, "_unsupportedIterableToArray");
  function oq(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
    return n;
  }
  o(oq, "_arrayLikeToArray");
  function PJ(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
      var n, i, s, a, l = [], u = true, c = false;
      try {
        if (s = (r = r.call(e)).next, t === 0) {
          if (Object(r) !== r) return;
          u = false;
        } else for (; !(u = (n = s.call(r)).done) && (l.push(n.value), l.length !== t); u = true) ;
      } catch (d) {
        c = true, i = d;
      } finally {
        try {
          if (!u && r.return != null && (a = r.return(), Object(a) !== a)) return;
        } finally {
          if (c) throw i;
        }
      }
      return l;
    }
  }
  o(PJ, "_iterableToArrayLimit");
  function AJ(e) {
    if (Array.isArray(e)) return e;
  }
  o(AJ, "_arrayWithHoles");
  var _n = [], iq = sq.default.keys();
  for (Nd = 0; Nd < iq.length; Nd++)
    if (RE = iq[Nd], jd = sq.default.get(RE), kd = [], jd) {
      for (SE = [].concat(jd.baseConcepts, jd.relatedConcepts), Ld = 0; Ld < SE.length; Ld++)
        _E = SE[Ld], _E.module === "HTML" && (CE = _E.concept, CE != null && kd.push(CE));
      kd.length > 0 && _n.push([RE, kd]);
    }
  var RE, jd, kd, SE, _E, CE, Ld, Nd, PE = {
    entries: /* @__PURE__ */ o(function() {
      return _n;
    }, "entries"),
    forEach: /* @__PURE__ */ o(function(t) {
      for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = 0, i = _n; n < i.length; n++) {
        var s = TE(i[n], 2), a = s[0], l = s[1];
        t.call(r, l, a, _n);
      }
    }, "forEach"),
    get: /* @__PURE__ */ o(function(t) {
      var r = _n.filter(function(n) {
        return n[0] === t;
      })[0];
      return r && r[1];
    }, "get"),
    has: /* @__PURE__ */ o(function(t) {
      return !!PE.get(t);
    }, "has"),
    keys: /* @__PURE__ */ o(function() {
      return _n.map(function(t) {
        var r = TE(t, 1), n = r[0];
        return n;
      });
    }, "keys"),
    values: /* @__PURE__ */ o(function() {
      return _n.map(function(t) {
        var r = TE(t, 2), n = r[1];
        return n;
      });
    }, "values")
  }; Fd.default = (0, SJ.default)(PE, PE.entries());
});
var AE = y$1((Ot) => {
  Object.defineProperty(Ot, "__esModule", {
    value: true
  });
  Ot.roles = Ot.roleElements = Ot.elementRoles = Ot.dom = Ot.aria = void 0;
  var OJ = us(d0()), qJ = us(f0()), IJ = us(Pd()), MJ = us(nq()), NJ = us(lq());
  function us(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(us, "_interopRequireDefault");
  Ot.aria = OJ.default; Ot.dom = qJ.default; Ot.roles = IJ.default; Ot.elementRoles = MJ.default; Ot.roleElements = NJ.default;
});
var cq = y$1((o1e, uq) => {
  uq.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});
var OE = y$1((i1e, pq) => {
  var cs = cq(), dq = {};
  for (let e of Object.keys(cs))
    dq[cs[e]] = e;
  var z = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  pq.exports = z;
  for (let e of Object.keys(z)) {
    if (!("channels" in z[e]))
      throw new Error("missing channels property: " + e);
    if (!("labels" in z[e]))
      throw new Error("missing channel labels property: " + e);
    if (z[e].labels.length !== z[e].channels)
      throw new Error("channel and label counts mismatch: " + e);
    let { channels: t, labels: r } = z[e];
    delete z[e].channels, delete z[e].labels, Object.defineProperty(z[e], "channels", { value: t }), Object.defineProperty(z[e], "labels", {
      value: r
    });
  }
  z.rgb.hsl = function(e) {
    let t = e[0] / 255, r = e[1] / 255, n = e[2] / 255, i = Math.min(t, r, n), s = Math.max(t, r, n), a = s - i, l, u;
    s === i ? l = 0 : t === s ? l = (r - n) / a : r === s ? l = 2 + (n - t) / a : n === s && (l = 4 + (t - r) / a), l = Math.min(l * 60, 360), l < 0 && (l += 360);
    let c = (i + s) / 2;
    return s === i ? u = 0 : c <= 0.5 ? u = a / (s + i) : u = a / (2 - s - i), [l, u * 100, c * 100];
  };
  z.rgb.hsv = function(e) {
    let t, r, n, i, s, a = e[0] / 255, l = e[1] / 255, u = e[2] / 255, c = Math.max(a, l, u), d = c - Math.min(a, l, u), p = /* @__PURE__ */ o(
      function(f) {
        return (c - f) / 6 / d + 1 / 2;
      },
      "diffc"
    );
    return d === 0 ? (i = 0, s = 0) : (s = d / c, t = p(a), r = p(l), n = p(u), a === c ? i = n - r : l === c ? i = 1 / 3 + t - n : u === c && (i = 2 / 3 + r - t), i < 0 ? i += 1 : i > 1 && (i -= 1)), [
      i * 360,
      s * 100,
      c * 100
    ];
  };
  z.rgb.hwb = function(e) {
    let t = e[0], r = e[1], n = e[2], i = z.rgb.hsl(e)[0], s = 1 / 255 * Math.min(t, Math.min(r, n));
    return n = 1 - 1 / 255 * Math.max(t, Math.max(r, n)), [i, s * 100, n * 100];
  };
  z.rgb.cmyk = function(e) {
    let t = e[0] / 255, r = e[1] / 255, n = e[2] / 255, i = Math.min(1 - t, 1 - r, 1 - n), s = (1 - t - i) / (1 - i) || 0, a = (1 - r - i) / (1 - i) || 0, l = (1 - n - i) / (1 - i) || 0;
    return [s * 100, a * 100, l * 100, i * 100];
  };
  function jJ(e, t) {
    return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
  }
  o(jJ, "comparativeDistance");
  z.rgb.keyword = function(e) {
    let t = dq[e];
    if (t)
      return t;
    let r = 1 / 0, n;
    for (let i of Object.keys(cs)) {
      let s = cs[i], a = jJ(e, s);
      a < r && (r = a, n = i);
    }
    return n;
  };
  z.keyword.rgb = function(e) {
    return cs[e];
  };
  z.rgb.xyz = function(e) {
    let t = e[0] / 255, r = e[1] / 255, n = e[2] / 255;
    t = t > 0.04045 ? ((t + 0.055) / 1.055) ** 2.4 : t / 12.92, r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92, n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
    let i = t * 0.4124 + r * 0.3576 + n * 0.1805, s = t * 0.2126 + r * 0.7152 + n * 0.0722, a = t * 0.0193 + r * 0.1192 + n * 0.9505;
    return [i * 100, s * 100, a * 100];
  };
  z.rgb.lab = function(e) {
    let t = z.rgb.xyz(e), r = t[0], n = t[1], i = t[2];
    r /= 95.047, n /= 100, i /= 108.883, r = r > 8856e-6 ? r ** (1 / 3) : 7.787 * r + 16 / 116, n = n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116;
    let s = 116 * n - 16, a = 500 * (r - n), l = 200 * (n - i);
    return [s, a, l];
  };
  z.hsl.rgb = function(e) {
    let t = e[0] / 360, r = e[1] / 100, n = e[2] / 100, i, s, a;
    if (r === 0)
      return a = n * 255, [a, a, a];
    n < 0.5 ? i = n * (1 + r) : i = n + r - n * r;
    let l = 2 * n - i, u = [0, 0, 0];
    for (let c = 0; c < 3; c++)
      s = t + 1 / 3 * -(c - 1), s < 0 && s++, s > 1 && s--, 6 * s < 1 ? a = l + (i - l) * 6 * s : 2 * s < 1 ? a = i : 3 * s < 2 ? a = l + (i - l) * (2 / 3 - s) * 6 : a = l, u[c] = a * 255;
    return u;
  };
  z.hsl.hsv = function(e) {
    let t = e[0], r = e[1] / 100, n = e[2] / 100, i = r, s = Math.max(n, 0.01);
    n *= 2, r *= n <= 1 ? n : 2 - n, i *= s <= 1 ? s : 2 - s;
    let a = (n + r) / 2, l = n === 0 ? 2 * i / (s + i) : 2 * r / (n + r);
    return [t, l * 100, a * 100];
  };
  z.hsv.rgb = function(e) {
    let t = e[0] / 60, r = e[1] / 100, n = e[2] / 100, i = Math.floor(t) % 6, s = t - Math.floor(t), a = 255 * n * (1 - r), l = 255 * n * (1 - r * s), u = 255 * n * (1 - r * (1 - s));
    switch (n *= 255, i) {
      case 0:
        return [n, u, a];
      case 1:
        return [l, n, a];
      case 2:
        return [a, n, u];
      case 3:
        return [a, l, n];
      case 4:
        return [u, a, n];
      case 5:
        return [n, a, l];
    }
  };
  z.hsv.hsl = function(e) {
    let t = e[0], r = e[1] / 100, n = e[2] / 100, i = Math.max(n, 0.01), s, a;
    a = (2 - r) * n;
    let l = (2 - r) * i;
    return s = r * i, s /= l <= 1 ? l : 2 - l, s = s || 0, a /= 2, [t, s * 100, a * 100];
  };
  z.hwb.rgb = function(e) {
    let t = e[0] / 360, r = e[1] / 100, n = e[2] / 100, i = r + n, s;
    i > 1 && (r /= i, n /= i);
    let a = Math.floor(6 * t), l = 1 - n;
    s = 6 * t - a, (a & 1) !== 0 && (s = 1 - s);
    let u = r + s * (l - r), c, d, p;
    switch (a) {
      default:
      case 6:
      case 0:
        c = l, d = u, p = r;
        break;
      case 1:
        c = u, d = l, p = r;
        break;
      case 2:
        c = r, d = l, p = u;
        break;
      case 3:
        c = r, d = u, p = l;
        break;
      case 4:
        c = u, d = r, p = l;
        break;
      case 5:
        c = l, d = r, p = u;
        break;
    }
    return [c * 255, d * 255, p * 255];
  };
  z.cmyk.rgb = function(e) {
    let t = e[0] / 100, r = e[1] / 100, n = e[2] / 100, i = e[3] / 100, s = 1 - Math.min(1, t * (1 - i) + i), a = 1 - Math.min(1, r * (1 - i) + i), l = 1 - Math.min(1, n * (1 - i) + i);
    return [s * 255, a * 255, l * 255];
  };
  z.xyz.rgb = function(e) {
    let t = e[0] / 100, r = e[1] / 100, n = e[2] / 100, i, s, a;
    return i = t * 3.2406 + r * -1.5372 + n * -0.4986, s = t * -0.9689 + r * 1.8758 + n * 0.0415, a = t * 0.0557 + r * -0.204 + n * 1.057, i = i > 31308e-7 ? 1.055 * i ** (1 / 2.4) - 0.055 : i * 12.92, s = s > 31308e-7 ? 1.055 * s ** (1 / 2.4) - 0.055 : s * 12.92, a = a > 31308e-7 ? 1.055 * a ** (1 / 2.4) - 0.055 : a * 12.92, i = Math.min(Math.max(0, i), 1), s = Math.min(Math.max(0, s), 1), a = Math.min(
      Math.max(0, a),
      1
    ), [i * 255, s * 255, a * 255];
  };
  z.xyz.lab = function(e) {
    let t = e[0], r = e[1], n = e[2];
    t /= 95.047, r /= 100, n /= 108.883, t = t > 8856e-6 ? t ** (1 / 3) : 7.787 * t + 16 / 116, r = r > 8856e-6 ? r ** (1 / 3) : 7.787 * r + 16 / 116, n = n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
    let i = 116 * r - 16, s = 500 * (t - r), a = 200 * (r - n);
    return [i, s, a];
  };
  z.lab.xyz = function(e) {
    let t = e[0], r = e[1], n = e[2], i, s, a;
    s = (t + 16) / 116, i = r / 500 + s, a = s - n / 200;
    let l = s ** 3, u = i ** 3, c = a ** 3;
    return s = l > 8856e-6 ? l : (s - 16 / 116) / 7.787, i = u > 8856e-6 ? u : (i - 16 / 116) / 7.787, a = c > 8856e-6 ? c : (a - 16 / 116) / 7.787, i *= 95.047, s *= 100, a *= 108.883, [i, s, a];
  };
  z.lab.lch = function(e) {
    let t = e[0], r = e[1], n = e[2], i;
    i = Math.atan2(n, r) * 360 / 2 / Math.PI, i < 0 && (i += 360);
    let a = Math.sqrt(r * r + n * n);
    return [t, a, i];
  };
  z.lch.lab = function(e) {
    let t = e[0], r = e[1], i = e[2] / 360 * 2 * Math.PI, s = r * Math.cos(i), a = r * Math.sin(i);
    return [t, s, a];
  };
  z.rgb.ansi16 = function(e, t = null) {
    let [r, n, i] = e, s = t === null ? z.rgb.hsv(e)[2] : t;
    if (s = Math.round(s / 50), s === 0)
      return 30;
    let a = 30 + (Math.round(i / 255) << 2 | Math.round(n / 255) << 1 | Math.round(r / 255));
    return s === 2 && (a += 60), a;
  };
  z.hsv.ansi16 = function(e) {
    return z.rgb.ansi16(z.hsv.rgb(e), e[2]);
  };
  z.rgb.ansi256 = function(e) {
    let t = e[0], r = e[1], n = e[2];
    return t === r && r === n ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(n / 255 * 5);
  };
  z.ansi16.rgb = function(e) {
    let t = e % 10;
    if (t === 0 || t === 7)
      return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
    let r = (~~(e > 50) + 1) * 0.5, n = (t & 1) * r * 255, i = (t >> 1 & 1) * r * 255, s = (t >> 2 & 1) * r * 255;
    return [n, i, s];
  };
  z.ansi256.rgb = function(e) {
    if (e >= 232) {
      let s = (e - 232) * 10 + 8;
      return [s, s, s];
    }
    e -= 16;
    let t, r = Math.floor(e / 36) / 5 * 255, n = Math.floor((t = e % 36) / 6) / 5 * 255, i = t % 6 / 5 * 255;
    return [r, n, i];
  };
  z.rgb.hex = function(e) {
    let r = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(r.length) + r;
  };
  z.hex.rgb = function(e) {
    let t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t)
      return [0, 0, 0];
    let r = t[0];
    t[0].length === 3 && (r = r.split("").map((l) => l + l).join(""));
    let n = parseInt(r, 16), i = n >> 16 & 255, s = n >> 8 & 255, a = n & 255;
    return [i, s, a];
  };
  z.rgb.hcg = function(e) {
    let t = e[0] / 255, r = e[1] / 255, n = e[2] / 255, i = Math.max(Math.max(t, r), n), s = Math.min(Math.min(t, r), n), a = i - s, l, u;
    return a < 1 ? l = s / (1 - a) : l = 0, a <= 0 ? u = 0 : i === t ? u = (r - n) / a % 6 : i === r ? u = 2 + (n - t) / a : u = 4 + (t - r) / a, u /= 6, u %= 1, [u * 360, a * 100, l * 100];
  };
  z.hsl.hcg = function(e) {
    let t = e[1] / 100, r = e[2] / 100, n = r < 0.5 ? 2 * t * r : 2 * t * (1 - r), i = 0;
    return n < 1 && (i = (r - 0.5 * n) / (1 - n)), [e[0], n * 100, i * 100];
  };
  z.hsv.hcg = function(e) {
    let t = e[1] / 100, r = e[2] / 100, n = t * r, i = 0;
    return n < 1 && (i = (r - n) / (1 - n)), [e[0], n * 100, i * 100];
  };
  z.hcg.rgb = function(e) {
    let t = e[0] / 360, r = e[1] / 100, n = e[2] / 100;
    if (r === 0)
      return [n * 255, n * 255, n * 255];
    let i = [0, 0, 0], s = t % 1 * 6, a = s % 1, l = 1 - a, u = 0;
    switch (Math.floor(s)) {
      case 0:
        i[0] = 1, i[1] = a, i[2] = 0;
        break;
      case 1:
        i[0] = l, i[1] = 1, i[2] = 0;
        break;
      case 2:
        i[0] = 0, i[1] = 1, i[2] = a;
        break;
      case 3:
        i[0] = 0, i[1] = l, i[2] = 1;
        break;
      case 4:
        i[0] = a, i[1] = 0, i[2] = 1;
        break;
      default:
        i[0] = 1, i[1] = 0, i[2] = l;
    }
    return u = (1 - r) * n, [
      (r * i[0] + u) * 255,
      (r * i[1] + u) * 255,
      (r * i[2] + u) * 255
    ];
  };
  z.hcg.hsv = function(e) {
    let t = e[1] / 100, r = e[2] / 100, n = t + r * (1 - t), i = 0;
    return n > 0 && (i = t / n), [e[0], i * 100, n * 100];
  };
  z.hcg.hsl = function(e) {
    let t = e[1] / 100, n = e[2] / 100 * (1 - t) + 0.5 * t, i = 0;
    return n > 0 && n < 0.5 ? i = t / (2 * n) : n >= 0.5 && n < 1 && (i = t / (2 * (1 - n))), [e[0], i * 100, n * 100];
  };
  z.hcg.hwb = function(e) {
    let t = e[1] / 100, r = e[2] / 100, n = t + r * (1 - t);
    return [e[0], (n - t) * 100, (1 - n) * 100];
  };
  z.hwb.hcg = function(e) {
    let t = e[1] / 100, n = 1 - e[2] / 100, i = n - t, s = 0;
    return i < 1 && (s = (n - i) / (1 - i)), [e[0], i * 100, s * 100];
  };
  z.apple.rgb = function(e) {
    return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
  };
  z.rgb.apple = function(e) {
    return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
  };
  z.gray.rgb = function(e) {
    return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
  };
  z.gray.hsl = function(e) {
    return [0, 0, e[0]];
  };
  z.gray.hsv = z.gray.hsl;
  z.gray.hwb = function(e) {
    return [0, 100, e[0]];
  };
  z.gray.cmyk = function(e) {
    return [0, 0, 0, e[0]];
  };
  z.gray.lab = function(e) {
    return [e[0], 0, 0];
  };
  z.gray.hex = function(e) {
    let t = Math.round(e[0] / 100 * 255) & 255, n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
    return "000000".substring(n.length) + n;
  };
  z.rgb.gray = function(e) {
    return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
  };
});
var mq = y$1((a1e, fq) => {
  var Dd = OE();
  function kJ() {
    let e = {}, t = Object.keys(Dd);
    for (let r = t.length, n = 0; n < r; n++)
      e[t[n]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return e;
  }
  o(kJ, "buildGraph");
  function LJ(e) {
    let t = kJ(), r = [e];
    for (t[e].distance = 0; r.length; ) {
      let n = r.pop(), i = Object.keys(Dd[n]);
      for (let s = i.length, a = 0; a < s; a++) {
        let l = i[a], u = t[l];
        u.distance === -1 && (u.distance = t[n].distance + 1, u.parent = n, r.unshift(l));
      }
    }
    return t;
  }
  o(LJ, "deriveBFS");
  function FJ(e, t) {
    return function(r) {
      return t(e(r));
    };
  }
  o(FJ, "link");
  function DJ(e, t) {
    let r = [t[e].parent, e], n = Dd[t[e].parent][e], i = t[e].parent;
    for (; t[i].parent; )
      r.unshift(t[i].parent), n = FJ(Dd[t[i].parent][i], n), i = t[i].parent;
    return n.conversion = r, n;
  }
  o(DJ, "wrapConversion");
  fq.exports = function(e) {
    let t = LJ(e), r = {}, n = Object.keys(t);
    for (let i = n.length, s = 0; s < i; s++) {
      let a = n[s];
      t[a].parent !== null && (r[a] = DJ(a, t));
    }
    return r;
  };
});
var yq = y$1((u1e, hq) => {
  var qE = OE(), $J = mq(), Mo = {}, BJ = Object.keys(qE);
  function HJ(e) {
    let t = /* @__PURE__ */ o(function(...r) {
      let n = r[0];
      return n == null ? n : (n.length > 1 && (r = n), e(r));
    }, "wrappedFn");
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  o(HJ, "wrapRaw");
  function UJ(e) {
    let t = /* @__PURE__ */ o(function(...r) {
      let n = r[0];
      if (n == null)
        return n;
      n.length > 1 && (r = n);
      let i = e(r);
      if (typeof i == "object")
        for (let s = i.length, a = 0; a < s; a++)
          i[a] = Math.round(i[a]);
      return i;
    }, "wrappedFn");
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  o(UJ, "wrapRounded");
  BJ.forEach((e) => {
    Mo[e] = {}, Object.defineProperty(Mo[e], "channels", { value: qE[e].channels }), Object.defineProperty(Mo[e], "labels", { value: qE[e].labels });
    let t = $J(e);
    Object.keys(t).forEach((n) => {
      let i = t[n];
      Mo[e][n] = UJ(i), Mo[e][n].raw = HJ(i);
    });
  });
  hq.exports = Mo;
});
var wq = y$1((d1e, xq) => {
  var bq = /* @__PURE__ */ o((e, t) => (...r) => `\x1B[${e(...r) + t}m`, "wrapAnsi16"), gq = /* @__PURE__ */ o((e, t) => (...r) => {
    let n = e(...r);
    return `\x1B[${38 + t};5;${n}m`;
  }, "wrapAnsi256"), vq = /* @__PURE__ */ o((e, t) => (...r) => {
    let n = e(...r);
    return `\x1B[${38 + t};2;${n[0]};${n[1]};${n[2]}m`;
  }, "wrapAnsi16m"), $d = /* @__PURE__ */ o((e) => e, "ansi2ansi"), Eq = /* @__PURE__ */ o((e, t, r) => [e, t, r], "rgb2rgb"), No = /* @__PURE__ */ o(
    (e, t, r) => {
      Object.defineProperty(e, t, {
        get: /* @__PURE__ */ o(() => {
          let n = r();
          return Object.defineProperty(e, t, {
            value: n,
            enumerable: true,
            configurable: true
          }), n;
        }, "get"),
        enumerable: true,
        configurable: true
      });
    },
    "setLazyProperty"
  ), IE, jo = /* @__PURE__ */ o((e, t, r, n) => {
    IE === void 0 && (IE = yq());
    let i = n ? 10 : 0, s = {};
    for (let [a, l] of Object.entries(IE)) {
      let u = a === "ansi16" ? "ansi" : a;
      a === t ? s[u] = e(r, i) : typeof l == "object" && (s[u] = e(l[t], i));
    }
    return s;
  }, "makeDynamicStyles");
  function VJ() {
    let e = /* @__PURE__ */ new Map(), t = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    t.color.gray = t.color.blackBright, t.bgColor.bgGray = t.bgColor.bgBlackBright, t.color.grey = t.color.blackBright, t.bgColor.bgGrey = t.bgColor.bgBlackBright;
    for (let [r, n] of Object.entries(t)) {
      for (let [i, s] of Object.entries(n))
        t[i] = {
          open: `\x1B[${s[0]}m`,
          close: `\x1B[${s[1]}m`
        }, n[i] = t[i], e.set(s[0], s[1]);
      Object.defineProperty(t, r, {
        value: n,
        enumerable: false
      });
    }
    return Object.defineProperty(t, "codes", {
      value: e,
      enumerable: false
    }), t.color.close = "\x1B[39m", t.bgColor.close = "\x1B[49m", No(t.color, "ansi", () => jo(bq, "ansi16", $d, false)), No(
      t.color,
      "ansi256",
      () => jo(gq, "ansi256", $d, false)
    ), No(t.color, "ansi16m", () => jo(vq, "rgb", Eq, false)), No(t.bgColor, "ansi", () => jo(bq, "ansi16", $d, true)), No(t.bgColor, "ansi256", () => jo(gq, "ansi256", $d, true)), No(t.bgColor, "ansi16m", () => jo(vq, "rgb", Eq, true)), t;
  }
  o(VJ, "assembleStyles");
  Object.defineProperty(xq, "exports", {
    enumerable: true,
    get: VJ
  });
});
var Rq = y$1((f1e, Tq) => {
  Tq.exports = {
    stdout: false,
    stderr: false
  };
});
var _q = y$1((m1e, Sq) => {
  var zJ = /* @__PURE__ */ o((e, t, r) => {
    let n = e.indexOf(t);
    if (n === -1)
      return e;
    let i = t.length, s = 0, a = "";
    do
      a += e.substr(s, n - s) + t + r, s = n + i, n = e.indexOf(t, s);
    while (n !== -1);
    return a += e.substr(s), a;
  }, "stringReplaceAll"), GJ = /* @__PURE__ */ o((e, t, r, n) => {
    let i = 0, s = "";
    do {
      let a = e[n - 1] === "\r";
      s += e.substr(i, (a ? n - 1 : n) - i) + t + (a ? `\r
` : `
`) + r, i = n + 1, n = e.indexOf(`
`, i);
    } while (n !== -1);
    return s += e.substr(i), s;
  }, "stringEncaseCRLFWithFirstIndex");
  Sq.exports = {
    stringReplaceAll: zJ,
    stringEncaseCRLFWithFirstIndex: GJ
  };
});
var qq = y$1((y1e, Oq) => {
  var WJ = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Cq = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, YJ = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, KJ = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi, XJ = /* @__PURE__ */ new Map([
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function Aq(e) {
    let t = e[0] === "u", r = e[1] === "{";
    return t && !r && e.length === 5 || e[0] === "x" && e.length === 3 ? String.fromCharCode(parseInt(e.slice(1), 16)) : t && r ? String.fromCodePoint(
      parseInt(e.slice(2, -1), 16)
    ) : XJ.get(e) || e;
  }
  o(Aq, "unescape");
  function JJ(e, t) {
    let r = [], n = t.trim().split(/\s*,\s*/g), i;
    for (let s of n) {
      let a = Number(s);
      if (!Number.isNaN(a))
        r.push(a);
      else if (i = s.match(YJ))
        r.push(i[2].replace(KJ, (l, u, c) => u ? Aq(u) : c));
      else
        throw new Error(`Invalid Chalk template style argument: ${s} (in style '${e}')`);
    }
    return r;
  }
  o(JJ, "parseArguments");
  function QJ(e) {
    Cq.lastIndex = 0;
    let t = [], r;
    for (; (r = Cq.exec(e)) !== null; ) {
      let n = r[1];
      if (r[2]) {
        let i = JJ(n, r[2]);
        t.push([n].concat(i));
      } else
        t.push([n]);
    }
    return t;
  }
  o(QJ, "parseStyle");
  function Pq(e, t) {
    let r = {};
    for (let i of t)
      for (let s of i.styles)
        r[s[0]] = i.inverse ? null : s.slice(1);
    let n = e;
    for (let [i, s] of Object.entries(r))
      if (Array.isArray(s)) {
        if (!(i in n))
          throw new Error(`Unknown Chalk style: ${i}`);
        n = s.length > 0 ? n[i](...s) : n[i];
      }
    return n;
  }
  o(Pq, "buildStyle");
  Oq.exports = (e, t) => {
    let r = [], n = [], i = [];
    if (t.replace(WJ, (s, a, l, u, c, d) => {
      if (a)
        i.push(Aq(a));
      else if (u) {
        let p = i.join("");
        i = [], n.push(r.length === 0 ? p : Pq(e, r)(p)), r.push({ inverse: l, styles: QJ(u) });
      } else if (c) {
        if (r.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        n.push(Pq(e, r)(i.join(""))), i = [], r.pop();
      } else
        i.push(d);
    }), n.push(i.join("")), r.length > 0) {
      let s = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(s);
    }
    return n.join("");
  };
});
var DE = y$1((g1e, jq) => {
  var ds = wq(), { stdout: NE, stderr: jE } = Rq(), {
    stringReplaceAll: ZJ,
    stringEncaseCRLFWithFirstIndex: eQ
  } = _q(), Iq = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ], ko = /* @__PURE__ */ Object.create(null), tQ = /* @__PURE__ */ o((e, t = {}) => {
    if (t.level > 3 || t.level < 0)
      throw new Error("The `level` option should be an integer from 0 to 3");
    let r = NE ? NE.level : 0;
    e.level = t.level === void 0 ? r : t.level;
  }, "applyOptions"), FE = class FE {
    constructor(t) {
      return Mq(t);
    }
  };
  o(FE, "ChalkClass");
  var kE = FE, Mq = /* @__PURE__ */ o((e) => {
    let t = {};
    return tQ(t, e), t.template = (...r) => oQ(t.template, ...r), Object.setPrototypeOf(t, Bd.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    }, t.template.Instance = kE, t.template;
  }, "chalkFactory");
  function Bd(e) {
    return Mq(e);
  }
  o(Bd, "Chalk");
  for (let [e, t] of Object.entries(ds))
    ko[e] = {
      get() {
        let r = Hd(this, LE(t.open, t.close, this._styler), this._isEmpty);
        return Object.defineProperty(this, e, { value: r }), r;
      }
    };
  ko.visible = {
    get() {
      let e = Hd(this, this._styler, true);
      return Object.defineProperty(this, "visible", { value: e }), e;
    }
  };
  var Nq = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (let e of Nq)
    ko[e] = {
      get() {
        let { level: t } = this;
        return function(...r) {
          let n = LE(ds.color[Iq[t]][e](...r), ds.color.close, this._styler);
          return Hd(this, n, this._isEmpty);
        };
      }
    };
  for (let e of Nq) {
    let t = "bg" + e[0].toUpperCase() + e.slice(1);
    ko[t] = {
      get() {
        let { level: r } = this;
        return function(...n) {
          let i = LE(ds.bgColor[Iq[r]][e](...n), ds.bgColor.close, this._styler);
          return Hd(this, i, this._isEmpty);
        };
      }
    };
  }
  var rQ = Object.defineProperties(() => {
  }, {
    ...ko,
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(e) {
        this._generator.level = e;
      }
    }
  }), LE = /* @__PURE__ */ o((e, t, r) => {
    let n, i;
    return r === void 0 ? (n = e, i = t) : (n = r.openAll + e, i = t + r.closeAll), {
      open: e,
      close: t,
      openAll: n,
      closeAll: i,
      parent: r
    };
  }, "createStyler"), Hd = /* @__PURE__ */ o((e, t, r) => {
    let n = /* @__PURE__ */ o((...i) => nQ(n, i.length === 1 ? "" + i[0] : i.join(" ")), "builder");
    return n.__proto__ = rQ, n._generator = e, n._styler = t, n._isEmpty = r, n;
  }, "createBuilder"), nQ = /* @__PURE__ */ o((e, t) => {
    if (e.level <= 0 || !t)
      return e._isEmpty ? "" : t;
    let r = e._styler;
    if (r === void 0)
      return t;
    let { openAll: n, closeAll: i } = r;
    if (t.indexOf("\x1B") !== -1)
      for (; r !== void 0; )
        t = ZJ(t, r.close, r.open), r = r.parent;
    let s = t.indexOf(`
`);
    return s !== -1 && (t = eQ(t, i, n, s)), n + t + i;
  }, "applyStyle"), ME, oQ = /* @__PURE__ */ o((e, ...t) => {
    let [r] = t;
    if (!Array.isArray(r))
      return t.join(" ");
    let n = t.slice(1), i = [r.raw[0]];
    for (let s = 1; s < r.length; s++)
      i.push(
        String(n[s - 1]).replace(/[{}\\]/g, "\\$&"),
        String(r.raw[s])
      );
    return ME === void 0 && (ME = qq()), ME(e, i.join(""));
  }, "chalkTag");
  Object.defineProperties(Bd.prototype, ko);
  var ps = Bd();
  ps.supportsColor = NE;
  ps.stderr = Bd({ level: jE ? jE.level : 0 });
  ps.stderr.supportsColor = jE;
  ps.Level = {
    None: 0,
    Basic: 1,
    Ansi256: 2,
    TrueColor: 3,
    0: "None",
    1: "Basic",
    2: "Ansi256",
    3: "TrueColor"
  };
  jq.exports = ps;
});
var Lq = y$1((E1e, kq) => {
  function iQ() {
    this.__data__ = [], this.size = 0;
  }
  o(iQ, "listCacheClear");
  kq.exports = iQ;
});
var $E = y$1((w1e, Fq) => {
  function sQ(e, t) {
    return e === t || e !== e && t !== t;
  }
  o(sQ, "eq");
  Fq.exports = sQ;
});
var fs = y$1((R1e, Dq) => {
  var aQ = $E();
  function lQ(e, t) {
    for (var r = e.length; r--; )
      if (aQ(e[r][0], t))
        return r;
    return -1;
  }
  o(lQ, "assocIndexOf");
  Dq.exports = lQ;
});
var Bq = y$1((_1e, $q) => {
  var uQ = fs(), cQ = Array.prototype, dQ = cQ.splice;
  function pQ(e) {
    var t = this.__data__, r = uQ(t, e);
    if (r < 0)
      return false;
    var n = t.length - 1;
    return r == n ? t.pop() : dQ.call(t, r, 1), --this.size, true;
  }
  o(pQ, "listCacheDelete");
  $q.exports = pQ;
});
var Uq = y$1((P1e, Hq) => {
  var fQ = fs();
  function mQ(e) {
    var t = this.__data__, r = fQ(t, e);
    return r < 0 ? void 0 : t[r][1];
  }
  o(mQ, "listCacheGet");
  Hq.exports = mQ;
});
var zq = y$1((O1e, Vq) => {
  var hQ = fs();
  function yQ(e) {
    return hQ(this.__data__, e) > -1;
  }
  o(yQ, "listCacheHas");
  Vq.exports = yQ;
});
var Wq = y$1((I1e, Gq) => {
  var bQ = fs();
  function gQ(e, t) {
    var r = this.__data__, n = bQ(r, e);
    return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
  }
  o(gQ, "listCacheSet");
  Gq.exports = gQ;
});
var ms = y$1((N1e, Yq) => {
  var vQ = Lq(), EQ = Bq(), xQ = Uq(), wQ = zq(), TQ = Wq();
  function Lo(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  o(Lo, "ListCache");
  Lo.prototype.clear = vQ;
  Lo.prototype.delete = EQ;
  Lo.prototype.get = xQ;
  Lo.prototype.has = wQ;
  Lo.prototype.set = TQ;
  Yq.exports = Lo;
});
var Xq = y$1((k1e, Kq) => {
  var RQ = ms();
  function SQ() {
    this.__data__ = new RQ(), this.size = 0;
  }
  o(SQ, "stackClear");
  Kq.exports = SQ;
});
var Qq = y$1((F1e, Jq) => {
  function _Q(e) {
    var t = this.__data__, r = t.delete(e);
    return this.size = t.size, r;
  }
  o(_Q, "stackDelete");
  Jq.exports = _Q;
});
var e1 = y$1(($1e, Zq) => {
  function CQ(e) {
    return this.__data__.get(e);
  }
  o(CQ, "stackGet");
  Zq.exports = CQ;
});
var r1 = y$1((H1e, t1) => {
  function PQ(e) {
    return this.__data__.has(e);
  }
  o(PQ, "stackHas");
  t1.exports = PQ;
});
var BE = y$1((V1e, n1) => {
  var AQ = typeof global == "object" && global && global.Object === Object && global;
  n1.exports = AQ;
});
var or = y$1((z1e, o1) => {
  var OQ = BE(), qQ = typeof self == "object" && self && self.Object === Object && self, IQ = OQ || qQ || Function("return this")();
  o1.exports = IQ;
});
var Ud = y$1((G1e, i1) => {
  var MQ = or(), NQ = MQ.Symbol;
  i1.exports = NQ;
});
var u1 = y$1((W1e, l1) => {
  var s1 = Ud(), a1 = Object.prototype, jQ = a1.hasOwnProperty, kQ = a1.toString, hs = s1 ? s1.toStringTag : void 0;
  function LQ(e) {
    var t = jQ.call(e, hs), r = e[hs];
    try {
      e[hs] = void 0;
      var n = true;
    } catch {
    }
    var i = kQ.call(e);
    return n && (t ? e[hs] = r : delete e[hs]), i;
  }
  o(LQ, "getRawTag");
  l1.exports = LQ;
});
var d1 = y$1((K1e, c1) => {
  var FQ = Object.prototype, DQ = FQ.toString;
  function $Q(e) {
    return DQ.call(e);
  }
  o($Q, "objectToString");
  c1.exports = $Q;
});
var ys = y$1((J1e, m1) => {
  var p1 = Ud(), BQ = u1(), HQ = d1(), UQ = "[object Null]", VQ = "[object Undefined]", f1 = p1 ? p1.toStringTag : void 0;
  function zQ(e) {
    return e == null ? e === void 0 ? VQ : UQ : f1 && f1 in Object(e) ? BQ(e) : HQ(e);
  }
  o(zQ, "baseGetTag");
  m1.exports = zQ;
});
var HE = y$1((Z1e, h1) => {
  function GQ(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  o(GQ, "isObject");
  h1.exports = GQ;
});
var UE = y$1((tIe, y1) => {
  var WQ = ys(), YQ = HE(), KQ = "[object AsyncFunction]", XQ = "[object Function]", JQ = "[object GeneratorFunction]", QQ = "[object Proxy]";
  function ZQ(e) {
    if (!YQ(e))
      return false;
    var t = WQ(e);
    return t == XQ || t == JQ || t == KQ || t == QQ;
  }
  o(ZQ, "isFunction");
  y1.exports = ZQ;
});
var g1 = y$1((nIe, b1) => {
  var eZ = or(), tZ = eZ["__core-js_shared__"];
  b1.exports = tZ;
});
var x1 = y$1((oIe, E1) => {
  var VE = g1(), v1 = function() {
    var e = /[^.]+$/.exec(VE && VE.keys && VE.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  }();
  function rZ(e) {
    return !!v1 && v1 in e;
  }
  o(rZ, "isMasked");
  E1.exports = rZ;
});
var zE = y$1((sIe, w1) => {
  var nZ = Function.prototype, oZ = nZ.toString;
  function iZ(e) {
    if (e != null) {
      try {
        return oZ.call(e);
      } catch {
      }
      try {
        return e + "";
      } catch {
      }
    }
    return "";
  }
  o(iZ, "toSource");
  w1.exports = iZ;
});
var R1 = y$1((lIe, T1) => {
  var sZ = UE(), aZ = x1(), lZ = HE(), uZ = zE(), cZ = /[\\^$.*+?()[\]{}|]/g, dZ = /^\[object .+?Constructor\]$/, pZ = Function.prototype, fZ = Object.prototype, mZ = pZ.toString, hZ = fZ.hasOwnProperty, yZ = RegExp(
    "^" + mZ.call(hZ).replace(cZ, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function bZ(e) {
    if (!lZ(e) || aZ(e))
      return false;
    var t = sZ(e) ? yZ : dZ;
    return t.test(uZ(e));
  }
  o(bZ, "baseIsNative");
  T1.exports = bZ;
});
var _1 = y$1((cIe, S1) => {
  function gZ(e, t) {
    return e?.[t];
  }
  o(gZ, "getValue");
  S1.exports = gZ;
});
var Cn = y$1((pIe, C1) => {
  var vZ = R1(), EZ = _1();
  function xZ(e, t) {
    var r = EZ(e, t);
    return vZ(r) ? r : void 0;
  }
  o(xZ, "getNative");
  C1.exports = xZ;
});
var Vd = y$1((mIe, P1) => {
  var wZ = Cn(), TZ = or(), RZ = wZ(TZ, "Map");
  P1.exports = RZ;
});
var bs = y$1((hIe, A1) => {
  var SZ = Cn(), _Z = SZ(Object, "create");
  A1.exports = _Z;
});
var I1 = y$1((yIe, q1) => {
  var O1 = bs();
  function CZ() {
    this.__data__ = O1 ? O1(null) : {}, this.size = 0;
  }
  o(CZ, "hashClear");
  q1.exports = CZ;
});
var N1 = y$1((gIe, M1) => {
  function PZ(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  o(PZ, "hashDelete");
  M1.exports = PZ;
});
var k1 = y$1((EIe, j1) => {
  var AZ = bs(), OZ = "__lodash_hash_undefined__", qZ = Object.prototype, IZ = qZ.hasOwnProperty;
  function MZ(e) {
    var t = this.__data__;
    if (AZ) {
      var r = t[e];
      return r === OZ ? void 0 : r;
    }
    return IZ.call(t, e) ? t[e] : void 0;
  }
  o(MZ, "hashGet");
  j1.exports = MZ;
});
var F1 = y$1((wIe, L1) => {
  var NZ = bs(), jZ = Object.prototype, kZ = jZ.hasOwnProperty;
  function LZ(e) {
    var t = this.__data__;
    return NZ ? t[e] !== void 0 : kZ.call(t, e);
  }
  o(LZ, "hashHas");
  L1.exports = LZ;
});
var $1 = y$1((RIe, D1) => {
  var FZ = bs(), DZ = "__lodash_hash_undefined__";
  function $Z(e, t) {
    var r = this.__data__;
    return this.size += this.has(e) ? 0 : 1, r[e] = FZ && t === void 0 ? DZ : t, this;
  }
  o($Z, "hashSet");
  D1.exports = $Z;
});
var H1 = y$1((_Ie, B1) => {
  var BZ = I1(), HZ = N1(), UZ = k1(), VZ = F1(), zZ = $1();
  function Fo(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  o(Fo, "Hash");
  Fo.prototype.clear = BZ;
  Fo.prototype.delete = HZ;
  Fo.prototype.get = UZ;
  Fo.prototype.has = VZ;
  Fo.prototype.set = zZ;
  B1.exports = Fo;
});
var z1 = y$1((PIe, V1) => {
  var U1 = H1(), GZ = ms(), WZ = Vd();
  function YZ() {
    this.size = 0, this.__data__ = {
      hash: new U1(),
      map: new (WZ || GZ)(),
      string: new U1()
    };
  }
  o(YZ, "mapCacheClear");
  V1.exports = YZ;
});
var W1 = y$1((OIe, G1) => {
  function KZ(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  o(KZ, "isKeyable");
  G1.exports = KZ;
});
var gs = y$1((IIe, Y1) => {
  var XZ = W1();
  function JZ(e, t) {
    var r = e.__data__;
    return XZ(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
  }
  o(JZ, "getMapData");
  Y1.exports = JZ;
});
var X1 = y$1((NIe, K1) => {
  var QZ = gs();
  function ZZ(e) {
    var t = QZ(this, e).delete(e);
    return this.size -= t ? 1 : 0, t;
  }
  o(ZZ, "mapCacheDelete");
  K1.exports = ZZ;
});
var Q1 = y$1((kIe, J1) => {
  var eee = gs();
  function tee(e) {
    return eee(this, e).get(e);
  }
  o(tee, "mapCacheGet");
  J1.exports = tee;
});
var eI = y$1((FIe, Z1) => {
  var ree = gs();
  function nee(e) {
    return ree(this, e).has(e);
  }
  o(nee, "mapCacheHas");
  Z1.exports = nee;
});
var rI = y$1(($Ie, tI) => {
  var oee = gs();
  function iee(e, t) {
    var r = oee(this, e), n = r.size;
    return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
  }
  o(iee, "mapCacheSet");
  tI.exports = iee;
});
var GE = y$1((HIe, nI) => {
  var see = z1(), aee = X1(), lee = Q1(), uee = eI(), cee = rI();
  function Do(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  o(Do, "MapCache");
  Do.prototype.clear = see;
  Do.prototype.delete = aee;
  Do.prototype.get = lee;
  Do.prototype.has = uee;
  Do.prototype.set = cee;
  nI.exports = Do;
});
var iI = y$1((VIe, oI) => {
  var dee = ms(), pee = Vd(), fee = GE(), mee = 200;
  function hee(e, t) {
    var r = this.__data__;
    if (r instanceof dee) {
      var n = r.__data__;
      if (!pee || n.length < mee - 1)
        return n.push([e, t]), this.size = ++r.size, this;
      r = this.__data__ = new fee(n);
    }
    return r.set(e, t), this.size = r.size, this;
  }
  o(hee, "stackSet");
  oI.exports = hee;
});
var aI = y$1((GIe, sI) => {
  var yee = ms(), bee = Xq(), gee = Qq(), vee = e1(), Eee = r1(), xee = iI();
  function $o(e) {
    var t = this.__data__ = new yee(e);
    this.size = t.size;
  }
  o($o, "Stack");
  $o.prototype.clear = bee;
  $o.prototype.delete = gee;
  $o.prototype.get = vee;
  $o.prototype.has = Eee;
  $o.prototype.set = xee;
  sI.exports = $o;
});
var uI = y$1((YIe, lI) => {
  var wee = "__lodash_hash_undefined__";
  function Tee(e) {
    return this.__data__.set(e, wee), this;
  }
  o(Tee, "setCacheAdd");
  lI.exports = Tee;
});
var dI = y$1((XIe, cI) => {
  function Ree(e) {
    return this.__data__.has(e);
  }
  o(Ree, "setCacheHas");
  cI.exports = Ree;
});
var fI = y$1((QIe, pI) => {
  var See = GE(), _ee = uI(), Cee = dI();
  function zd(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.__data__ = new See(); ++t < r; )
      this.add(e[t]);
  }
  o(zd, "SetCache");
  zd.prototype.add = zd.prototype.push = _ee;
  zd.prototype.has = Cee;
  pI.exports = zd;
});
var hI = y$1((eMe, mI) => {
  function Pee(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length; ++r < n; )
      if (t(e[r], r, e))
        return true;
    return false;
  }
  o(Pee, "arraySome");
  mI.exports = Pee;
});
var bI = y$1((rMe, yI) => {
  function Aee(e, t) {
    return e.has(t);
  }
  o(Aee, "cacheHas");
  yI.exports = Aee;
});
var WE = y$1((oMe, gI) => {
  var Oee = fI(), qee = hI(), Iee = bI(), Mee = 1, Nee = 2;
  function jee(e, t, r, n, i, s) {
    var a = r & Mee, l = e.length, u = t.length;
    if (l != u && !(a && u > l))
      return false;
    var c = s.get(e), d = s.get(t);
    if (c && d)
      return c == t && d == e;
    var p = -1, f = true, m = r & Nee ? new Oee() : void 0;
    for (s.set(e, t), s.set(t, e); ++p < l; ) {
      var h = e[p], b = t[p];
      if (n)
        var v = a ? n(b, h, p, t, e, s) : n(h, b, p, e, t, s);
      if (v !== void 0) {
        if (v)
          continue;
        f = false;
        break;
      }
      if (m) {
        if (!qee(t, function(g, w) {
          if (!Iee(m, w) && (h === g || i(h, g, r, n, s)))
            return m.push(w);
        })) {
          f = false;
          break;
        }
      } else if (!(h === b || i(h, b, r, n, s))) {
        f = false;
        break;
      }
    }
    return s.delete(e), s.delete(t), f;
  }
  o(jee, "equalArrays");
  gI.exports = jee;
});
var EI = y$1((sMe, vI) => {
  var kee = or(), Lee = kee.Uint8Array;
  vI.exports = Lee;
});
var wI = y$1((aMe, xI) => {
  function Fee(e) {
    var t = -1, r = Array(e.size);
    return e.forEach(function(n, i) {
      r[++t] = [i, n];
    }), r;
  }
  o(Fee, "mapToArray");
  xI.exports = Fee;
});
var RI = y$1((uMe, TI) => {
  function Dee(e) {
    var t = -1, r = Array(e.size);
    return e.forEach(function(n) {
      r[++t] = n;
    }), r;
  }
  o(Dee, "setToArray");
  TI.exports = Dee;
});
var AI = y$1((dMe, PI) => {
  var SI = Ud(), _I = EI(), $ee = $E(), Bee = WE(), Hee = wI(), Uee = RI(), Vee = 1, zee = 2, Gee = "[object Boolean]", Wee = "[object Date]", Yee = "[object Error]", Kee = "[object Map]", Xee = "[object Number]", Jee = "[object RegExp]", Qee = "[object Set]", Zee = "[object String]", ete = "[object Symbol]", tte = "[object ArrayBuffer]", rte = "[object DataView]", CI = SI ? SI.prototype : void 0, YE = CI ? CI.valueOf : void 0;
  function nte(e, t, r, n, i, s, a) {
    switch (r) {
      case rte:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
          return false;
        e = e.buffer, t = t.buffer;
      case tte:
        return !(e.byteLength != t.byteLength || !s(new _I(e), new _I(t)));
      case Gee:
      case Wee:
      case Xee:
        return $ee(+e, +t);
      case Yee:
        return e.name == t.name && e.message == t.message;
      case Jee:
      case Zee:
        return e == t + "";
      case Kee:
        var l = Hee;
      case Qee:
        var u = n & Vee;
        if (l || (l = Uee), e.size != t.size && !u)
          return false;
        var c = a.get(e);
        if (c)
          return c == t;
        n |= zee, a.set(e, t);
        var d = Bee(l(e), l(t), n, i, s, a);
        return a.delete(e), d;
      case ete:
        if (YE)
          return YE.call(e) == YE.call(t);
    }
    return false;
  }
  o(nte, "equalByTag");
  PI.exports = nte;
});
var qI = y$1((fMe, OI) => {
  function ote(e, t) {
    for (var r = -1, n = t.length, i = e.length; ++r < n; )
      e[i + r] = t[r];
    return e;
  }
  o(ote, "arrayPush");
  OI.exports = ote;
});
var Gd = y$1((hMe, II) => {
  var ite = Array.isArray;
  II.exports = ite;
});
var NI = y$1((yMe, MI) => {
  var ste = qI(), ate = Gd();
  function lte(e, t, r) {
    var n = t(e);
    return ate(e) ? n : ste(n, r(e));
  }
  o(lte, "baseGetAllKeys");
  MI.exports = lte;
});
var kI = y$1((gMe, jI) => {
  function ute(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, i = 0, s = []; ++r < n; ) {
      var a = e[r];
      t(a, r, e) && (s[i++] = a);
    }
    return s;
  }
  o(ute, "arrayFilter");
  jI.exports = ute;
});
var FI = y$1((EMe, LI) => {
  function cte() {
    return [];
  }
  o(cte, "stubArray");
  LI.exports = cte;
});
var BI = y$1((wMe, $I) => {
  var dte = kI(), pte = FI(), fte = Object.prototype, mte = fte.propertyIsEnumerable, DI = Object.getOwnPropertySymbols, hte = DI ? function(e) {
    return e == null ? [] : (e = Object(e), dte(DI(e), function(t) {
      return mte.call(e, t);
    }));
  } : pte;
  $I.exports = hte;
});
var UI = y$1((TMe, HI) => {
  function yte(e, t) {
    for (var r = -1, n = Array(e); ++r < e; )
      n[r] = t(r);
    return n;
  }
  o(yte, "baseTimes");
  HI.exports = yte;
});
var vs = y$1((SMe, VI) => {
  function bte(e) {
    return e != null && typeof e == "object";
  }
  o(bte, "isObjectLike");
  VI.exports = bte;
});
var GI = y$1((CMe, zI) => {
  var gte = ys(), vte = vs(), Ete = "[object Arguments]";
  function xte(e) {
    return vte(e) && gte(e) == Ete;
  }
  o(xte, "baseIsArguments");
  zI.exports = xte;
});
var XI = y$1((AMe, KI) => {
  var WI = GI(), wte = vs(), YI = Object.prototype, Tte = YI.hasOwnProperty, Rte = YI.propertyIsEnumerable, Ste = WI(/* @__PURE__ */ function() {
    return arguments;
  }()) ? WI : function(e) {
    return wte(e) && Tte.call(e, "callee") && !Rte.call(e, "callee");
  };
  KI.exports = Ste;
});
var QI = y$1((OMe, JI) => {
  function _te() {
    return false;
  }
  o(_te, "stubFalse");
  JI.exports = _te;
});
var KE = y$1((Es, Bo) => {
  var Cte = or(), Pte = QI(), tM = typeof Es == "object" && Es && !Es.nodeType && Es, ZI = tM && typeof Bo == "object" && Bo && !Bo.nodeType && Bo, Ate = ZI && ZI.exports === tM, eM = Ate ? Cte.Buffer : void 0, Ote = eM ? eM.isBuffer : void 0, qte = Ote || Pte;
  Bo.exports = qte;
});
var nM = y$1((IMe, rM) => {
  var Ite = 9007199254740991, Mte = /^(?:0|[1-9]\d*)$/;
  function Nte(e, t) {
    var r = typeof e;
    return t = t ?? Ite, !!t && (r == "number" || r != "symbol" && Mte.test(e)) && e > -1 && e % 1 == 0 && e < t;
  }
  o(Nte, "isIndex");
  rM.exports = Nte;
});
var XE = y$1((NMe, oM) => {
  var jte = 9007199254740991;
  function kte(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= jte;
  }
  o(kte, "isLength");
  oM.exports = kte;
});
var sM = y$1((kMe, iM) => {
  var Lte = ys(), Fte = XE(), Dte = vs(), $te = "[object Arguments]", Bte = "[object Array]", Hte = "[object Boolean]", Ute = "[object Date]", Vte = "[object Error]", zte = "[object Function]", Gte = "[object Map]", Wte = "[object Number]", Yte = "[object Object]", Kte = "[object RegExp]", Xte = "[object Set]", Jte = "[object String]", Qte = "[object WeakMap]", Zte = "[object ArrayBuffer]", ere = "[object DataView]", tre = "[object Float32Array]", rre = "[object Float64Array]", nre = "[object Int8Array]", ore = "[object Int16Array]", ire = "[object Int32Array]", sre = "[object Uint8Array]", are = "[object Uint8ClampedArray]", lre = "[object Uint16Array]", ure = "[object Uint32Array]", Se = {};
  Se[tre] = Se[rre] = Se[nre] = Se[ore] = Se[ire] = Se[sre] = Se[are] = Se[lre] = Se[ure] = true;
  Se[$te] = Se[Bte] = Se[Zte] = Se[Hte] = Se[ere] = Se[Ute] = Se[Vte] = Se[zte] = Se[Gte] = Se[Wte] = Se[Yte] = Se[Kte] = Se[Xte] = Se[Jte] = Se[Qte] = false;
  function cre(e) {
    return Dte(e) && Fte(e.length) && !!Se[Lte(e)];
  }
  o(cre, "baseIsTypedArray");
  iM.exports = cre;
});
var lM = y$1((FMe, aM) => {
  function dre(e) {
    return function(t) {
      return e(t);
    };
  }
  o(dre, "baseUnary");
  aM.exports = dre;
});
var cM = y$1((xs, Ho) => {
  var pre = BE(), uM = typeof xs == "object" && xs && !xs.nodeType && xs, ws = uM && typeof Ho == "object" && Ho && !Ho.nodeType && Ho, fre = ws && ws.exports === uM, JE = fre && pre.process, mre = function() {
    try {
      var e = ws && ws.require && ws.require("util").types;
      return e || JE && JE.binding && JE.binding("util");
    } catch {
    }
  }();
  Ho.exports = mre;
});
var QE = y$1(($Me, fM) => {
  var hre = sM(), yre = lM(), dM = cM(), pM = dM && dM.isTypedArray, bre = pM ? yre(pM) : hre;
  fM.exports = bre;
});
var hM = y$1((BMe, mM) => {
  var gre = UI(), vre = XI(), Ere = Gd(), xre = KE(), wre = nM(), Tre = QE(), Rre = Object.prototype, Sre = Rre.hasOwnProperty;
  function _re(e, t) {
    var r = Ere(e), n = !r && vre(e), i = !r && !n && xre(e), s = !r && !n && !i && Tre(e), a = r || n || i || s, l = a ? gre(e.length, String) : [], u = l.length;
    for (var c in e)
      (t || Sre.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
      (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
      wre(c, u))) && l.push(c);
    return l;
  }
  o(_re, "arrayLikeKeys");
  mM.exports = _re;
});
var bM = y$1((UMe, yM) => {
  var Cre = Object.prototype;
  function Pre(e) {
    var t = e && e.constructor, r = typeof t == "function" && t.prototype || Cre;
    return e === r;
  }
  o(Pre, "isPrototype");
  yM.exports = Pre;
});
var vM = y$1((zMe, gM) => {
  function Are(e, t) {
    return function(r) {
      return e(t(r));
    };
  }
  o(Are, "overArg");
  gM.exports = Are;
});
var xM = y$1((WMe, EM) => {
  var Ore = vM(), qre = Ore(Object.keys, Object);
  EM.exports = qre;
});
var TM = y$1((YMe, wM) => {
  var Ire = bM(), Mre = xM(), Nre = Object.prototype, jre = Nre.hasOwnProperty;
  function kre(e) {
    if (!Ire(e))
      return Mre(e);
    var t = [];
    for (var r in Object(e))
      jre.call(e, r) && r != "constructor" && t.push(r);
    return t;
  }
  o(kre, "baseKeys");
  wM.exports = kre;
});
var SM = y$1((XMe, RM) => {
  var Lre = UE(), Fre = XE();
  function Dre(e) {
    return e != null && Fre(e.length) && !Lre(e);
  }
  o(Dre, "isArrayLike");
  RM.exports = Dre;
});
var CM = y$1((QMe, _M) => {
  var $re = hM(), Bre = TM(), Hre = SM();
  function Ure(e) {
    return Hre(e) ? $re(e) : Bre(e);
  }
  o(Ure, "keys");
  _M.exports = Ure;
});
var AM = y$1((eNe, PM) => {
  var Vre = NI(), zre = BI(), Gre = CM();
  function Wre(e) {
    return Vre(e, Gre, zre);
  }
  o(Wre, "getAllKeys");
  PM.exports = Wre;
});
var IM = y$1((rNe, qM) => {
  var OM = AM(), Yre = 1, Kre = Object.prototype, Xre = Kre.hasOwnProperty;
  function Jre(e, t, r, n, i, s) {
    var a = r & Yre, l = OM(e), u = l.length, c = OM(t), d = c.length;
    if (u != d && !a)
      return false;
    for (var p = u; p--; ) {
      var f = l[p];
      if (!(a ? f in t : Xre.call(t, f)))
        return false;
    }
    var m = s.get(e), h = s.get(t);
    if (m && h)
      return m == t && h == e;
    var b = true;
    s.set(e, t), s.set(t, e);
    for (var v = a; ++p < u; ) {
      f = l[p];
      var g = e[f], w = t[f];
      if (n)
        var E = a ? n(w, g, f, t, e, s) : n(g, w, f, e, t, s);
      if (!(E === void 0 ? g === w || i(g, w, r, n, s) : E)) {
        b = false;
        break;
      }
      v || (v = f == "constructor");
    }
    if (b && !v) {
      var R = e.constructor, S = t.constructor;
      R != S && "constructor" in e && "constructor" in t && !(typeof R == "function" && R instanceof R && typeof S == "function" && S instanceof S) && (b = false);
    }
    return s.delete(e), s.delete(t), b;
  }
  o(Jre, "equalObjects");
  qM.exports = Jre;
});
var NM = y$1((oNe, MM) => {
  var Qre = Cn(), Zre = or(), ene = Qre(Zre, "DataView");
  MM.exports = ene;
});
var kM = y$1((iNe, jM) => {
  var tne = Cn(), rne = or(), nne = tne(rne, "Promise");
  jM.exports = nne;
});
var FM = y$1((sNe, LM) => {
  var one = Cn(), ine = or(), sne = one(ine, "Set");
  LM.exports = sne;
});
var $M = y$1((aNe, DM) => {
  var ane = Cn(), lne = or(), une = ane(lne, "WeakMap");
  DM.exports = une;
});
var YM = y$1((lNe, WM) => {
  var ZE = NM(), ex = Vd(), tx = kM(), rx = FM(), nx = $M(), GM = ys(), Uo = zE(), BM = "[object Map]", cne = "[object Object]", HM = "[object Promise]", UM = "[object Set]", VM = "[object WeakMap]", zM = "[object DataView]", dne = Uo(ZE), pne = Uo(ex), fne = Uo(tx), mne = Uo(rx), hne = Uo(nx), Pn = GM;
  (ZE && Pn(new ZE(new ArrayBuffer(1))) != zM || ex && Pn(new ex()) != BM || tx && Pn(tx.resolve()) != HM || rx && Pn(new rx()) != UM || nx && Pn(new nx()) != VM) && (Pn = /* @__PURE__ */ o(function(e) {
    var t = GM(e), r = t == cne ? e.constructor : void 0, n = r ? Uo(r) : "";
    if (n)
      switch (n) {
        case dne:
          return zM;
        case pne:
          return BM;
        case fne:
          return HM;
        case mne:
          return UM;
        case hne:
          return VM;
      }
    return t;
  }, "getTag"));
  WM.exports = Pn;
});
var rN = y$1((cNe, tN) => {
  var ox = aI(), yne = WE(), bne = AI(), gne = IM(), KM = YM(), XM = Gd(), JM = KE(), vne = QE(), Ene = 1, QM = "[object Arguments]", ZM = "[object Array]", Wd = "[object Object]", xne = Object.prototype, eN = xne.hasOwnProperty;
  function wne(e, t, r, n, i, s) {
    var a = XM(e), l = XM(t), u = a ? ZM : KM(e), c = l ? ZM : KM(t);
    u = u == QM ? Wd : u, c = c == QM ? Wd : c;
    var d = u == Wd, p = c == Wd, f = u == c;
    if (f && JM(e)) {
      if (!JM(t))
        return false;
      a = true, d = false;
    }
    if (f && !d)
      return s || (s = new ox()), a || vne(e) ? yne(e, t, r, n, i, s) : bne(e, t, u, r, n, i, s);
    if (!(r & Ene)) {
      var m = d && eN.call(e, "__wrapped__"), h = p && eN.call(t, "__wrapped__");
      if (m || h) {
        var b = m ? e.value() : e, v = h ? t.value() : t;
        return s || (s = new ox()), i(b, v, r, n, s);
      }
    }
    return f ? (s || (s = new ox()), gne(e, t, r, n, i, s)) : false;
  }
  o(wne, "baseIsEqualDeep");
  tN.exports = wne;
});
var sN = y$1((pNe, iN) => {
  var Tne = rN(), nN = vs();
  function oN(e, t, r, n, i) {
    return e === t ? true : e == null || t == null || !nN(e) && !nN(t) ? e !== e && t !== t : Tne(e, t, r, n, oN, i);
  }
  o(oN, "baseIsEqual");
  iN.exports = oN;
});
var ix = y$1((mNe, aN) => {
  var Rne = sN();
  function Sne(e, t, r) {
    r = typeof r == "function" ? r : void 0;
    var n = r ? r(e, t) : void 0;
    return n === void 0 ? Rne(e, t, void 0, r) : !!n;
  }
  o(Sne, "isEqualWith");
  aN.exports = Sne;
});
var ax = y$1((sx, lN) => {
  (function(e, t) {
    typeof sx == "object" ? lN.exports = t(e) : typeof define == "function" && define.amd ? define([], t.bind(e, e)) : t(e);
  })(typeof global < "u" ? global : sx, function(e) {
    if (e.CSS && e.CSS.escape)
      return e.CSS.escape;
    var t = /* @__PURE__ */ o(function(r) {
      if (arguments.length == 0)
        throw new TypeError("`CSS.escape` requires an argument.");
      for (var n = String(r), i = n.length, s = -1, a, l = "", u = n.charCodeAt(0); ++s < i; ) {
        if (a = n.charCodeAt(s), a == 0) {
          l += "";
          continue;
        }
        if (
          // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
          // U+007F, []
          a >= 1 && a <= 31 || a == 127 || // If the character is the first character and is in the range [0-9]
          // (U+0030 to U+0039), []
          s == 0 && a >= 48 && a <= 57 || // If the character is the second character and is in the range [0-9]
          // (U+0030 to U+0039) and the first character is a `-` (U+002D), []
          s == 1 && a >= 48 && a <= 57 && u == 45
        ) {
          l += "\\" + a.toString(16) + " ";
          continue;
        }
        if (
          // If the character is the first character and is a `-` (U+002D), and
          // there is no second character, []
          s == 0 && i == 1 && a == 45
        ) {
          l += "\\" + n.charAt(s);
          continue;
        }
        if (a >= 128 || a == 45 || a == 95 || a >= 48 && a <= 57 || a >= 65 && a <= 90 || a >= 97 && a <= 122) {
          l += n.charAt(s);
          continue;
        }
        l += "\\" + n.charAt(s);
      }
      return l;
    }, "cssEscape");
    return e.CSS || (e.CSS = {}), e.CSS.escape = t, t;
  });
});
var fw = y$1((yje, rj) => {
  var ej = /* @__PURE__ */ o((e = 0) => (t) => `\x1B[${38 + e};5;${t}m`, "wrapAnsi256"), tj = /* @__PURE__ */ o((e = 0) => (t, r, n) => `\x1B[${38 + e};2;${t};${r};${n}m`, "wrapAnsi16m");
  function uie() {
    let e = /* @__PURE__ */ new Map(), t = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    t.color.gray = t.color.blackBright, t.bgColor.bgGray = t.bgColor.bgBlackBright, t.color.grey = t.color.blackBright, t.bgColor.bgGrey = t.bgColor.bgBlackBright;
    for (let [r, n] of Object.entries(t)) {
      for (let [i, s] of Object.entries(n))
        t[i] = {
          open: `\x1B[${s[0]}m`,
          close: `\x1B[${s[1]}m`
        }, n[i] = t[i], e.set(s[0], s[1]);
      Object.defineProperty(t, r, {
        value: n,
        enumerable: false
      });
    }
    return Object.defineProperty(t, "codes", {
      value: e,
      enumerable: false
    }), t.color.close = "\x1B[39m", t.bgColor.close = "\x1B[49m", t.color.ansi256 = ej(), t.color.ansi16m = tj(), t.bgColor.ansi256 = ej(10), t.bgColor.ansi16m = tj(10), Object.defineProperties(t, {
      rgbToAnsi256: {
        value: /* @__PURE__ */ o((r, n, i) => r === n && n === i ? r < 8 ? 16 : r > 248 ? 231 : Math.round((r - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(i / 255 * 5), "value"),
        enumerable: false
      },
      hexToRgb: {
        value: /* @__PURE__ */ o((r) => {
          let n = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(r.toString(16));
          if (!n)
            return [0, 0, 0];
          let { colorString: i } = n.groups;
          i.length === 3 && (i = i.split("").map((a) => a + a).join(""));
          let s = Number.parseInt(i, 16);
          return [
            s >> 16 & 255,
            s >> 8 & 255,
            s & 255
          ];
        }, "value"),
        enumerable: false
      },
      hexToAnsi256: {
        value: /* @__PURE__ */ o((r) => t.rgbToAnsi256(...t.hexToRgb(r)), "value"),
        enumerable: false
      }
    }), t;
  }
  o(uie, "assembleStyles");
  Object.defineProperty(rj, "exports", {
    enumerable: true,
    get: uie
  });
});
var Is = y$1((Wo) => {
  Object.defineProperty(Wo, "__esModule", {
    value: true
  });
  Wo.printIteratorEntries = die;
  Wo.printIteratorValues = pie;
  Wo.printListItems = fie;
  Wo.printObjectProperties = mie;
  var cie = /* @__PURE__ */ o((e, t) => {
    let r = Object.keys(e).sort(t);
    return Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(e).forEach((n) => {
      Object.getOwnPropertyDescriptor(e, n).enumerable && r.push(n);
    }), r;
  }, "getKeysOfEnumerableProperties");
  function die(e, t, r, n, i, s, a = ": ") {
    let l = "", u = e.next();
    if (!u.done) {
      l += t.spacingOuter;
      let c = r + t.indent;
      for (; !u.done; ) {
        let d = s(
          u.value[0],
          t,
          c,
          n,
          i
        ), p = s(
          u.value[1],
          t,
          c,
          n,
          i
        );
        l += c + d + a + p, u = e.next(), u.done ? t.min || (l += ",") : l += "," + t.spacingInner;
      }
      l += t.spacingOuter + r;
    }
    return l;
  }
  o(die, "printIteratorEntries");
  function pie(e, t, r, n, i, s) {
    let a = "", l = e.next();
    if (!l.done) {
      a += t.spacingOuter;
      let u = r + t.indent;
      for (; !l.done; )
        a += u + s(l.value, t, u, n, i), l = e.next(), l.done ? t.min || (a += ",") : a += "," + t.spacingInner;
      a += t.spacingOuter + r;
    }
    return a;
  }
  o(pie, "printIteratorValues");
  function fie(e, t, r, n, i, s) {
    let a = "";
    if (e.length) {
      a += t.spacingOuter;
      let l = r + t.indent;
      for (let u = 0; u < e.length; u++)
        a += l, u in e && (a += s(e[u], t, l, n, i)), u < e.length - 1 ? a += "," + t.spacingInner : t.min || (a += ",");
      a += t.spacingOuter + r;
    }
    return a;
  }
  o(fie, "printListItems");
  function mie(e, t, r, n, i, s) {
    let a = "", l = cie(e, t.compareKeys);
    if (l.length) {
      a += t.spacingOuter;
      let u = r + t.indent;
      for (let c = 0; c < l.length; c++) {
        let d = l[c], p = s(d, t, u, n, i), f = s(e[d], t, u, n, i);
        a += u + p + ": " + f, c < l.length - 1 ? a += "," + t.spacingInner : t.min || (a += ",");
      }
      a += t.spacingOuter + r;
    }
    return a;
  }
  o(mie, "printObjectProperties");
});
var sj = y$1((Vr) => {
  Object.defineProperty(Vr, "__esModule", {
    value: true
  });
  Vr.test = Vr.serialize = Vr.default = void 0;
  var nj = Is(), xp = function() {
    return typeof globalThis < "u" ? globalThis : typeof xp < "u" ? xp : typeof self < "u" ? self : typeof window < "u" ? window : Function(
      "return this"
    )();
  }(), mw = xp["jest-symbol-do-not-touch"] || xp.Symbol, hie = typeof mw == "function" && mw.for ? mw.for("jest.asymmetricMatcher") : 1267621, Ep = " ", oj = /* @__PURE__ */ o((e, t, r, n, i, s) => {
    let a = e.toString();
    return a === "ArrayContaining" || a === "ArrayNotContaining" ? ++n > t.maxDepth ? "[" + a + "]" : a + Ep + "[" + (0, nj.printListItems)(
      e.sample,
      t,
      r,
      n,
      i,
      s
    ) + "]" : a === "ObjectContaining" || a === "ObjectNotContaining" ? ++n > t.maxDepth ? "[" + a + "]" : a + Ep + "{" + (0, nj.printObjectProperties)(
      e.sample,
      t,
      r,
      n,
      i,
      s
    ) + "}" : a === "StringMatching" || a === "StringNotMatching" || a === "StringContaining" || a === "StringNotContaining" ? a + Ep + s(e.sample, t, r, n, i) : e.toAsymmetricMatcher();
  }, "serialize");
  Vr.serialize = oj;
  var ij = /* @__PURE__ */ o((e) => e && e.$$typeof === hie, "test");
  Vr.test = ij;
  var yie = {
    serialize: oj,
    test: ij
  }, bie = yie;
  Vr.default = bie;
});
var lj = y$1((wje, aj) => {
  aj.exports = ({ onlyFirst: e = false } = {}) => {
    let t = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(t, e ? void 0 : "g");
  };
});
var fj = y$1((zr) => {
  Object.defineProperty(zr, "__esModule", {
    value: true
  });
  zr.test = zr.serialize = zr.default = void 0;
  var uj = cj(lj()), xe = cj(fw());
  function cj(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(cj, "_interopRequireDefault");
  var gie = /* @__PURE__ */ o((e) => e.replace((0, uj.default)(), (t) => {
    switch (t) {
      case xe.default.red.close:
      case xe.default.green.close:
      case xe.default.cyan.close:
      case xe.default.gray.close:
      case xe.default.white.close:
      case xe.default.yellow.close:
      case xe.default.bgRed.close:
      case xe.default.bgGreen.close:
      case xe.default.bgYellow.close:
      case xe.default.inverse.close:
      case xe.default.dim.close:
      case xe.default.bold.close:
      case xe.default.reset.open:
      case xe.default.reset.close:
        return "</>";
      case xe.default.red.open:
        return "<red>";
      case xe.default.green.open:
        return "<green>";
      case xe.default.cyan.open:
        return "<cyan>";
      case xe.default.gray.open:
        return "<gray>";
      case xe.default.white.open:
        return "<white>";
      case xe.default.yellow.open:
        return "<yellow>";
      case xe.default.bgRed.open:
        return "<bgRed>";
      case xe.default.bgGreen.open:
        return "<bgGreen>";
      case xe.default.bgYellow.open:
        return "<bgYellow>";
      case xe.default.inverse.open:
        return "<inverse>";
      case xe.default.dim.open:
        return "<dim>";
      case xe.default.bold.open:
        return "<bold>";
      default:
        return "";
    }
  }), "toHumanReadableAnsi"), dj = /* @__PURE__ */ o((e) => typeof e == "string" && !!e.match((0, uj.default)()), "test");
  zr.test = dj;
  var pj = /* @__PURE__ */ o((e, t, r, n, i, s) => s(gie(e), t, r, n, i), "serialize");
  zr.serialize = pj;
  var vie = {
    serialize: pj,
    test: dj
  }, Eie = vie;
  zr.default = Eie;
});
var gj = y$1((Gr) => {
  Object.defineProperty(Gr, "__esModule", {
    value: true
  });
  Gr.test = Gr.serialize = Gr.default = void 0;
  var mj = Is(), xie = " ", hj = ["DOMStringMap", "NamedNodeMap"], wie = /^(HTML\w*Collection|NodeList)$/, Tie = /* @__PURE__ */ o((e) => hj.indexOf(e) !== -1 || wie.test(e), "testName"), yj = /* @__PURE__ */ o((e) => e && e.constructor && !!e.constructor.name && Tie(e.constructor.name), "test");
  Gr.test = yj;
  var Rie = /* @__PURE__ */ o((e) => e.constructor.name === "NamedNodeMap", "isNamedNodeMap"), bj = /* @__PURE__ */ o((e, t, r, n, i, s) => {
    let a = e.constructor.name;
    return ++n > t.maxDepth ? "[" + a + "]" : (t.min ? "" : a + xie) + (hj.indexOf(a) !== -1 ? "{" + (0, mj.printObjectProperties)(
      Rie(e) ? Array.from(e).reduce((l, u) => (l[u.name] = u.value, l), {}) : { ...e },
      t,
      r,
      n,
      i,
      s
    ) + "}" : "[" + (0, mj.printListItems)(
      Array.from(e),
      t,
      r,
      n,
      i,
      s
    ) + "]");
  }, "serialize");
  Gr.serialize = bj;
  var Sie = {
    serialize: bj,
    test: yj
  }, _ie = Sie;
  Gr.default = _ie;
});
var vj = y$1((hw) => {
  Object.defineProperty(hw, "__esModule", {
    value: true
  });
  hw.default = Cie;
  function Cie(e) {
    return e.replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  o(Cie, "escapeHTML");
});
var wp = y$1((ft) => {
  Object.defineProperty(ft, "__esModule", {
    value: true
  });
  ft.printText = ft.printProps = ft.printElementAsLeaf = ft.printElement = ft.printComment = ft.printChildren = void 0;
  var Ej = Pie(vj());
  function Pie(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(Pie, "_interopRequireDefault");
  var Aie = /* @__PURE__ */ o((e, t, r, n, i, s, a) => {
    let l = n + r.indent, u = r.colors;
    return e.map((c) => {
      let d = t[c], p = a(d, r, l, i, s);
      return typeof d != "string" && (p.indexOf(`
`) !== -1 && (p = r.spacingOuter + l + p + r.spacingOuter + n), p = "{" + p + "}"), r.spacingInner + n + u.prop.open + c + u.prop.close + "=" + u.value.open + p + u.value.close;
    }).join("");
  }, "printProps");
  ft.printProps = Aie;
  var Oie = /* @__PURE__ */ o((e, t, r, n, i, s) => e.map(
    (a) => t.spacingOuter + r + (typeof a == "string" ? xj(a, t) : s(a, t, r, n, i))
  ).join(""), "printChildren");
  ft.printChildren = Oie;
  var xj = /* @__PURE__ */ o((e, t) => {
    let r = t.colors.content;
    return r.open + (0, Ej.default)(e) + r.close;
  }, "printText");
  ft.printText = xj;
  var qie = /* @__PURE__ */ o((e, t) => {
    let r = t.colors.comment;
    return r.open + "<!--" + (0, Ej.default)(e) + "-->" + r.close;
  }, "printComment");
  ft.printComment = qie;
  var Iie = /* @__PURE__ */ o((e, t, r, n, i) => {
    let s = n.colors.tag;
    return s.open + "<" + e + (t && s.close + t + n.spacingOuter + i + s.open) + (r ? ">" + s.close + r + n.spacingOuter + i + s.open + "</" + e : (t && !n.min ? "" : " ") + "/") + ">" + s.close;
  }, "printElement");
  ft.printElement = Iie;
  var Mie = /* @__PURE__ */ o((e, t) => {
    let r = t.colors.tag;
    return r.open + "<" + e + r.close + " " + r.open + " />" + r.close;
  }, "printElementAsLeaf");
  ft.printElementAsLeaf = Mie;
});
var Cj = y$1((Wr) => {
  Object.defineProperty(Wr, "__esModule", {
    value: true
  });
  Wr.test = Wr.serialize = Wr.default = void 0;
  var Yo = wp(), Nie = 1, wj = 3, Tj = 8, Rj = 11, jie = /^((HTML|SVG)\w*)?Element$/, kie = /* @__PURE__ */ o((e) => {
    try {
      return typeof e.hasAttribute == "function" && e.hasAttribute("is");
    } catch {
      return false;
    }
  }, "testHasAttribute"), Lie = /* @__PURE__ */ o((e) => {
    let t = e.constructor.name, { nodeType: r, tagName: n } = e, i = typeof n == "string" && n.includes("-") || kie(e);
    return r === Nie && (jie.test(t) || i) || r === wj && t === "Text" || r === Tj && t === "Comment" || r === Rj && t === "DocumentFragment";
  }, "testNode"), Sj = /* @__PURE__ */ o((e) => {
    var t;
    return (e == null || (t = e.constructor) === null || t === void 0 ? void 0 : t.name) && Lie(e);
  }, "test");
  Wr.test = Sj;
  function Fie(e) {
    return e.nodeType === wj;
  }
  o(Fie, "nodeIsText");
  function Die(e) {
    return e.nodeType === Tj;
  }
  o(Die, "nodeIsComment");
  function yw(e) {
    return e.nodeType === Rj;
  }
  o(yw, "nodeIsFragment");
  var _j = /* @__PURE__ */ o((e, t, r, n, i, s) => {
    if (Fie(e))
      return (0, Yo.printText)(e.data, t);
    if (Die(e))
      return (0, Yo.printComment)(e.data, t);
    let a = yw(e) ? "DocumentFragment" : e.tagName.toLowerCase();
    return ++n > t.maxDepth ? (0, Yo.printElementAsLeaf)(a, t) : (0, Yo.printElement)(
      a,
      (0, Yo.printProps)(
        yw(e) ? [] : Array.from(e.attributes).map((l) => l.name).sort(),
        yw(e) ? {} : Array.from(e.attributes).reduce((l, u) => (l[u.name] = u.value, l), {}),
        t,
        r + t.indent,
        n,
        i,
        s
      ),
      (0, Yo.printChildren)(
        Array.prototype.slice.call(e.childNodes || e.children),
        t,
        r + t.indent,
        n,
        i,
        s
      ),
      t,
      r
    );
  }, "serialize");
  Wr.serialize = _j;
  var $ie = {
    serialize: _j,
    test: Sj
  }, Bie = $ie;
  Wr.default = Bie;
});
var Ij = y$1((Yr) => {
  Object.defineProperty(Yr, "__esModule", {
    value: true
  });
  Yr.test = Yr.serialize = Yr.default = void 0;
  var Ms = Is(), Hie = "@@__IMMUTABLE_ITERABLE__@@", Uie = "@@__IMMUTABLE_LIST__@@", Vie = "@@__IMMUTABLE_KEYED__@@", zie = "@@__IMMUTABLE_MAP__@@", Pj = "@@__IMMUTABLE_ORDERED__@@", Gie = "@@__IMMUTABLE_RECORD__@@", Wie = "@@__IMMUTABLE_SEQ__@@", Yie = "@@__IMMUTABLE_SET__@@", Kie = "@@__IMMUTABLE_STACK__@@", Ko = /* @__PURE__ */ o((e) => "Immutable." + e, "getImmutableName"), Tp = /* @__PURE__ */ o((e) => "[" + e + "]", "printAsLeaf"), Ns = " ", Aj = "", Xie = /* @__PURE__ */ o((e, t, r, n, i, s, a) => ++n > t.maxDepth ? Tp(Ko(a)) : Ko(a) + Ns + "{" + (0, Ms.printIteratorEntries)(
    e.entries(),
    t,
    r,
    n,
    i,
    s
  ) + "}", "printImmutableEntries");
  function Jie(e) {
    let t = 0;
    return {
      next() {
        if (t < e._keys.length) {
          let r = e._keys[t++];
          return {
            done: false,
            value: [r, e.get(r)]
          };
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
  o(Jie, "getRecordEntries");
  var Qie = /* @__PURE__ */ o((e, t, r, n, i, s) => {
    let a = Ko(e._name || "Record");
    return ++n > t.maxDepth ? Tp(a) : a + Ns + "{" + (0, Ms.printIteratorEntries)(
      Jie(e),
      t,
      r,
      n,
      i,
      s
    ) + "}";
  }, "printImmutableRecord"), Zie = /* @__PURE__ */ o((e, t, r, n, i, s) => {
    let a = Ko("Seq");
    return ++n > t.maxDepth ? Tp(a) : e[Vie] ? a + Ns + "{" + // from Immutable collection of entries or from ECMAScript object
    (e._iter || e._object ? (0, Ms.printIteratorEntries)(
      e.entries(),
      t,
      r,
      n,
      i,
      s
    ) : Aj) + "}" : a + Ns + "[" + (e._iter || // from Immutable collection of values
    e._array || // from ECMAScript array
    e._collection || // from ECMAScript collection in immutable v4
    e._iterable ? (0, Ms.printIteratorValues)(
      e.values(),
      t,
      r,
      n,
      i,
      s
    ) : Aj) + "]";
  }, "printImmutableSeq"), bw = /* @__PURE__ */ o((e, t, r, n, i, s, a) => ++n > t.maxDepth ? Tp(Ko(a)) : Ko(a) + Ns + "[" + (0, Ms.printIteratorValues)(
    e.values(),
    t,
    r,
    n,
    i,
    s
  ) + "]", "printImmutableValues"), Oj = /* @__PURE__ */ o((e, t, r, n, i, s) => e[zie] ? Xie(
    e,
    t,
    r,
    n,
    i,
    s,
    e[Pj] ? "OrderedMap" : "Map"
  ) : e[Uie] ? bw(
    e,
    t,
    r,
    n,
    i,
    s,
    "List"
  ) : e[Yie] ? bw(
    e,
    t,
    r,
    n,
    i,
    s,
    e[Pj] ? "OrderedSet" : "Set"
  ) : e[Kie] ? bw(
    e,
    t,
    r,
    n,
    i,
    s,
    "Stack"
  ) : e[Wie] ? Zie(e, t, r, n, i, s) : Qie(e, t, r, n, i, s), "serialize");
  Yr.serialize = Oj;
  var qj = /* @__PURE__ */ o((e) => e && (e[Hie] === true || e[Gie] === true), "test");
  Yr.test = qj;
  var ese = {
    serialize: Oj,
    test: qj
  }, tse = ese;
  Yr.default = tse;
});
var Fj = y$1((ge) => {
  var Rp = 60103, Sp = 60106, js = 60107, ks = 60108, Ls = 60114, Fs = 60109, Ds = 60110, $s = 60112, Bs = 60113, gw = 60120, Hs = 60115, Us = 60116, Mj = 60121, Nj = 60122, jj = 60117, kj = 60129, Lj = 60131;
  typeof Symbol == "function" && Symbol.for && (ze = Symbol.for, Rp = ze("react.element"), Sp = ze("react.portal"), js = ze("react.fragment"), ks = ze("react.strict_mode"), Ls = ze("react.profiler"), Fs = ze("react.provider"), Ds = ze("react.context"), $s = ze("react.forward_ref"), Bs = ze("react.suspense"), gw = ze("react.suspense_list"), Hs = ze("react.memo"), Us = ze("react.lazy"), Mj = ze("react.block"), Nj = ze("react.server.block"), jj = ze("react.fundamental"), kj = ze("react.debug_trace_mode"), Lj = ze("react.legacy_hidden"));
  var ze;
  function Vt(e) {
    if (typeof e == "object" && e !== null) {
      var t = e.$$typeof;
      switch (t) {
        case Rp:
          switch (e = e.type, e) {
            case js:
            case Ls:
            case ks:
            case Bs:
            case gw:
              return e;
            default:
              switch (e = e && e.$$typeof, e) {
                case Ds:
                case $s:
                case Us:
                case Hs:
                case Fs:
                  return e;
                default:
                  return t;
              }
          }
        case Sp:
          return t;
      }
    }
  }
  o(Vt, "y");
  var rse = Fs, nse = Rp, ose = $s, ise = js, sse = Us, ase = Hs, lse = Sp, use = Ls, cse = ks, dse = Bs;
  ge.ContextConsumer = Ds;
  ge.ContextProvider = rse;
  ge.Element = nse;
  ge.ForwardRef = ose;
  ge.Fragment = ise;
  ge.Lazy = sse;
  ge.Memo = ase;
  ge.Portal = lse;
  ge.Profiler = use;
  ge.StrictMode = cse;
  ge.Suspense = dse;
  ge.isAsyncMode = function() {
    return false;
  };
  ge.isConcurrentMode = function() {
    return false;
  };
  ge.isContextConsumer = function(e) {
    return Vt(e) === Ds;
  };
  ge.isContextProvider = function(e) {
    return Vt(e) === Fs;
  };
  ge.isElement = function(e) {
    return typeof e == "object" && e !== null && e.$$typeof === Rp;
  };
  ge.isForwardRef = function(e) {
    return Vt(e) === $s;
  };
  ge.isFragment = function(e) {
    return Vt(e) === js;
  };
  ge.isLazy = function(e) {
    return Vt(e) === Us;
  };
  ge.isMemo = function(e) {
    return Vt(e) === Hs;
  };
  ge.isPortal = function(e) {
    return Vt(e) === Sp;
  };
  ge.isProfiler = function(e) {
    return Vt(e) === Ls;
  };
  ge.isStrictMode = function(e) {
    return Vt(e) === ks;
  };
  ge.isSuspense = function(e) {
    return Vt(e) === Bs;
  };
  ge.isValidElementType = function(e) {
    return typeof e == "string" || typeof e == "function" || e === js || e === Ls || e === kj || e === ks || e === Bs || e === gw || e === Lj || typeof e == "object" && e !== null && (e.$$typeof === Us || e.$$typeof === Hs || e.$$typeof === Fs || e.$$typeof === Ds || e.$$typeof === $s || e.$$typeof === jj || e.$$typeof === Mj || e[0] === Nj);
  };
  ge.typeOf = Vt;
});
var $j = y$1((Lje, Dj) => {
  Dj.exports = Fj();
});
var Gj = y$1((Kr) => {
  Object.defineProperty(Kr, "__esModule", {
    value: true
  });
  Kr.test = Kr.serialize = Kr.default = void 0;
  var An = pse($j()), _p = wp();
  function Hj(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (Hj = /* @__PURE__ */ o(function(n) {
      return n ? r : t;
    }, "_getRequireWildcardCache"))(e);
  }
  o(Hj, "_getRequireWildcardCache");
  function pse(e, t) {
    if (!t && e && e.__esModule)
      return e;
    if (e === null || typeof e != "object" && typeof e != "function")
      return { default: e };
    var r = Hj(t);
    if (r && r.has(e))
      return r.get(e);
    var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var s in e)
      if (s !== "default" && Object.prototype.hasOwnProperty.call(e, s)) {
        var a = i ? Object.getOwnPropertyDescriptor(e, s) : null;
        a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = e[s];
      }
    return n.default = e, r && r.set(e, n), n;
  }
  o(pse, "_interopRequireWildcard");
  var Uj = /* @__PURE__ */ o((e, t = []) => (Array.isArray(e) ? e.forEach((r) => {
    Uj(r, t);
  }) : e != null && e !== false && t.push(e), t), "getChildren"), Bj = /* @__PURE__ */ o((e) => {
    let t = e.type;
    if (typeof t == "string")
      return t;
    if (typeof t == "function")
      return t.displayName || t.name || "Unknown";
    if (An.isFragment(e))
      return "React.Fragment";
    if (An.isSuspense(e))
      return "React.Suspense";
    if (typeof t == "object" && t !== null) {
      if (An.isContextProvider(e))
        return "Context.Provider";
      if (An.isContextConsumer(e))
        return "Context.Consumer";
      if (An.isForwardRef(e)) {
        if (t.displayName)
          return t.displayName;
        let r = t.render.displayName || t.render.name || "";
        return r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef";
      }
      if (An.isMemo(e)) {
        let r = t.displayName || t.type.displayName || t.type.name || "";
        return r !== "" ? "Memo(" + r + ")" : "Memo";
      }
    }
    return "UNDEFINED";
  }, "getType"), fse = /* @__PURE__ */ o((e) => {
    let { props: t } = e;
    return Object.keys(t).filter((r) => r !== "children" && t[r] !== void 0).sort();
  }, "getPropKeys"), Vj = /* @__PURE__ */ o((e, t, r, n, i, s) => ++n > t.maxDepth ? (0, _p.printElementAsLeaf)(Bj(e), t) : (0, _p.printElement)(
    Bj(e),
    (0, _p.printProps)(
      fse(e),
      e.props,
      t,
      r + t.indent,
      n,
      i,
      s
    ),
    (0, _p.printChildren)(
      Uj(e.props.children),
      t,
      r + t.indent,
      n,
      i,
      s
    ),
    t,
    r
  ), "serialize");
  Kr.serialize = Vj;
  var zj = /* @__PURE__ */ o((e) => e != null && An.isElement(e), "test");
  Kr.test = zj;
  var mse = {
    serialize: Vj,
    test: zj
  }, hse = mse;
  Kr.default = hse;
});
var Kj = y$1((Xr) => {
  Object.defineProperty(Xr, "__esModule", {
    value: true
  });
  Xr.test = Xr.serialize = Xr.default = void 0;
  var Cp = wp(), Pp = function() {
    return typeof globalThis < "u" ? globalThis : typeof Pp < "u" ? Pp : typeof self < "u" ? self : typeof window < "u" ? window : Function(
      "return this"
    )();
  }(), vw = Pp["jest-symbol-do-not-touch"] || Pp.Symbol, yse = typeof vw == "function" && vw.for ? vw.for("react.test.json") : 245830487, bse = /* @__PURE__ */ o(
    (e) => {
      let { props: t } = e;
      return t ? Object.keys(t).filter((r) => t[r] !== void 0).sort() : [];
    },
    "getPropKeys"
  ), Wj = /* @__PURE__ */ o((e, t, r, n, i, s) => ++n > t.maxDepth ? (0, Cp.printElementAsLeaf)(e.type, t) : (0, Cp.printElement)(
    e.type,
    e.props ? (0, Cp.printProps)(
      bse(e),
      e.props,
      t,
      r + t.indent,
      n,
      i,
      s
    ) : "",
    e.children ? (0, Cp.printChildren)(
      e.children,
      t,
      r + t.indent,
      n,
      i,
      s
    ) : "",
    t,
    r
  ), "serialize");
  Xr.serialize = Wj;
  var Yj = /* @__PURE__ */ o((e) => e && e.$$typeof === yse, "test");
  Xr.test = Yj;
  var gse = {
    serialize: Wj,
    test: Yj
  }, vse = gse;
  Xr.default = vse;
});
var dk = y$1((yr) => {
  Object.defineProperty(yr, "__esModule", {
    value: true
  });
  yr.default = yr.DEFAULT_OPTIONS = void 0;
  yr.format = ck;
  yr.plugins = void 0;
  var Ese = Qr(fw()), Vs = Is(), xse = Qr(
    sj()
  ), wse = Qr(fj()), Tse = Qr(gj()), Rse = Qr(Cj()), Sse = Qr(Ij()), _se = Qr(Gj()), Cse = Qr(
    Kj()
  );
  function Qr(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(Qr, "_interopRequireDefault");
  var tk = Object.prototype.toString, Pse = Date.prototype.toISOString, Ase = Error.prototype.toString, Xj = RegExp.prototype.toString, Ew = /* @__PURE__ */ o(
    (e) => typeof e.constructor == "function" && e.constructor.name || "Object",
    "getConstructorName"
  ), Ose = /* @__PURE__ */ o((e) => typeof window < "u" && e === window, "isWindow"), qse = /^Symbol\((.*)\)(.*)$/, Ise = /\n/gi, ww = class ww extends Error {
    constructor(t, r) {
      super(t), this.stack = r, this.name = this.constructor.name;
    }
  };
  o(ww, "PrettyFormatPluginError");
  var Ap = ww;
  function Mse(e) {
    return e === "[object Array]" || e === "[object ArrayBuffer]" || e === "[object DataView]" || e === "[object Float32Array]" || e === "[object Float64Array]" || e === "[object Int8Array]" || e === "[object Int16Array]" || e === "[object Int32Array]" || e === "[object Uint8Array]" || e === "[object Uint8ClampedArray]" || e === "[object Uint16Array]" || e === "[object Uint32Array]";
  }
  o(Mse, "isToStringedArrayType");
  function Nse(e) {
    return Object.is(e, -0) ? "-0" : String(e);
  }
  o(Nse, "printNumber");
  function jse(e) {
    return `${e}n`;
  }
  o(jse, "printBigInt");
  function Jj(e, t) {
    return t ? "[Function " + (e.name || "anonymous") + "]" : "[Function]";
  }
  o(Jj, "printFunction");
  function Qj(e) {
    return String(e).replace(qse, "Symbol($1)");
  }
  o(Qj, "printSymbol");
  function Zj(e) {
    return "[" + Ase.call(e) + "]";
  }
  o(Zj, "printError");
  function rk(e, t, r, n) {
    if (e === true || e === false)
      return "" + e;
    if (e === void 0)
      return "undefined";
    if (e === null)
      return "null";
    let i = typeof e;
    if (i === "number")
      return Nse(e);
    if (i === "bigint")
      return jse(e);
    if (i === "string")
      return n ? '"' + e.replace(/"|\\/g, "\\$&") + '"' : '"' + e + '"';
    if (i === "function")
      return Jj(e, t);
    if (i === "symbol")
      return Qj(e);
    let s = tk.call(e);
    return s === "[object WeakMap]" ? "WeakMap {}" : s === "[object WeakSet]" ? "WeakSet {}" : s === "[object Function]" || s === "[object GeneratorFunction]" ? Jj(e, t) : s === "[object Symbol]" ? Qj(e) : s === "[object Date]" ? isNaN(+e) ? "Date { NaN }" : Pse.call(e) : s === "[object Error]" ? Zj(e) : s === "[object RegExp]" ? r ? Xj.call(e).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&") : Xj.call(e) : e instanceof Error ? Zj(e) : null;
  }
  o(rk, "printBasicValue");
  function nk(e, t, r, n, i, s) {
    if (i.indexOf(e) !== -1)
      return "[Circular]";
    i = i.slice(), i.push(e);
    let a = ++n > t.maxDepth, l = t.min;
    if (t.callToJSON && !a && e.toJSON && typeof e.toJSON == "function" && !s)
      return Jr(e.toJSON(), t, r, n, i, true);
    let u = tk.call(e);
    return u === "[object Arguments]" ? a ? "[Arguments]" : (l ? "" : "Arguments ") + "[" + (0, Vs.printListItems)(
      e,
      t,
      r,
      n,
      i,
      Jr
    ) + "]" : Mse(u) ? a ? "[" + e.constructor.name + "]" : (l || !t.printBasicPrototype && e.constructor.name === "Array" ? "" : e.constructor.name + " ") + "[" + (0, Vs.printListItems)(
      e,
      t,
      r,
      n,
      i,
      Jr
    ) + "]" : u === "[object Map]" ? a ? "[Map]" : "Map {" + (0, Vs.printIteratorEntries)(
      e.entries(),
      t,
      r,
      n,
      i,
      Jr,
      " => "
    ) + "}" : u === "[object Set]" ? a ? "[Set]" : "Set {" + (0, Vs.printIteratorValues)(
      e.values(),
      t,
      r,
      n,
      i,
      Jr
    ) + "}" : a || Ose(e) ? "[" + Ew(e) + "]" : (l || !t.printBasicPrototype && Ew(e) === "Object" ? "" : Ew(e) + " ") + "{" + (0, Vs.printObjectProperties)(
      e,
      t,
      r,
      n,
      i,
      Jr
    ) + "}";
  }
  o(nk, "printComplexValue");
  function kse(e) {
    return e.serialize != null;
  }
  o(kse, "isNewPlugin");
  function ok(e, t, r, n, i, s) {
    let a;
    try {
      a = kse(e) ? e.serialize(t, r, n, i, s, Jr) : e.print(
        t,
        (l) => Jr(l, r, n, i, s),
        (l) => {
          let u = n + r.indent;
          return u + l.replace(Ise, `
` + u);
        },
        {
          edgeSpacing: r.spacingOuter,
          min: r.min,
          spacing: r.spacingInner
        },
        r.colors
      );
    } catch (l) {
      throw new Ap(l.message, l.stack);
    }
    if (typeof a != "string")
      throw new Error(
        `pretty-format: Plugin must return type "string" but instead returned "${typeof a}".`
      );
    return a;
  }
  o(ok, "printPlugin");
  function ik(e, t) {
    for (let r = 0; r < e.length; r++)
      try {
        if (e[r].test(t))
          return e[r];
      } catch (n) {
        throw new Ap(n.message, n.stack);
      }
    return null;
  }
  o(ik, "findPlugin");
  function Jr(e, t, r, n, i, s) {
    let a = ik(t.plugins, e);
    if (a !== null)
      return ok(a, e, t, r, n, i);
    let l = rk(
      e,
      t.printFunctionName,
      t.escapeRegex,
      t.escapeString
    );
    return l !== null ? l : nk(
      e,
      t,
      r,
      n,
      i,
      s
    );
  }
  o(Jr, "printer");
  var xw = {
    comment: "gray",
    content: "reset",
    prop: "yellow",
    tag: "cyan",
    value: "green"
  }, sk = Object.keys(xw), zt = {
    callToJSON: true,
    compareKeys: void 0,
    escapeRegex: false,
    escapeString: true,
    highlight: false,
    indent: 2,
    maxDepth: 1 / 0,
    min: false,
    plugins: [],
    printBasicPrototype: true,
    printFunctionName: true,
    theme: xw
  };
  yr.DEFAULT_OPTIONS = zt;
  function Lse(e) {
    if (Object.keys(e).forEach((t) => {
      if (!zt.hasOwnProperty(t))
        throw new Error(`pretty-format: Unknown option "${t}".`);
    }), e.min && e.indent !== void 0 && e.indent !== 0)
      throw new Error(
        'pretty-format: Options "min" and "indent" cannot be used together.'
      );
    if (e.theme !== void 0) {
      if (e.theme === null)
        throw new Error('pretty-format: Option "theme" must not be null.');
      if (typeof e.theme != "object")
        throw new Error(
          `pretty-format: Option "theme" must be of type "object" but instead received "${typeof e.theme}".`
        );
    }
  }
  o(Lse, "validateOptions");
  var Fse = /* @__PURE__ */ o((e) => sk.reduce((t, r) => {
    let n = e.theme && e.theme[r] !== void 0 ? e.theme[r] : xw[r], i = n && Ese.default[n];
    if (i && typeof i.close == "string" && typeof i.open == "string")
      t[r] = i;
    else
      throw new Error(
        `pretty-format: Option "theme" has a key "${r}" whose value "${n}" is undefined in ansi-styles.`
      );
    return t;
  }, /* @__PURE__ */ Object.create(null)), "getColorsHighlight"), Dse = /* @__PURE__ */ o(() => sk.reduce((e, t) => (e[t] = {
    close: "",
    open: ""
  }, e), /* @__PURE__ */ Object.create(null)), "getColorsEmpty"), ak = /* @__PURE__ */ o((e) => e && e.printFunctionName !== void 0 ? e.printFunctionName : zt.printFunctionName, "getPrintFunctionName"), lk = /* @__PURE__ */ o(
    (e) => e && e.escapeRegex !== void 0 ? e.escapeRegex : zt.escapeRegex,
    "getEscapeRegex"
  ), uk = /* @__PURE__ */ o((e) => e && e.escapeString !== void 0 ? e.escapeString : zt.escapeString, "getEscapeString"), ek = /* @__PURE__ */ o(
    (e) => {
      var t;
      return {
        callToJSON: e && e.callToJSON !== void 0 ? e.callToJSON : zt.callToJSON,
        colors: e && e.highlight ? Fse(e) : Dse(),
        compareKeys: e && typeof e.compareKeys == "function" ? e.compareKeys : zt.compareKeys,
        escapeRegex: lk(e),
        escapeString: uk(e),
        indent: e && e.min ? "" : $se(
          e && e.indent !== void 0 ? e.indent : zt.indent
        ),
        maxDepth: e && e.maxDepth !== void 0 ? e.maxDepth : zt.maxDepth,
        min: e && e.min !== void 0 ? e.min : zt.min,
        plugins: e && e.plugins !== void 0 ? e.plugins : zt.plugins,
        printBasicPrototype: (t = e?.printBasicPrototype) !== null && t !== void 0 ? t : true,
        printFunctionName: ak(e),
        spacingInner: e && e.min ? " " : `
`,
        spacingOuter: e && e.min ? "" : `
`
      };
    },
    "getConfig"
  );
  function $se(e) {
    return new Array(e + 1).join(" ");
  }
  o($se, "createIndent");
  function ck(e, t) {
    if (t && (Lse(t), t.plugins)) {
      let n = ik(t.plugins, e);
      if (n !== null)
        return ok(n, e, ek(t), "", 0, []);
    }
    let r = rk(
      e,
      ak(t),
      lk(t),
      uk(t)
    );
    return r !== null ? r : nk(e, ek(t), "", 0, []);
  }
  o(ck, "format");
  var Bse = {
    AsymmetricMatcher: xse.default,
    ConvertAnsi: wse.default,
    DOMCollection: Tse.default,
    DOMElement: Rse.default,
    Immutable: Sse.default,
    ReactElement: _se.default,
    ReactTestComponent: Cse.default
  };
  yr.plugins = Bse;
  var Hse = ck;
  yr.default = Hse;
});
var Nk = y$1((Mp) => {
  Object.defineProperty(Mp, "__esModule", {
    value: true
  });
  Mp.default = void 0;
  function Eae() {
    var e = this, t = 0, r = {
      "@@iterator": /* @__PURE__ */ o(function() {
        return r;
      }, "iterator"),
      next: /* @__PURE__ */ o(function() {
        if (t < e.length) {
          var i = e[t];
          return t = t + 1, {
            done: false,
            value: i
          };
        } else
          return {
            done: true
          };
      }, "next")
    };
    return r;
  }
  o(Eae, "iteratorProxy");
  var xae = Eae;
  Mp.default = xae;
});
var Jo = y$1((Sw) => {
  Object.defineProperty(Sw, "__esModule", {
    value: true
  });
  Sw.default = Rae;
  var wae = Tae(Nk());
  function Tae(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(Tae, "_interopRequireDefault");
  function Rw(e) {
    "@babel/helpers - typeof";
    return Rw = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, Rw(e);
  }
  o(Rw, "_typeof");
  function Rae(e, t) {
    return typeof Symbol == "function" && Rw(Symbol.iterator) === "symbol" && Object.defineProperty(e, Symbol.iterator, {
      value: wae.default.bind(t)
    }), e;
  }
  o(Rae, "iterationDecorator");
});
var Lk = y$1((Np) => {
  Object.defineProperty(Np, "__esModule", {
    value: true
  });
  Np.default = void 0;
  var Sae = _ae(Jo());
  function _ae(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(_ae, "_interopRequireDefault");
  function _w(e, t) {
    return Aae(e) || Pae(e, t) || kk(e, t) || Cae();
  }
  o(_w, "_slicedToArray");
  function Cae() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  o(Cae, "_nonIterableRest");
  function Pae(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
      var n = [], i = true, s = false, a, l;
      try {
        for (r = r.call(e); !(i = (a = r.next()).done) && (n.push(a.value), !(t && n.length === t)); i = true)
          ;
      } catch (u) {
        s = true, l = u;
      } finally {
        try {
          !i && r.return != null && r.return();
        } finally {
          if (s) throw l;
        }
      }
      return n;
    }
  }
  o(Pae, "_iterableToArrayLimit");
  function Aae(e) {
    if (Array.isArray(e)) return e;
  }
  o(Aae, "_arrayWithHoles");
  function Oae(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = kk(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var n = 0, i = /* @__PURE__ */ o(function() {
        }, "F");
        return { s: i, n: /* @__PURE__ */ o(function() {
          return n >= e.length ? { done: true } : { done: false, value: e[n++] };
        }, "n"), e: /* @__PURE__ */ o(function(c) {
          throw c;
        }, "e"), f: i };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var s = true, a = false, l;
    return { s: /* @__PURE__ */ o(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ o(function() {
      var c = r.next();
      return s = c.done, c;
    }, "n"), e: /* @__PURE__ */ o(function(c) {
      a = true, l = c;
    }, "e"), f: /* @__PURE__ */ o(function() {
      try {
        !s && r.return != null && r.return();
      } finally {
        if (a) throw l;
      }
    }, "f") };
  }
  o(Oae, "_createForOfIteratorHelper");
  function kk(e, t) {
    if (e) {
      if (typeof e == "string") return jk(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return jk(e, t);
    }
  }
  o(kk, "_unsupportedIterableToArray");
  function jk(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++)
      n[r] = e[r];
    return n;
  }
  o(jk, "_arrayLikeToArray");
  var Qo = [["aria-activedescendant", {
    type: "id"
  }], ["aria-atomic", {
    type: "boolean"
  }], ["aria-autocomplete", {
    type: "token",
    values: ["inline", "list", "both", "none"]
  }], ["aria-braillelabel", {
    type: "string"
  }], ["aria-brailleroledescription", {
    type: "string"
  }], ["aria-busy", {
    type: "boolean"
  }], ["aria-checked", {
    type: "tristate"
  }], ["aria-colcount", {
    type: "integer"
  }], ["aria-colindex", {
    type: "integer"
  }], ["aria-colspan", {
    type: "integer"
  }], ["aria-controls", {
    type: "idlist"
  }], ["aria-current", {
    type: "token",
    values: ["page", "step", "location", "date", "time", true, false]
  }], ["aria-describedby", {
    type: "idlist"
  }], ["aria-description", {
    type: "string"
  }], ["aria-details", {
    type: "id"
  }], ["aria-disabled", {
    type: "boolean"
  }], ["aria-dropeffect", {
    type: "tokenlist",
    values: ["copy", "execute", "link", "move", "none", "popup"]
  }], ["aria-errormessage", {
    type: "id"
  }], ["aria-expanded", {
    type: "boolean",
    allowundefined: true
  }], ["aria-flowto", {
    type: "idlist"
  }], ["aria-grabbed", {
    type: "boolean",
    allowundefined: true
  }], ["aria-haspopup", {
    type: "token",
    values: [false, true, "menu", "listbox", "tree", "grid", "dialog"]
  }], ["aria-hidden", {
    type: "boolean",
    allowundefined: true
  }], ["aria-invalid", {
    type: "token",
    values: ["grammar", false, "spelling", true]
  }], ["aria-keyshortcuts", {
    type: "string"
  }], ["aria-label", {
    type: "string"
  }], ["aria-labelledby", {
    type: "idlist"
  }], ["aria-level", {
    type: "integer"
  }], ["aria-live", {
    type: "token",
    values: ["assertive", "off", "polite"]
  }], ["aria-modal", {
    type: "boolean"
  }], ["aria-multiline", {
    type: "boolean"
  }], ["aria-multiselectable", {
    type: "boolean"
  }], ["aria-orientation", {
    type: "token",
    values: ["vertical", "undefined", "horizontal"]
  }], ["aria-owns", {
    type: "idlist"
  }], ["aria-placeholder", {
    type: "string"
  }], ["aria-posinset", {
    type: "integer"
  }], ["aria-pressed", {
    type: "tristate"
  }], ["aria-readonly", {
    type: "boolean"
  }], ["aria-relevant", {
    type: "tokenlist",
    values: ["additions", "all", "removals", "text"]
  }], ["aria-required", {
    type: "boolean"
  }], ["aria-roledescription", {
    type: "string"
  }], ["aria-rowcount", {
    type: "integer"
  }], ["aria-rowindex", {
    type: "integer"
  }], ["aria-rowspan", {
    type: "integer"
  }], ["aria-selected", {
    type: "boolean",
    allowundefined: true
  }], ["aria-setsize", {
    type: "integer"
  }], ["aria-sort", {
    type: "token",
    values: ["ascending", "descending", "none", "other"]
  }], ["aria-valuemax", {
    type: "number"
  }], ["aria-valuemin", {
    type: "number"
  }], ["aria-valuenow", {
    type: "number"
  }], ["aria-valuetext", {
    type: "string"
  }]], Cw = {
    entries: /* @__PURE__ */ o(function() {
      return Qo;
    }, "entries"),
    forEach: /* @__PURE__ */ o(function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = Oae(Qo), i;
      try {
        for (n.s(); !(i = n.n()).done; ) {
          var s = _w(i.value, 2), a = s[0], l = s[1];
          t.call(r, l, a, Qo);
        }
      } catch (u) {
        n.e(u);
      } finally {
        n.f();
      }
    }, "forEach"),
    get: /* @__PURE__ */ o(function(t) {
      var r = Qo.find(function(n) {
        return n[0] === t;
      });
      return r && r[1];
    }, "get"),
    has: /* @__PURE__ */ o(function(t) {
      return !!Cw.get(t);
    }, "has"),
    keys: /* @__PURE__ */ o(function() {
      return Qo.map(function(t) {
        var r = _w(t, 1), n = r[0];
        return n;
      });
    }, "keys"),
    values: /* @__PURE__ */ o(function() {
      return Qo.map(function(t) {
        var r = _w(t, 2), n = r[1];
        return n;
      });
    }, "values")
  }, qae = (0, Sae.default)(Cw, Cw.entries());
  Np.default = qae;
});
var $k = y$1((jp) => {
  Object.defineProperty(jp, "__esModule", {
    value: true
  });
  jp.default = void 0;
  var Iae = Mae(Jo());
  function Mae(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(Mae, "_interopRequireDefault");
  function Pw(e, t) {
    return kae(e) || jae(e, t) || Dk(e, t) || Nae();
  }
  o(Pw, "_slicedToArray");
  function Nae() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  o(Nae, "_nonIterableRest");
  function jae(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
      var n = [], i = true, s = false, a, l;
      try {
        for (r = r.call(e); !(i = (a = r.next()).done) && (n.push(a.value), !(t && n.length === t)); i = true)
          ;
      } catch (u) {
        s = true, l = u;
      } finally {
        try {
          !i && r.return != null && r.return();
        } finally {
          if (s) throw l;
        }
      }
      return n;
    }
  }
  o(jae, "_iterableToArrayLimit");
  function kae(e) {
    if (Array.isArray(e)) return e;
  }
  o(kae, "_arrayWithHoles");
  function Lae(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = Dk(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var n = 0, i = /* @__PURE__ */ o(function() {
        }, "F");
        return { s: i, n: /* @__PURE__ */ o(function() {
          return n >= e.length ? { done: true } : { done: false, value: e[n++] };
        }, "n"), e: /* @__PURE__ */ o(function(c) {
          throw c;
        }, "e"), f: i };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var s = true, a = false, l;
    return { s: /* @__PURE__ */ o(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ o(function() {
      var c = r.next();
      return s = c.done, c;
    }, "n"), e: /* @__PURE__ */ o(function(c) {
      a = true, l = c;
    }, "e"), f: /* @__PURE__ */ o(function() {
      try {
        !s && r.return != null && r.return();
      } finally {
        if (a) throw l;
      }
    }, "f") };
  }
  o(Lae, "_createForOfIteratorHelper");
  function Dk(e, t) {
    if (e) {
      if (typeof e == "string") return Fk(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Fk(e, t);
    }
  }
  o(Dk, "_unsupportedIterableToArray");
  function Fk(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++)
      n[r] = e[r];
    return n;
  }
  o(Fk, "_arrayLikeToArray");
  var Zo = [["a", {
    reserved: false
  }], ["abbr", {
    reserved: false
  }], ["acronym", {
    reserved: false
  }], ["address", {
    reserved: false
  }], ["applet", {
    reserved: false
  }], ["area", {
    reserved: false
  }], ["article", {
    reserved: false
  }], ["aside", {
    reserved: false
  }], ["audio", {
    reserved: false
  }], ["b", {
    reserved: false
  }], ["base", {
    reserved: true
  }], ["bdi", {
    reserved: false
  }], ["bdo", {
    reserved: false
  }], ["big", {
    reserved: false
  }], ["blink", {
    reserved: false
  }], ["blockquote", {
    reserved: false
  }], ["body", {
    reserved: false
  }], ["br", {
    reserved: false
  }], ["button", {
    reserved: false
  }], ["canvas", {
    reserved: false
  }], ["caption", {
    reserved: false
  }], ["center", {
    reserved: false
  }], ["cite", {
    reserved: false
  }], ["code", {
    reserved: false
  }], ["col", {
    reserved: true
  }], ["colgroup", {
    reserved: true
  }], ["content", {
    reserved: false
  }], ["data", {
    reserved: false
  }], ["datalist", {
    reserved: false
  }], ["dd", {
    reserved: false
  }], ["del", {
    reserved: false
  }], ["details", {
    reserved: false
  }], ["dfn", {
    reserved: false
  }], ["dialog", {
    reserved: false
  }], ["dir", {
    reserved: false
  }], ["div", {
    reserved: false
  }], ["dl", {
    reserved: false
  }], ["dt", {
    reserved: false
  }], ["em", {
    reserved: false
  }], ["embed", {
    reserved: false
  }], ["fieldset", {
    reserved: false
  }], ["figcaption", {
    reserved: false
  }], ["figure", {
    reserved: false
  }], ["font", {
    reserved: false
  }], ["footer", {
    reserved: false
  }], ["form", {
    reserved: false
  }], ["frame", {
    reserved: false
  }], ["frameset", {
    reserved: false
  }], ["h1", {
    reserved: false
  }], ["h2", {
    reserved: false
  }], ["h3", {
    reserved: false
  }], ["h4", {
    reserved: false
  }], ["h5", {
    reserved: false
  }], ["h6", {
    reserved: false
  }], ["head", {
    reserved: true
  }], ["header", {
    reserved: false
  }], ["hgroup", {
    reserved: false
  }], ["hr", {
    reserved: false
  }], ["html", {
    reserved: true
  }], ["i", {
    reserved: false
  }], ["iframe", {
    reserved: false
  }], ["img", {
    reserved: false
  }], ["input", {
    reserved: false
  }], ["ins", {
    reserved: false
  }], ["kbd", {
    reserved: false
  }], ["keygen", {
    reserved: false
  }], ["label", {
    reserved: false
  }], ["legend", {
    reserved: false
  }], ["li", {
    reserved: false
  }], ["link", {
    reserved: true
  }], ["main", {
    reserved: false
  }], ["map", {
    reserved: false
  }], ["mark", {
    reserved: false
  }], ["marquee", {
    reserved: false
  }], ["menu", {
    reserved: false
  }], ["menuitem", {
    reserved: false
  }], ["meta", {
    reserved: true
  }], ["meter", {
    reserved: false
  }], ["nav", {
    reserved: false
  }], ["noembed", {
    reserved: true
  }], ["noscript", {
    reserved: true
  }], ["object", {
    reserved: false
  }], ["ol", {
    reserved: false
  }], ["optgroup", {
    reserved: false
  }], ["option", {
    reserved: false
  }], ["output", {
    reserved: false
  }], ["p", {
    reserved: false
  }], ["param", {
    reserved: true
  }], ["picture", {
    reserved: true
  }], ["pre", {
    reserved: false
  }], ["progress", {
    reserved: false
  }], ["q", {
    reserved: false
  }], ["rp", {
    reserved: false
  }], ["rt", {
    reserved: false
  }], ["rtc", {
    reserved: false
  }], ["ruby", {
    reserved: false
  }], ["s", {
    reserved: false
  }], ["samp", {
    reserved: false
  }], ["script", {
    reserved: true
  }], ["section", {
    reserved: false
  }], ["select", {
    reserved: false
  }], ["small", {
    reserved: false
  }], ["source", {
    reserved: true
  }], ["spacer", {
    reserved: false
  }], ["span", {
    reserved: false
  }], ["strike", {
    reserved: false
  }], ["strong", {
    reserved: false
  }], ["style", {
    reserved: true
  }], ["sub", {
    reserved: false
  }], ["summary", {
    reserved: false
  }], ["sup", {
    reserved: false
  }], ["table", {
    reserved: false
  }], ["tbody", {
    reserved: false
  }], ["td", {
    reserved: false
  }], ["textarea", {
    reserved: false
  }], ["tfoot", {
    reserved: false
  }], ["th", {
    reserved: false
  }], ["thead", {
    reserved: false
  }], ["time", {
    reserved: false
  }], ["title", {
    reserved: true
  }], ["tr", {
    reserved: false
  }], ["track", {
    reserved: true
  }], ["tt", {
    reserved: false
  }], ["u", {
    reserved: false
  }], ["ul", {
    reserved: false
  }], ["var", {
    reserved: false
  }], ["video", {
    reserved: false
  }], ["wbr", {
    reserved: false
  }], ["xmp", {
    reserved: false
  }]], Aw = {
    entries: /* @__PURE__ */ o(function() {
      return Zo;
    }, "entries"),
    forEach: /* @__PURE__ */ o(function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = Lae(Zo), i;
      try {
        for (n.s(); !(i = n.n()).done; ) {
          var s = Pw(i.value, 2), a = s[0], l = s[1];
          t.call(r, l, a, Zo);
        }
      } catch (u) {
        n.e(u);
      } finally {
        n.f();
      }
    }, "forEach"),
    get: /* @__PURE__ */ o(function(t) {
      var r = Zo.find(function(n) {
        return n[0] === t;
      });
      return r && r[1];
    }, "get"),
    has: /* @__PURE__ */ o(function(t) {
      return !!Aw.get(t);
    }, "has"),
    keys: /* @__PURE__ */ o(function() {
      return Zo.map(function(t) {
        var r = Pw(t, 1), n = r[0];
        return n;
      });
    }, "keys"),
    values: /* @__PURE__ */ o(function() {
      return Zo.map(function(t) {
        var r = Pw(t, 2), n = r[1];
        return n;
      });
    }, "values")
  }, Fae = (0, Iae.default)(Aw, Aw.entries());
  jp.default = Fae;
});
var Bk = y$1((kp) => {
  Object.defineProperty(kp, "__esModule", {
    value: true
  });
  kp.default = void 0;
  var Dae = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  }, $ae = Dae;
  kp.default = $ae;
});
var Hk = y$1((Lp) => {
  Object.defineProperty(Lp, "__esModule", {
    value: true
  });
  Lp.default = void 0;
  var Bae = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  }, Hae = Bae;
  Lp.default = Hae;
});
var Uk = y$1((Fp) => {
  Object.defineProperty(Fp, "__esModule", {
    value: true
  });
  Fp.default = void 0;
  var Uae = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null
    },
    relatedConcepts: [{
      concept: {
        name: "input"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  }, Vae = Uae;
  Fp.default = Vae;
});
var Vk = y$1((Dp) => {
  Object.defineProperty(Dp, "__esModule", {
    value: true
  });
  Dp.default = void 0;
  var zae = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Gae = zae;
  Dp.default = Gae;
});
var zk = y$1(($p) => {
  Object.defineProperty($p, "__esModule", {
    value: true
  });
  $p.default = void 0;
  var Wae = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuemax": null,
      "aria-valuemin": null,
      "aria-valuenow": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }, Yae = Wae;
  $p.default = Yae;
});
var Gk = y$1((Bp) => {
  Object.defineProperty(Bp, "__esModule", {
    value: true
  });
  Bp.default = void 0;
  var Kae = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {
      "aria-atomic": null,
      "aria-busy": null,
      "aria-controls": null,
      "aria-current": null,
      "aria-describedby": null,
      "aria-details": null,
      "aria-dropeffect": null,
      "aria-flowto": null,
      "aria-grabbed": null,
      "aria-hidden": null,
      "aria-keyshortcuts": null,
      "aria-label": null,
      "aria-labelledby": null,
      "aria-live": null,
      "aria-owns": null,
      "aria-relevant": null,
      "aria-roledescription": null
    },
    relatedConcepts: [{
      concept: {
        name: "role"
      },
      module: "XHTML"
    }, {
      concept: {
        name: "type"
      },
      module: "Dublin Core"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: []
  }, Xae = Kae;
  Bp.default = Xae;
});
var Wk = y$1((Hp) => {
  Object.defineProperty(Hp, "__esModule", {
    value: true
  });
  Hp.default = void 0;
  var Jae = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "frontmatter"
      },
      module: "DTB"
    }, {
      concept: {
        name: "level"
      },
      module: "DTB"
    }, {
      concept: {
        name: "level"
      },
      module: "SMIL"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }, Qae = Jae;
  Hp.default = Qae;
});
var Yk = y$1((Up) => {
  Object.defineProperty(Up, "__esModule", {
    value: true
  });
  Up.default = void 0;
  var Zae = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }, ele = Zae;
  Up.default = ele;
});
var Kk = y$1((Vp) => {
  Object.defineProperty(Vp, "__esModule", {
    value: true
  });
  Vp.default = void 0;
  var tle = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
  }, rle = tle;
  Vp.default = rle;
});
var Xk = y$1((zp) => {
  Object.defineProperty(zp, "__esModule", {
    value: true
  });
  zp.default = void 0;
  var nle = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  }, ole = nle;
  zp.default = ole;
});
var Jk = y$1((Gp) => {
  Object.defineProperty(Gp, "__esModule", {
    value: true
  });
  Gp.default = void 0;
  var ile = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  }, sle = ile;
  Gp.default = sle;
});
var Qk = y$1((Wp) => {
  Object.defineProperty(Wp, "__esModule", {
    value: true
  });
  Wp.default = void 0;
  var ale = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-modal": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  }, lle = ale;
  Wp.default = lle;
});
var Zk = y$1((Yp) => {
  Object.defineProperty(Yp, "__esModule", {
    value: true
  });
  Yp.default = void 0;
  var ule = It(Bk()), cle = It(Hk()), dle = It(Uk()), ple = It(Vk()), fle = It(zk()), mle = It(Gk()), hle = It(Wk()), yle = It(Yk()), ble = It(
    Kk()
  ), gle = It(Xk()), vle = It(Jk()), Ele = It(Qk());
  function It(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(It, "_interopRequireDefault");
  var xle = [
    ["command", ule.default],
    ["composite", cle.default],
    ["input", dle.default],
    ["landmark", ple.default],
    ["range", fle.default],
    ["roletype", mle.default],
    ["section", hle.default],
    ["sectionhead", yle.default],
    ["select", ble.default],
    ["structure", gle.default],
    ["widget", vle.default],
    ["window", Ele.default]
  ], wle = xle;
  Yp.default = wle;
});
var eL = y$1((Kp) => {
  Object.defineProperty(Kp, "__esModule", {
    value: true
  });
  Kp.default = void 0;
  var Tle = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-atomic": "true",
      "aria-live": "assertive"
    },
    relatedConcepts: [{
      concept: {
        name: "alert"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Rle = Tle;
  Kp.default = Rle;
});
var tL = y$1((Xp) => {
  Object.defineProperty(Xp, "__esModule", {
    value: true
  });
  Xp.default = void 0;
  var Sle = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "alert"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
  }, _le = Sle;
  Xp.default = _le;
});
var rL = y$1((Jp) => {
  Object.defineProperty(Jp, "__esModule", {
    value: true
  });
  Jp.default = void 0;
  var Cle = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "Device Independence Delivery Unit"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }, Ple = Cle;
  Jp.default = Ple;
});
var nL = y$1((Qp) => {
  Object.defineProperty(Qp, "__esModule", {
    value: true
  });
  Qp.default = void 0;
  var Ale = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "article"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "document"]]
  }, Ole = Ale;
  Qp.default = Ole;
});
var oL = y$1((Zp) => {
  Object.defineProperty(Zp, "__esModule", {
    value: true
  });
  Zp.default = void 0;
  var qle = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        constraints: ["scoped to the body element"],
        name: "header"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, Ile = qle;
  Zp.default = Ile;
});
var iL = y$1((ef) => {
  Object.defineProperty(ef, "__esModule", {
    value: true
  });
  ef.default = void 0;
  var Mle = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "blockquote"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Nle = Mle;
  ef.default = Nle;
});
var sL = y$1((tf) => {
  Object.defineProperty(tf, "__esModule", {
    value: true
  });
  tf.default = void 0;
  var jle = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-pressed": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "button"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "image"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "reset"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "submit"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "button"
      },
      module: "HTML"
    }, {
      concept: {
        name: "trigger"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  }, kle = jle;
  tf.default = kle;
});
var aL = y$1((rf) => {
  Object.defineProperty(rf, "__esModule", {
    value: true
  });
  rf.default = void 0;
  var Lle = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "caption"
      },
      module: "HTML"
    }],
    requireContextRole: ["figure", "grid", "table"],
    requiredContextRole: ["figure", "grid", "table"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Fle = Lle;
  rf.default = Fle;
});
var lL = y$1((nf) => {
  Object.defineProperty(nf, "__esModule", {
    value: true
  });
  nf.default = void 0;
  var Dle = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-colindex": null,
      "aria-colspan": null,
      "aria-rowindex": null,
      "aria-rowspan": null
    },
    relatedConcepts: [{
      concept: {
        constraints: ["ancestor table element has table role"],
        name: "td"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, $le = Dle;
  nf.default = $le;
});
var uL = y$1((of) => {
  Object.defineProperty(of, "__esModule", {
    value: true
  });
  of.default = void 0;
  var Ble = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "checkbox"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "option"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input"]]
  }, Hle = Ble;
  of.default = Hle;
});
var cL = y$1((sf) => {
  Object.defineProperty(sf, "__esModule", {
    value: true
  });
  sf.default = void 0;
  var Ule = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "code"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Vle = Ule;
  sf.default = Vle;
});
var dL = y$1((af) => {
  Object.defineProperty(af, "__esModule", {
    value: true
  });
  af.default = void 0;
  var zle = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-sort": null
    },
    relatedConcepts: [{
      concept: {
        name: "th"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "scope",
          value: "col"
        }],
        name: "th"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "scope",
          value: "colgroup"
        }],
        name: "th"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
  }, Gle = zle;
  af.default = Gle;
});
var pL = y$1((lf) => {
  Object.defineProperty(lf, "__esModule", {
    value: true
  });
  lf.default = void 0;
  var Wle = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-autocomplete": null,
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-expanded": "false",
      "aria-haspopup": "listbox"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "email"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "search"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "tel"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "text"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "multiple"
        }, {
          constraints: ["undefined"],
          name: "size"
        }],
        constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-controls": null,
      "aria-expanded": "false"
    },
    superClass: [["roletype", "widget", "input"]]
  }, Yle = Wle;
  lf.default = Yle;
});
var fL = y$1((uf) => {
  Object.defineProperty(uf, "__esModule", {
    value: true
  });
  uf.default = void 0;
  var Kle = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "aside"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-label"
        }],
        constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
        name: "aside"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-labelledby"
        }],
        constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
        name: "aside"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, Xle = Kle;
  uf.default = Xle;
});
var mL = y$1((cf) => {
  Object.defineProperty(cf, "__esModule", {
    value: true
  });
  cf.default = void 0;
  var Jle = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        constraints: ["scoped to the body element"],
        name: "footer"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, Qle = Jle;
  cf.default = Qle;
});
var hL = y$1((df) => {
  Object.defineProperty(df, "__esModule", {
    value: true
  });
  df.default = void 0;
  var Zle = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dd"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, eue = Zle;
  df.default = eue;
});
var yL = y$1((pf) => {
  Object.defineProperty(pf, "__esModule", {
    value: true
  });
  pf.default = void 0;
  var tue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "del"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, rue = tue;
  pf.default = rue;
});
var bL = y$1((ff) => {
  Object.defineProperty(ff, "__esModule", {
    value: true
  });
  ff.default = void 0;
  var nue = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dialog"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "window"]]
  }, oue = nue;
  ff.default = oue;
});
var gL = y$1((mf) => {
  Object.defineProperty(mf, "__esModule", {
    value: true
  });
  mf.default = void 0;
  var iue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      module: "DAISY Guide"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "list"]]
  }, sue = iue;
  mf.default = sue;
});
var vL = y$1((hf) => {
  Object.defineProperty(hf, "__esModule", {
    value: true
  });
  hf.default = void 0;
  var aue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "Device Independence Delivery Unit"
      }
    }, {
      concept: {
        name: "html"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }, lue = aue;
  hf.default = lue;
});
var EL = y$1((yf) => {
  Object.defineProperty(yf, "__esModule", {
    value: true
  });
  yf.default = void 0;
  var uue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "em"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, cue = uue;
  yf.default = cue;
});
var xL = y$1((bf) => {
  Object.defineProperty(bf, "__esModule", {
    value: true
  });
  bf.default = void 0;
  var due = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["article"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "list"]]
  }, pue = due;
  bf.default = pue;
});
var wL = y$1((gf) => {
  Object.defineProperty(gf, "__esModule", {
    value: true
  });
  gf.default = void 0;
  var fue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "figure"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, mue = fue;
  gf.default = mue;
});
var TL = y$1((vf) => {
  Object.defineProperty(vf, "__esModule", {
    value: true
  });
  vf.default = void 0;
  var hue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-label"
        }],
        name: "form"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-labelledby"
        }],
        name: "form"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "name"
        }],
        name: "form"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, yue = hue;
  vf.default = yue;
});
var RL = y$1((Ef) => {
  Object.defineProperty(Ef, "__esModule", {
    value: true
  });
  Ef.default = void 0;
  var bue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "a"
      },
      module: "HTML"
    }, {
      concept: {
        name: "area"
      },
      module: "HTML"
    }, {
      concept: {
        name: "aside"
      },
      module: "HTML"
    }, {
      concept: {
        name: "b"
      },
      module: "HTML"
    }, {
      concept: {
        name: "bdo"
      },
      module: "HTML"
    }, {
      concept: {
        name: "body"
      },
      module: "HTML"
    }, {
      concept: {
        name: "data"
      },
      module: "HTML"
    }, {
      concept: {
        name: "div"
      },
      module: "HTML"
    }, {
      concept: {
        constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
        name: "footer"
      },
      module: "HTML"
    }, {
      concept: {
        constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
        name: "header"
      },
      module: "HTML"
    }, {
      concept: {
        name: "hgroup"
      },
      module: "HTML"
    }, {
      concept: {
        name: "i"
      },
      module: "HTML"
    }, {
      concept: {
        name: "pre"
      },
      module: "HTML"
    }, {
      concept: {
        name: "q"
      },
      module: "HTML"
    }, {
      concept: {
        name: "samp"
      },
      module: "HTML"
    }, {
      concept: {
        name: "section"
      },
      module: "HTML"
    }, {
      concept: {
        name: "small"
      },
      module: "HTML"
    }, {
      concept: {
        name: "span"
      },
      module: "HTML"
    }, {
      concept: {
        name: "u"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }, gue = bue;
  Ef.default = gue;
});
var SL = y$1((xf) => {
  Object.defineProperty(xf, "__esModule", {
    value: true
  });
  xf.default = void 0;
  var vue = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-multiselectable": null,
      "aria-readonly": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
  }, Eue = vue;
  xf.default = Eue;
});
var _L = y$1((wf) => {
  Object.defineProperty(wf, "__esModule", {
    value: true
  });
  wf.default = void 0;
  var xue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-selected": null
    },
    relatedConcepts: [{
      concept: {
        constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
        name: "td"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
  }, wue = xue;
  wf.default = wue;
});
var CL = y$1((Tf) => {
  Object.defineProperty(Tf, "__esModule", {
    value: true
  });
  Tf.default = void 0;
  var Tue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null
    },
    relatedConcepts: [{
      concept: {
        name: "details"
      },
      module: "HTML"
    }, {
      concept: {
        name: "fieldset"
      },
      module: "HTML"
    }, {
      concept: {
        name: "optgroup"
      },
      module: "HTML"
    }, {
      concept: {
        name: "address"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Rue = Tue;
  Tf.default = Rue;
});
var PL = y$1((Rf) => {
  Object.defineProperty(Rf, "__esModule", {
    value: true
  });
  Rf.default = void 0;
  var Sue = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-level": "2"
    },
    relatedConcepts: [{
      concept: {
        name: "h1"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h2"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h3"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h4"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h5"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h6"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-level": "2"
    },
    superClass: [["roletype", "structure", "sectionhead"]]
  }, _ue = Sue;
  Rf.default = _ue;
});
var AL = y$1((Sf) => {
  Object.defineProperty(Sf, "__esModule", {
    value: true
  });
  Sf.default = void 0;
  var Cue = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "alt"
        }],
        name: "img"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "alt"
        }],
        name: "img"
      },
      module: "HTML"
    }, {
      concept: {
        name: "imggroup"
      },
      module: "DTB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Pue = Cue;
  Sf.default = Pue;
});
var OL = y$1((_f) => {
  Object.defineProperty(_f, "__esModule", {
    value: true
  });
  _f.default = void 0;
  var Aue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "ins"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Oue = Aue;
  _f.default = Oue;
});
var qL = y$1((Cf) => {
  Object.defineProperty(Cf, "__esModule", {
    value: true
  });
  Cf.default = void 0;
  var que = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "href"
        }],
        name: "a"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "href"
        }],
        name: "area"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  }, Iue = que;
  Cf.default = Iue;
});
var IL = y$1((Pf) => {
  Object.defineProperty(Pf, "__esModule", {
    value: true
  });
  Pf.default = void 0;
  var Mue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menu"
      },
      module: "HTML"
    }, {
      concept: {
        name: "ol"
      },
      module: "HTML"
    }, {
      concept: {
        name: "ul"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["listitem"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Nue = Mue;
  Pf.default = Nue;
});
var ML = y$1((Af) => {
  Object.defineProperty(Af, "__esModule", {
    value: true
  });
  Af.default = void 0;
  var jue = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-invalid": null,
      "aria-multiselectable": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-orientation": "vertical"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: [">1"],
          name: "size"
        }],
        constraints: ["the size attribute value is greater than 1"],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "multiple"
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        name: "datalist"
      },
      module: "HTML"
    }, {
      concept: {
        name: "list"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["option", "group"], ["option"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  }, kue = jue;
  Af.default = kue;
});
var NL = y$1((Of) => {
  Object.defineProperty(Of, "__esModule", {
    value: true
  });
  Of.default = void 0;
  var Lue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-level": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
        name: "li"
      },
      module: "HTML"
    }, {
      concept: {
        name: "item"
      },
      module: "XForms"
    }],
    requireContextRole: ["directory", "list"],
    requiredContextRole: ["directory", "list"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Fue = Lue;
  Of.default = Fue;
});
var jL = y$1((qf) => {
  Object.defineProperty(qf, "__esModule", {
    value: true
  });
  qf.default = void 0;
  var Due = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-live": "polite"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, $ue = Due;
  qf.default = $ue;
});
var kL = y$1((If) => {
  Object.defineProperty(If, "__esModule", {
    value: true
  });
  If.default = void 0;
  var Bue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "main"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, Hue = Bue;
  If.default = Hue;
});
var LL = y$1((Mf) => {
  Object.defineProperty(Mf, "__esModule", {
    value: true
  });
  Mf.default = void 0;
  var Uue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: [],
    props: {
      "aria-braillelabel": null,
      "aria-brailleroledescription": null,
      "aria-description": null
    },
    relatedConcepts: [{
      concept: {
        name: "mark"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Vue = Uue;
  Mf.default = Vue;
});
var FL = y$1((Nf) => {
  Object.defineProperty(Nf, "__esModule", {
    value: true
  });
  Nf.default = void 0;
  var zue = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Gue = zue;
  Nf.default = Gue;
});
var DL = y$1((jf) => {
  Object.defineProperty(jf, "__esModule", {
    value: true
  });
  jf.default = void 0;
  var Wue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "math"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Yue = Wue;
  jf.default = Yue;
});
var $L = y$1((kf) => {
  Object.defineProperty(kf, "__esModule", {
    value: true
  });
  kf.default = void 0;
  var Kue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "vertical"
    },
    relatedConcepts: [{
      concept: {
        name: "MENU"
      },
      module: "JAPI"
    }, {
      concept: {
        name: "list"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }, {
      concept: {
        name: "sidebar"
      },
      module: "DTB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  }, Xue = Kue;
  kf.default = Xue;
});
var BL = y$1((Lf) => {
  Object.defineProperty(Lf, "__esModule", {
    value: true
  });
  Lf.default = void 0;
  var Jue = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      concept: {
        name: "toolbar"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
  }, Que = Jue;
  Lf.default = Que;
});
var HL = y$1((Ff) => {
  Object.defineProperty(Ff, "__esModule", {
    value: true
  });
  Ff.default = void 0;
  var Zue = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "MENU_ITEM"
      },
      module: "JAPI"
    }, {
      concept: {
        name: "listitem"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "option"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  }, ece = Zue;
  Ff.default = ece;
});
var UL = y$1((Df) => {
  Object.defineProperty(Df, "__esModule", {
    value: true
  });
  Df.default = void 0;
  var tce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menuitem"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
  }, rce = tce;
  Df.default = rce;
});
var VL = y$1(($f) => {
  Object.defineProperty($f, "__esModule", {
    value: true
  });
  $f.default = void 0;
  var nce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menuitem"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
  }, oce = nce;
  $f.default = oce;
});
var zL = y$1((Bf) => {
  Object.defineProperty(Bf, "__esModule", {
    value: true
  });
  Bf.default = void 0;
  var ice = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuetext": null,
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [{
      concept: {
        name: "meter"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-valuenow": null
    },
    superClass: [["roletype", "structure", "range"]]
  }, sce = ice;
  Bf.default = sce;
});
var GL = y$1((Hf) => {
  Object.defineProperty(Hf, "__esModule", {
    value: true
  });
  Hf.default = void 0;
  var ace = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "nav"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, lce = ace;
  Hf.default = lce;
});
var WL = y$1((Uf) => {
  Object.defineProperty(Uf, "__esModule", {
    value: true
  });
  Uf.default = void 0;
  var uce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: []
  }, cce = uce;
  Uf.default = cce;
});
var YL = y$1((Vf) => {
  Object.defineProperty(Vf, "__esModule", {
    value: true
  });
  Vf.default = void 0;
  var dce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, pce = dce;
  Vf.default = pce;
});
var KL = y$1((zf) => {
  Object.defineProperty(zf, "__esModule", {
    value: true
  });
  zf.default = void 0;
  var fce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-posinset": null,
      "aria-setsize": null,
      "aria-selected": "false"
    },
    relatedConcepts: [{
      concept: {
        name: "item"
      },
      module: "XForms"
    }, {
      concept: {
        name: "listitem"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "option"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-selected": "false"
    },
    superClass: [["roletype", "widget", "input"]]
  }, mce = fce;
  zf.default = mce;
});
var XL = y$1((Gf) => {
  Object.defineProperty(Gf, "__esModule", {
    value: true
  });
  Gf.default = void 0;
  var hce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "p"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, yce = hce;
  Gf.default = yce;
});
var JL = y$1((Wf) => {
  Object.defineProperty(Wf, "__esModule", {
    value: true
  });
  Wf.default = void 0;
  var bce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "alt",
          value: ""
        }],
        name: "img"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }, gce = bce;
  Wf.default = gce;
});
var QL = y$1((Yf) => {
  Object.defineProperty(Yf, "__esModule", {
    value: true
  });
  Yf.default = void 0;
  var vce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuetext": null
    },
    relatedConcepts: [{
      concept: {
        name: "progress"
      },
      module: "HTML"
    }, {
      concept: {
        name: "status"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
  }, Ece = vce;
  Yf.default = Ece;
});
var ZL = y$1((Kf) => {
  Object.defineProperty(Kf, "__esModule", {
    value: true
  });
  Kf.default = void 0;
  var xce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "radio"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input"]]
  }, wce = xce;
  Kf.default = wce;
});
var eF = y$1((Xf) => {
  Object.defineProperty(Xf, "__esModule", {
    value: true
  });
  Xf.default = void 0;
  var Tce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        name: "list"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["radio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  }, Rce = Tce;
  Xf.default = Rce;
});
var tF = y$1((Jf) => {
  Object.defineProperty(Jf, "__esModule", {
    value: true
  });
  Jf.default = void 0;
  var Sce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-label"
        }],
        name: "section"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-labelledby"
        }],
        name: "section"
      },
      module: "HTML"
    }, {
      concept: {
        name: "Device Independence Glossart perceivable unit"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, _ce = Sce;
  Jf.default = _ce;
});
var rF = y$1((Qf) => {
  Object.defineProperty(Qf, "__esModule", {
    value: true
  });
  Qf.default = void 0;
  var Cce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-colindex": null,
      "aria-expanded": null,
      "aria-level": null,
      "aria-posinset": null,
      "aria-rowindex": null,
      "aria-selected": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "tr"
      },
      module: "HTML"
    }],
    requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
    requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
    requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
  }, Pce = Cce;
  Qf.default = Pce;
});
var nF = y$1((Zf) => {
  Object.defineProperty(Zf, "__esModule", {
    value: true
  });
  Zf.default = void 0;
  var Ace = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "tbody"
      },
      module: "HTML"
    }, {
      concept: {
        name: "tfoot"
      },
      module: "HTML"
    }, {
      concept: {
        name: "thead"
      },
      module: "HTML"
    }],
    requireContextRole: ["grid", "table", "treegrid"],
    requiredContextRole: ["grid", "table", "treegrid"],
    requiredOwnedElements: [["row"]],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }, Oce = Ace;
  Zf.default = Oce;
});
var oF = y$1((em) => {
  Object.defineProperty(em, "__esModule", {
    value: true
  });
  em.default = void 0;
  var qce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-sort": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "scope",
          value: "row"
        }],
        name: "th"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "scope",
          value: "rowgroup"
        }],
        name: "th"
      },
      module: "HTML"
    }],
    requireContextRole: ["row", "rowgroup"],
    requiredContextRole: ["row", "rowgroup"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
  }, Ice = qce;
  em.default = Ice;
});
var iF = y$1((tm) => {
  Object.defineProperty(tm, "__esModule", {
    value: true
  });
  tm.default = void 0;
  var Mce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-valuetext": null,
      "aria-orientation": "vertical",
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-controls": null,
      "aria-valuenow": null
    },
    superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
  }, Nce = Mce;
  tm.default = Nce;
});
var sF = y$1((rm) => {
  Object.defineProperty(rm, "__esModule", {
    value: true
  });
  rm.default = void 0;
  var jce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, kce = jce;
  rm.default = kce;
});
var aF = y$1((nm) => {
  Object.defineProperty(nm, "__esModule", {
    value: true
  });
  nm.default = void 0;
  var Lce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "search"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "input", "textbox"]]
  }, Fce = Lce;
  nm.default = Fce;
});
var lF = y$1((om) => {
  Object.defineProperty(om, "__esModule", {
    value: true
  });
  om.default = void 0;
  var Dce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-orientation": "horizontal",
      "aria-valuemax": "100",
      "aria-valuemin": "0",
      "aria-valuenow": null,
      "aria-valuetext": null
    },
    relatedConcepts: [{
      concept: {
        name: "hr"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  }, $ce = Dce;
  om.default = $ce;
});
var uF = y$1((im) => {
  Object.defineProperty(im, "__esModule", {
    value: true
  });
  im.default = void 0;
  var Bce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-valuetext": null,
      "aria-orientation": "horizontal",
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "range"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-valuenow": null
    },
    superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
  }, Hce = Bce;
  im.default = Hce;
});
var cF = y$1((sm) => {
  Object.defineProperty(sm, "__esModule", {
    value: true
  });
  sm.default = void 0;
  var Uce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-valuetext": null,
      "aria-valuenow": "0"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "number"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
  }, Vce = Uce;
  sm.default = Vce;
});
var dF = y$1((am) => {
  Object.defineProperty(am, "__esModule", {
    value: true
  });
  am.default = void 0;
  var zce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-atomic": "true",
      "aria-live": "polite"
    },
    relatedConcepts: [{
      concept: {
        name: "output"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Gce = zce;
  am.default = Gce;
});
var pF = y$1((lm) => {
  Object.defineProperty(lm, "__esModule", {
    value: true
  });
  lm.default = void 0;
  var Wce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "strong"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Yce = Wce;
  lm.default = Yce;
});
var fF = y$1((um) => {
  Object.defineProperty(um, "__esModule", {
    value: true
  });
  um.default = void 0;
  var Kce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "sub"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Xce = Kce;
  um.default = Xce;
});
var mF = y$1((cm) => {
  Object.defineProperty(cm, "__esModule", {
    value: true
  });
  cm.default = void 0;
  var Jce = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "sup"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Qce = Jce;
  cm.default = Qce;
});
var hF = y$1((dm) => {
  Object.defineProperty(dm, "__esModule", {
    value: true
  });
  dm.default = void 0;
  var Zce = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "button"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox"]]
  }, ede = Zce;
  dm.default = ede;
});
var yF = y$1((pm) => {
  Object.defineProperty(pm, "__esModule", {
    value: true
  });
  pm.default = void 0;
  var tde = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-posinset": null,
      "aria-setsize": null,
      "aria-selected": "false"
    },
    relatedConcepts: [],
    requireContextRole: ["tablist"],
    requiredContextRole: ["tablist"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
  }, rde = tde;
  pm.default = rde;
});
var bF = y$1((fm) => {
  Object.defineProperty(fm, "__esModule", {
    value: true
  });
  fm.default = void 0;
  var nde = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-colcount": null,
      "aria-rowcount": null
    },
    relatedConcepts: [{
      concept: {
        name: "table"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, ode = nde;
  fm.default = ode;
});
var gF = y$1((mm) => {
  Object.defineProperty(mm, "__esModule", {
    value: true
  });
  mm.default = void 0;
  var ide = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-level": null,
      "aria-multiselectable": null,
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      module: "DAISY",
      concept: {
        name: "guide"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["tab"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"]]
  }, sde = ide;
  mm.default = sde;
});
var vF = y$1((hm) => {
  Object.defineProperty(hm, "__esModule", {
    value: true
  });
  hm.default = void 0;
  var ade = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, lde = ade;
  hm.default = lde;
});
var EF = y$1((ym) => {
  Object.defineProperty(ym, "__esModule", {
    value: true
  });
  ym.default = void 0;
  var ude = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dfn"
      },
      module: "HTML"
    }, {
      concept: {
        name: "dt"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, cde = ude;
  ym.default = cde;
});
var xF = y$1((bm) => {
  Object.defineProperty(bm, "__esModule", {
    value: true
  });
  bm.default = void 0;
  var dde = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-autocomplete": null,
      "aria-errormessage": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-multiline": null,
      "aria-placeholder": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "type"
        }, {
          constraints: ["undefined"],
          name: "list"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "email"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "tel"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "text"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        constraints: ["the list attribute is not set"],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "input"
      },
      module: "XForms"
    }, {
      concept: {
        name: "textarea"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "input"]]
  }, pde = dde;
  bm.default = pde;
});
var wF = y$1((gm) => {
  Object.defineProperty(gm, "__esModule", {
    value: true
  });
  gm.default = void 0;
  var fde = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "time"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, mde = fde;
  gm.default = mde;
});
var TF = y$1((vm) => {
  Object.defineProperty(vm, "__esModule", {
    value: true
  });
  vm.default = void 0;
  var hde = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "status"]]
  }, yde = hde;
  vm.default = yde;
});
var RF = y$1((Em) => {
  Object.defineProperty(Em, "__esModule", {
    value: true
  });
  Em.default = void 0;
  var bde = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      concept: {
        name: "menubar"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"]]
  }, gde = bde;
  Em.default = gde;
});
var SF = y$1((xm) => {
  Object.defineProperty(xm, "__esModule", {
    value: true
  });
  xm.default = void 0;
  var vde = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Ede = vde;
  xm.default = Ede;
});
var _F = y$1((wm) => {
  Object.defineProperty(wm, "__esModule", {
    value: true
  });
  wm.default = void 0;
  var xde = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-multiselectable": null,
      "aria-required": null,
      "aria-orientation": "vertical"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  }, wde = xde;
  wm.default = wde;
});
var CF = y$1((Tm) => {
  Object.defineProperty(Tm, "__esModule", {
    value: true
  });
  Tm.default = void 0;
  var Tde = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
  }, Rde = Tde;
  Tm.default = Rde;
});
var PF = y$1((Rm) => {
  Object.defineProperty(Rm, "__esModule", {
    value: true
  });
  Rm.default = void 0;
  var Sde = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-expanded": null,
      "aria-haspopup": null
    },
    relatedConcepts: [],
    requireContextRole: ["group", "tree"],
    requiredContextRole: ["group", "tree"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-selected": null
    },
    superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
  }, _de = Sde;
  Rm.default = _de;
});
var AF = y$1((Sm) => {
  Object.defineProperty(Sm, "__esModule", {
    value: true
  });
  Sm.default = void 0;
  var Cde = B(eL()), Pde = B(tL()), Ade = B(rL()), Ode = B(nL()), qde = B(oL()), Ide = B(iL()), Mde = B(sL()), Nde = B(aL()), jde = B(lL()), kde = B(uL()), Lde = B(cL()), Fde = B(dL()), Dde = B(pL()), $de = B(fL()), Bde = B(mL()), Hde = B(hL()), Ude = B(yL()), Vde = B(bL()), zde = B(
    gL()
  ), Gde = B(vL()), Wde = B(EL()), Yde = B(xL()), Kde = B(wL()), Xde = B(TL()), Jde = B(RL()), Qde = B(SL()), Zde = B(_L()), epe = B(CL()), tpe = B(PL()), rpe = B(AL()), npe = B(OL()), ope = B(qL()), ipe = B(IL()), spe = B(ML()), ape = B(NL()), lpe = B(jL()), upe = B(kL()), cpe = B(
    LL()
  ), dpe = B(FL()), ppe = B(DL()), fpe = B($L()), mpe = B(BL()), hpe = B(HL()), ype = B(UL()), bpe = B(VL()), gpe = B(zL()), vpe = B(GL()), Epe = B(WL()), xpe = B(YL()), wpe = B(KL()), Tpe = B(XL()), Rpe = B(JL()), Spe = B(QL()), _pe = B(ZL()), Cpe = B(eF()), Ppe = B(tF()), Ape = B(
    rF()
  ), Ope = B(nF()), qpe = B(oF()), Ipe = B(iF()), Mpe = B(sF()), Npe = B(aF()), jpe = B(lF()), kpe = B(uF()), Lpe = B(cF()), Fpe = B(dF()), Dpe = B(pF()), $pe = B(fF()), Bpe = B(mF()), Hpe = B(hF()), Upe = B(yF()), Vpe = B(bF()), zpe = B(gF()), Gpe = B(vF()), Wpe = B(EF()), Ype = B(
    xF()
  ), Kpe = B(wF()), Xpe = B(TF()), Jpe = B(RF()), Qpe = B(SF()), Zpe = B(_F()), efe = B(CF()), tfe = B(PF());
  function B(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(B, "_interopRequireDefault");
  var rfe = [
    ["alert", Cde.default],
    ["alertdialog", Pde.default],
    ["application", Ade.default],
    ["article", Ode.default],
    ["banner", qde.default],
    ["blockquote", Ide.default],
    ["button", Mde.default],
    ["caption", Nde.default],
    ["cell", jde.default],
    ["checkbox", kde.default],
    [
      "code",
      Lde.default
    ],
    ["columnheader", Fde.default],
    ["combobox", Dde.default],
    ["complementary", $de.default],
    ["contentinfo", Bde.default],
    ["definition", Hde.default],
    ["deletion", Ude.default],
    ["dialog", Vde.default],
    ["directory", zde.default],
    ["document", Gde.default],
    ["emphasis", Wde.default],
    ["feed", Yde.default],
    ["figure", Kde.default],
    ["form", Xde.default],
    ["generic", Jde.default],
    ["grid", Qde.default],
    [
      "gridcell",
      Zde.default
    ],
    ["group", epe.default],
    ["heading", tpe.default],
    ["img", rpe.default],
    ["insertion", npe.default],
    ["link", ope.default],
    ["list", ipe.default],
    ["listbox", spe.default],
    ["listitem", ape.default],
    ["log", lpe.default],
    ["main", upe.default],
    [
      "mark",
      cpe.default
    ],
    ["marquee", dpe.default],
    ["math", ppe.default],
    ["menu", fpe.default],
    ["menubar", mpe.default],
    ["menuitem", hpe.default],
    ["menuitemcheckbox", ype.default],
    ["menuitemradio", bpe.default],
    ["meter", gpe.default],
    ["navigation", vpe.default],
    ["none", Epe.default],
    ["note", xpe.default],
    ["option", wpe.default],
    ["paragraph", Tpe.default],
    ["presentation", Rpe.default],
    ["progressbar", Spe.default],
    [
      "radio",
      _pe.default
    ],
    ["radiogroup", Cpe.default],
    ["region", Ppe.default],
    ["row", Ape.default],
    ["rowgroup", Ope.default],
    [
      "rowheader",
      qpe.default
    ],
    ["scrollbar", Ipe.default],
    ["search", Mpe.default],
    ["searchbox", Npe.default],
    ["separator", jpe.default],
    ["slider", kpe.default],
    ["spinbutton", Lpe.default],
    ["status", Fpe.default],
    ["strong", Dpe.default],
    ["subscript", $pe.default],
    ["superscript", Bpe.default],
    ["switch", Hpe.default],
    ["tab", Upe.default],
    ["table", Vpe.default],
    ["tablist", zpe.default],
    ["tabpanel", Gpe.default],
    ["term", Wpe.default],
    ["textbox", Ype.default],
    ["time", Kpe.default],
    ["timer", Xpe.default],
    ["toolbar", Jpe.default],
    ["tooltip", Qpe.default],
    ["tree", Zpe.default],
    ["treegrid", efe.default],
    ["treeitem", tfe.default]
  ], nfe = rfe;
  Sm.default = nfe;
});
var OF = y$1((_m) => {
  Object.defineProperty(_m, "__esModule", {
    value: true
  });
  _m.default = void 0;
  var ofe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "abstract [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, ife = ofe;
  _m.default = ife;
});
var qF = y$1((Cm) => {
  Object.defineProperty(Cm, "__esModule", {
    value: true
  });
  Cm.default = void 0;
  var sfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "acknowledgments [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, afe = sfe;
  Cm.default = afe;
});
var IF = y$1((Pm) => {
  Object.defineProperty(Pm, "__esModule", {
    value: true
  });
  Pm.default = void 0;
  var lfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "afterword [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, ufe = lfe;
  Pm.default = ufe;
});
var MF = y$1((Am) => {
  Object.defineProperty(Am, "__esModule", {
    value: true
  });
  Am.default = void 0;
  var cfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "appendix [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, dfe = cfe;
  Am.default = dfe;
});
var NF = y$1((Om) => {
  Object.defineProperty(Om, "__esModule", {
    value: true
  });
  Om.default = void 0;
  var pfe = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "referrer [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  }, ffe = pfe;
  Om.default = ffe;
});
var jF = y$1((qm) => {
  Object.defineProperty(qm, "__esModule", {
    value: true
  });
  qm.default = void 0;
  var mfe = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "EPUB biblioentry [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: ["doc-bibliography"],
    requiredContextRole: ["doc-bibliography"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "listitem"]]
  }, hfe = mfe;
  qm.default = hfe;
});
var kF = y$1((Im) => {
  Object.defineProperty(Im, "__esModule", {
    value: true
  });
  Im.default = void 0;
  var yfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "bibliography [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["doc-biblioentry"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, bfe = yfe;
  Im.default = bfe;
});
var LF = y$1((Mm) => {
  Object.defineProperty(Mm, "__esModule", {
    value: true
  });
  Mm.default = void 0;
  var gfe = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "biblioref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  }, vfe = gfe;
  Mm.default = vfe;
});
var FF = y$1((Nm) => {
  Object.defineProperty(Nm, "__esModule", {
    value: true
  });
  Nm.default = void 0;
  var Efe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "chapter [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, xfe = Efe;
  Nm.default = xfe;
});
var DF = y$1((jm) => {
  Object.defineProperty(jm, "__esModule", {
    value: true
  });
  jm.default = void 0;
  var wfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "colophon [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Tfe = wfe;
  jm.default = Tfe;
});
var $F = y$1((km) => {
  Object.defineProperty(km, "__esModule", {
    value: true
  });
  km.default = void 0;
  var Rfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "conclusion [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, Sfe = Rfe;
  km.default = Sfe;
});
var BF = y$1((Lm) => {
  Object.defineProperty(Lm, "__esModule", {
    value: true
  });
  Lm.default = void 0;
  var _fe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "cover [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "img"]]
  }, Cfe = _fe;
  Lm.default = Cfe;
});
var HF = y$1((Fm) => {
  Object.defineProperty(Fm, "__esModule", {
    value: true
  });
  Fm.default = void 0;
  var Pfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "credit [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Afe = Pfe;
  Fm.default = Afe;
});
var UF = y$1((Dm) => {
  Object.defineProperty(Dm, "__esModule", {
    value: true
  });
  Dm.default = void 0;
  var Ofe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "credits [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, qfe = Ofe;
  Dm.default = qfe;
});
var VF = y$1(($m) => {
  Object.defineProperty($m, "__esModule", {
    value: true
  });
  $m.default = void 0;
  var Ife = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "dedication [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Mfe = Ife;
  $m.default = Mfe;
});
var zF = y$1((Bm) => {
  Object.defineProperty(Bm, "__esModule", {
    value: true
  });
  Bm.default = void 0;
  var Nfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "rearnote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: ["doc-endnotes"],
    requiredContextRole: ["doc-endnotes"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "listitem"]]
  }, jfe = Nfe;
  Bm.default = jfe;
});
var GF = y$1((Hm) => {
  Object.defineProperty(Hm, "__esModule", {
    value: true
  });
  Hm.default = void 0;
  var kfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "rearnotes [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["doc-endnote"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, Lfe = kfe;
  Hm.default = Lfe;
});
var WF = y$1((Um) => {
  Object.defineProperty(Um, "__esModule", {
    value: true
  });
  Um.default = void 0;
  var Ffe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "epigraph [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Dfe = Ffe;
  Um.default = Dfe;
});
var YF = y$1((Vm) => {
  Object.defineProperty(Vm, "__esModule", {
    value: true
  });
  Vm.default = void 0;
  var $fe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "epilogue [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, Bfe = $fe;
  Vm.default = Bfe;
});
var KF = y$1((zm) => {
  Object.defineProperty(zm, "__esModule", {
    value: true
  });
  zm.default = void 0;
  var Hfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "errata [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, Ufe = Hfe;
  zm.default = Ufe;
});
var XF = y$1((Gm) => {
  Object.defineProperty(Gm, "__esModule", {
    value: true
  });
  Gm.default = void 0;
  var Vfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, zfe = Vfe;
  Gm.default = zfe;
});
var JF = y$1((Wm) => {
  Object.defineProperty(Wm, "__esModule", {
    value: true
  });
  Wm.default = void 0;
  var Gfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "footnote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, Wfe = Gfe;
  Wm.default = Wfe;
});
var QF = y$1((Ym) => {
  Object.defineProperty(Ym, "__esModule", {
    value: true
  });
  Ym.default = void 0;
  var Yfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "foreword [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, Kfe = Yfe;
  Ym.default = Kfe;
});
var ZF = y$1((Km) => {
  Object.defineProperty(Km, "__esModule", {
    value: true
  });
  Km.default = void 0;
  var Xfe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "glossary [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["definition"], ["term"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, Jfe = Xfe;
  Km.default = Jfe;
});
var eD = y$1((Xm) => {
  Object.defineProperty(Xm, "__esModule", {
    value: true
  });
  Xm.default = void 0;
  var Qfe = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "glossref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  }, Zfe = Qfe;
  Xm.default = Zfe;
});
var tD = y$1((Jm) => {
  Object.defineProperty(Jm, "__esModule", {
    value: true
  });
  Jm.default = void 0;
  var eme = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "index [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  }, tme = eme;
  Jm.default = tme;
});
var rD = y$1((Qm) => {
  Object.defineProperty(Qm, "__esModule", {
    value: true
  });
  Qm.default = void 0;
  var rme = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "introduction [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, nme = rme;
  Qm.default = nme;
});
var nD = y$1((Zm) => {
  Object.defineProperty(Zm, "__esModule", {
    value: true
  });
  Zm.default = void 0;
  var ome = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "noteref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  }, ime = ome;
  Zm.default = ime;
});
var oD = y$1((eh) => {
  Object.defineProperty(eh, "__esModule", {
    value: true
  });
  eh.default = void 0;
  var sme = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "notice [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "note"]]
  }, ame = sme;
  eh.default = ame;
});
var iD = y$1((th) => {
  Object.defineProperty(th, "__esModule", {
    value: true
  });
  th.default = void 0;
  var lme = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "pagebreak [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "separator"]]
  }, ume = lme;
  th.default = ume;
});
var sD = y$1((rh) => {
  Object.defineProperty(rh, "__esModule", {
    value: true
  });
  rh.default = void 0;
  var cme = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "page-list [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  }, dme = cme;
  rh.default = dme;
});
var aD = y$1((nh) => {
  Object.defineProperty(nh, "__esModule", {
    value: true
  });
  nh.default = void 0;
  var pme = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "part [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, fme = pme;
  nh.default = fme;
});
var lD = y$1((oh) => {
  Object.defineProperty(oh, "__esModule", {
    value: true
  });
  oh.default = void 0;
  var mme = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "preface [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, hme = mme;
  oh.default = hme;
});
var uD = y$1((ih) => {
  Object.defineProperty(ih, "__esModule", {
    value: true
  });
  ih.default = void 0;
  var yme = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "prologue [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  }, bme = yme;
  ih.default = bme;
});
var cD = y$1((sh) => {
  Object.defineProperty(sh, "__esModule", {
    value: true
  });
  sh.default = void 0;
  var gme = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "pullquote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["none"]]
  }, vme = gme;
  sh.default = vme;
});
var dD = y$1((ah) => {
  Object.defineProperty(ah, "__esModule", {
    value: true
  });
  ah.default = void 0;
  var Eme = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "qna [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  }, xme = Eme;
  ah.default = xme;
});
var pD = y$1((lh) => {
  Object.defineProperty(lh, "__esModule", {
    value: true
  });
  lh.default = void 0;
  var wme = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "subtitle [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "sectionhead"]]
  }, Tme = wme;
  lh.default = Tme;
});
var fD = y$1((uh) => {
  Object.defineProperty(uh, "__esModule", {
    value: true
  });
  uh.default = void 0;
  var Rme = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "help [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "note"]]
  }, Sme = Rme;
  uh.default = Sme;
});
var mD = y$1((ch) => {
  Object.defineProperty(ch, "__esModule", {
    value: true
  });
  ch.default = void 0;
  var _me = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "toc [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  }, Cme = _me;
  ch.default = Cme;
});
var hD = y$1((dh) => {
  Object.defineProperty(dh, "__esModule", {
    value: true
  });
  dh.default = void 0;
  var Pme = ne(OF()), Ame = ne(qF()), Ome = ne(IF()), qme = ne(MF()), Ime = ne(NF()), Mme = ne(jF()), Nme = ne(kF()), jme = ne(LF()), kme = ne(
    FF()
  ), Lme = ne(DF()), Fme = ne($F()), Dme = ne(BF()), $me = ne(HF()), Bme = ne(UF()), Hme = ne(VF()), Ume = ne(zF()), Vme = ne(GF()), zme = ne(
    WF()
  ), Gme = ne(YF()), Wme = ne(KF()), Yme = ne(XF()), Kme = ne(JF()), Xme = ne(QF()), Jme = ne(ZF()), Qme = ne(eD()), Zme = ne(tD()), ehe = ne(
    rD()
  ), the = ne(nD()), rhe = ne(oD()), nhe = ne(iD()), ohe = ne(sD()), ihe = ne(aD()), she = ne(lD()), ahe = ne(uD()), lhe = ne(cD()), uhe = ne(
    dD()
  ), che = ne(pD()), dhe = ne(fD()), phe = ne(mD());
  function ne(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(ne, "_interopRequireDefault");
  var fhe = [
    ["doc-abstract", Pme.default],
    ["doc-acknowledgments", Ame.default],
    ["doc-afterword", Ome.default],
    ["doc-appendix", qme.default],
    ["doc-backlink", Ime.default],
    ["doc-biblioentry", Mme.default],
    ["doc-bibliography", Nme.default],
    ["doc-biblioref", jme.default],
    ["doc-chapter", kme.default],
    ["doc-colophon", Lme.default],
    ["doc-conclusion", Fme.default],
    ["doc-cover", Dme.default],
    ["doc-credit", $me.default],
    ["doc-credits", Bme.default],
    ["doc-dedication", Hme.default],
    ["doc-endnote", Ume.default],
    ["doc-endnotes", Vme.default],
    [
      "doc-epigraph",
      zme.default
    ],
    ["doc-epilogue", Gme.default],
    ["doc-errata", Wme.default],
    ["doc-example", Yme.default],
    ["doc-footnote", Kme.default],
    ["doc-foreword", Xme.default],
    ["doc-glossary", Jme.default],
    ["doc-glossref", Qme.default],
    ["doc-index", Zme.default],
    ["doc-introduction", ehe.default],
    ["doc-noteref", the.default],
    ["doc-notice", rhe.default],
    ["doc-pagebreak", nhe.default],
    ["doc-pagelist", ohe.default],
    ["doc-part", ihe.default],
    ["doc-preface", she.default],
    ["doc-prologue", ahe.default],
    ["doc-pullquote", lhe.default],
    ["doc-qna", uhe.default],
    [
      "doc-subtitle",
      che.default
    ],
    ["doc-tip", dhe.default],
    ["doc-toc", phe.default]
  ], mhe = fhe;
  dh.default = mhe;
});
var yD = y$1((ph) => {
  Object.defineProperty(ph, "__esModule", {
    value: true
  });
  ph.default = void 0;
  var hhe = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      module: "GRAPHICS",
      concept: {
        name: "graphics-object"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "img"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "article"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "document"]]
  }, yhe = hhe;
  ph.default = yhe;
});
var bD = y$1((fh) => {
  Object.defineProperty(fh, "__esModule", {
    value: true
  });
  fh.default = void 0;
  var bhe = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      module: "GRAPHICS",
      concept: {
        name: "graphics-document"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "group"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "img"
      }
    }, {
      module: "GRAPHICS",
      concept: {
        name: "graphics-symbol"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"]]
  }, ghe = bhe;
  fh.default = ghe;
});
var gD = y$1((mh) => {
  Object.defineProperty(mh, "__esModule", {
    value: true
  });
  mh.default = void 0;
  var vhe = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "img"]]
  }, Ehe = vhe;
  mh.default = Ehe;
});
var vD = y$1((hh) => {
  Object.defineProperty(hh, "__esModule", {
    value: true
  });
  hh.default = void 0;
  var xhe = Ow(yD()), whe = Ow(bD()), The = Ow(gD());
  function Ow(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(Ow, "_interopRequireDefault");
  var Rhe = [["graphics-document", xhe.default], ["graphics-object", whe.default], ["graphics-symbol", The.default]], She = Rhe;
  hh.default = She;
});
var bh = y$1((yh) => {
  Object.defineProperty(yh, "__esModule", {
    value: true
  });
  yh.default = void 0;
  var _he = Xs(Zk()), Che = Xs(AF()), Phe = Xs(hD()), Ahe = Xs(vD()), Ohe = Xs(Jo());
  function Xs(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(Xs, "_interopRequireDefault");
  function qhe(e, t, r) {
    return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
  }
  o(qhe, "_defineProperty");
  function qw(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = xD(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var n = 0, i = /* @__PURE__ */ o(function() {
        }, "F");
        return { s: i, n: /* @__PURE__ */ o(function() {
          return n >= e.length ? { done: true } : { done: false, value: e[n++] };
        }, "n"), e: /* @__PURE__ */ o(function(c) {
          throw c;
        }, "e"), f: i };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var s = true, a = false, l;
    return { s: /* @__PURE__ */ o(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ o(function() {
      var c = r.next();
      return s = c.done, c;
    }, "n"), e: /* @__PURE__ */ o(function(c) {
      a = true, l = c;
    }, "e"), f: /* @__PURE__ */ o(function() {
      try {
        !s && r.return != null && r.return();
      } finally {
        if (a) throw l;
      }
    }, "f") };
  }
  o(qw, "_createForOfIteratorHelper");
  function Ks(e, t) {
    return Nhe(e) || Mhe(e, t) || xD(e, t) || Ihe();
  }
  o(Ks, "_slicedToArray");
  function Ihe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  o(Ihe, "_nonIterableRest");
  function xD(e, t) {
    if (e) {
      if (typeof e == "string") return ED(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return ED(e, t);
    }
  }
  o(xD, "_unsupportedIterableToArray");
  function ED(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++)
      n[r] = e[r];
    return n;
  }
  o(ED, "_arrayLikeToArray");
  function Mhe(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
      var n = [], i = true, s = false, a, l;
      try {
        for (r = r.call(e); !(i = (a = r.next()).done) && (n.push(a.value), !(t && n.length === t)); i = true)
          ;
      } catch (u) {
        s = true, l = u;
      } finally {
        try {
          !i && r.return != null && r.return();
        } finally {
          if (s) throw l;
        }
      }
      return n;
    }
  }
  o(Mhe, "_iterableToArrayLimit");
  function Nhe(e) {
    if (Array.isArray(e)) return e;
  }
  o(Nhe, "_arrayWithHoles");
  var Zr = [].concat(_he.default, Che.default, Phe.default, Ahe.default);
  Zr.forEach(function(e) {
    var t = Ks(e, 2), r = t[1], n = qw(r.superClass), i;
    try {
      for (n.s(); !(i = n.n()).done; ) {
        var s = i.value, a = qw(s), l;
        try {
          var u = /* @__PURE__ */ o(function() {
            var d = l.value, p = Zr.find(function(v) {
              var g = Ks(v, 1), w = g[0];
              return w === d;
            });
            if (p)
              for (var f = p[1], m = 0, h = Object.keys(f.props); m < h.length; m++) {
                var b = h[m];
                Object.prototype.hasOwnProperty.call(r.props, b) || Object.assign(r.props, qhe({}, b, f.props[b]));
              }
          }, "_loop");
          for (a.s(); !(l = a.n()).done; )
            u();
        } catch (c) {
          a.e(c);
        } finally {
          a.f();
        }
      }
    } catch (c) {
      n.e(c);
    } finally {
      n.f();
    }
  });
  var Iw = {
    entries: /* @__PURE__ */ o(function() {
      return Zr;
    }, "entries"),
    forEach: /* @__PURE__ */ o(function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = qw(Zr), i;
      try {
        for (n.s(); !(i = n.n()).done; ) {
          var s = Ks(i.value, 2), a = s[0], l = s[1];
          t.call(r, l, a, Zr);
        }
      } catch (u) {
        n.e(u);
      } finally {
        n.f();
      }
    }, "forEach"),
    get: /* @__PURE__ */ o(function(t) {
      var r = Zr.find(function(n) {
        return n[0] === t;
      });
      return r && r[1];
    }, "get"),
    has: /* @__PURE__ */ o(function(t) {
      return !!Iw.get(t);
    }, "has"),
    keys: /* @__PURE__ */ o(function() {
      return Zr.map(function(t) {
        var r = Ks(t, 1), n = r[0];
        return n;
      });
    }, "keys"),
    values: /* @__PURE__ */ o(function() {
      return Zr.map(function(t) {
        var r = Ks(t, 2), n = r[1];
        return n;
      });
    }, "values")
  }, jhe = (0, Ohe.default)(Iw, Iw.entries());
  yh.default = jhe;
});
var TD = {};
st$1(TD, {
  dequal: () => Mw
});
function Mw(e, t) {
  var r, n;
  if (e === t) return true;
  if (e && t && (r = e.constructor) === t.constructor) {
    if (r === Date) return e.getTime() === t.getTime();
    if (r === RegExp) return e.toString() === t.toString();
    if (r === Array) {
      if ((n = e.length) === t.length)
        for (; n-- && Mw(e[n], t[n]); ) ;
      return n === -1;
    }
    if (!r || typeof e == "object") {
      n = 0;
      for (r in e)
        if (wD.call(e, r) && ++n && !wD.call(t, r) || !(r in t) || !Mw(e[r], t[r])) return false;
      return Object.keys(t).length === n;
    }
  }
  return e !== e && t !== t;
}
var wD, RD = X5(() => {
  wD = Object.prototype.hasOwnProperty;
  o(Mw, "dequal");
});
var qD = y$1((wh) => {
  Object.defineProperty(wh, "__esModule", {
    value: true
  });
  wh.default = void 0;
  var CD = (RD(), J5(TD)), khe = AD(Jo()), PD = AD(bh());
  function AD(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(AD, "_interopRequireDefault");
  function Nw(e, t) {
    return Dhe(e) || Fhe(e, t) || OD(e, t) || Lhe();
  }
  o(Nw, "_slicedToArray");
  function Lhe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  o(Lhe, "_nonIterableRest");
  function Fhe(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
      var n = [], i = true, s = false, a, l;
      try {
        for (r = r.call(e); !(i = (a = r.next()).done) && (n.push(a.value), !(t && n.length === t)); i = true)
          ;
      } catch (u) {
        s = true, l = u;
      } finally {
        try {
          !i && r.return != null && r.return();
        } finally {
          if (s) throw l;
        }
      }
      return n;
    }
  }
  o(Fhe, "_iterableToArrayLimit");
  function Dhe(e) {
    if (Array.isArray(e)) return e;
  }
  o(Dhe, "_arrayWithHoles");
  function $he(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = OD(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var n = 0, i = /* @__PURE__ */ o(function() {
        }, "F");
        return { s: i, n: /* @__PURE__ */ o(function() {
          return n >= e.length ? { done: true } : { done: false, value: e[n++] };
        }, "n"), e: /* @__PURE__ */ o(function(c) {
          throw c;
        }, "e"), f: i };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var s = true, a = false, l;
    return { s: /* @__PURE__ */ o(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ o(function() {
      var c = r.next();
      return s = c.done, c;
    }, "n"), e: /* @__PURE__ */ o(function(c) {
      a = true, l = c;
    }, "e"), f: /* @__PURE__ */ o(function() {
      try {
        !s && r.return != null && r.return();
      } finally {
        if (a) throw l;
      }
    }, "f") };
  }
  o($he, "_createForOfIteratorHelper");
  function OD(e, t) {
    if (e) {
      if (typeof e == "string") return SD(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return SD(e, t);
    }
  }
  o(OD, "_unsupportedIterableToArray");
  function SD(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++)
      n[r] = e[r];
    return n;
  }
  o(SD, "_arrayLikeToArray");
  var en = [], _D = PD.default.keys();
  for (gh = 0; gh < _D.length; gh++)
    if (vh = _D[gh], Eh = PD.default.get(vh), Eh)
      for (jw = [].concat(Eh.baseConcepts, Eh.relatedConcepts), xh = 0; xh < jw.length; xh++)
        kw = jw[xh], kw.module === "HTML" && function() {
          var e = kw.concept;
          if (e) {
            var t = en.find(function(s) {
              return (0, CD.dequal)(s, e);
            }), r;
            t ? r = t[1] : r = [];
            for (var n = true, i = 0; i < r.length; i++)
              if (r[i] === vh) {
                n = false;
                break;
              }
            n && r.push(vh), en.push([e, r]);
          }
        }();
  var vh, Eh, jw, kw, xh, gh, Lw = {
    entries: /* @__PURE__ */ o(function() {
      return en;
    }, "entries"),
    forEach: /* @__PURE__ */ o(function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = $he(en), i;
      try {
        for (n.s(); !(i = n.n()).done; ) {
          var s = Nw(i.value, 2), a = s[0], l = s[1];
          t.call(r, l, a, en);
        }
      } catch (u) {
        n.e(u);
      } finally {
        n.f();
      }
    }, "forEach"),
    get: /* @__PURE__ */ o(function(t) {
      var r = en.find(function(n) {
        return t.name === n[0].name && (0, CD.dequal)(t.attributes, n[0].attributes);
      });
      return r && r[1];
    }, "get"),
    has: /* @__PURE__ */ o(function(t) {
      return !!Lw.get(t);
    }, "has"),
    keys: /* @__PURE__ */ o(function() {
      return en.map(function(t) {
        var r = Nw(t, 1), n = r[0];
        return n;
      });
    }, "keys"),
    values: /* @__PURE__ */ o(function() {
      return en.map(function(t) {
        var r = Nw(t, 2), n = r[1];
        return n;
      });
    }, "values")
  }, Bhe = (0, khe.default)(Lw, Lw.entries());
  wh.default = Bhe;
});
var LD = y$1((Ch) => {
  Object.defineProperty(Ch, "__esModule", {
    value: true
  });
  Ch.default = void 0;
  var Hhe = jD(Jo()), ND = jD(bh());
  function jD(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(jD, "_interopRequireDefault");
  function Fw(e, t) {
    return zhe(e) || Vhe(e, t) || kD(e, t) || Uhe();
  }
  o(Fw, "_slicedToArray");
  function Uhe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  o(Uhe, "_nonIterableRest");
  function Vhe(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
      var n = [], i = true, s = false, a, l;
      try {
        for (r = r.call(e); !(i = (a = r.next()).done) && (n.push(a.value), !(t && n.length === t)); i = true)
          ;
      } catch (u) {
        s = true, l = u;
      } finally {
        try {
          !i && r.return != null && r.return();
        } finally {
          if (s) throw l;
        }
      }
      return n;
    }
  }
  o(Vhe, "_iterableToArrayLimit");
  function zhe(e) {
    if (Array.isArray(e)) return e;
  }
  o(zhe, "_arrayWithHoles");
  function Ghe(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = kD(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var n = 0, i = /* @__PURE__ */ o(function() {
        }, "F");
        return { s: i, n: /* @__PURE__ */ o(function() {
          return n >= e.length ? { done: true } : { done: false, value: e[n++] };
        }, "n"), e: /* @__PURE__ */ o(function(c) {
          throw c;
        }, "e"), f: i };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var s = true, a = false, l;
    return { s: /* @__PURE__ */ o(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ o(function() {
      var c = r.next();
      return s = c.done, c;
    }, "n"), e: /* @__PURE__ */ o(function(c) {
      a = true, l = c;
    }, "e"), f: /* @__PURE__ */ o(function() {
      try {
        !s && r.return != null && r.return();
      } finally {
        if (a) throw l;
      }
    }, "f") };
  }
  o(Ghe, "_createForOfIteratorHelper");
  function kD(e, t) {
    if (e) {
      if (typeof e == "string") return ID(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return ID(e, t);
    }
  }
  o(kD, "_unsupportedIterableToArray");
  function ID(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++)
      n[r] = e[r];
    return n;
  }
  o(ID, "_arrayLikeToArray");
  var On = [], MD = ND.default.keys();
  for (Th = 0; Th < MD.length; Th++)
    if (Dw = MD[Th], Rh = ND.default.get(Dw), Sh = [], Rh) {
      for ($w = [].concat(Rh.baseConcepts, Rh.relatedConcepts), _h = 0; _h < $w.length; _h++)
        Bw = $w[_h], Bw.module === "HTML" && (Hw = Bw.concept, Hw != null && Sh.push(Hw));
      Sh.length > 0 && On.push([Dw, Sh]);
    }
  var Dw, Rh, Sh, $w, Bw, Hw, _h, Th, Uw = {
    entries: /* @__PURE__ */ o(function() {
      return On;
    }, "entries"),
    forEach: /* @__PURE__ */ o(function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = Ghe(On), i;
      try {
        for (n.s(); !(i = n.n()).done; ) {
          var s = Fw(i.value, 2), a = s[0], l = s[1];
          t.call(r, l, a, On);
        }
      } catch (u) {
        n.e(u);
      } finally {
        n.f();
      }
    }, "forEach"),
    get: /* @__PURE__ */ o(function(t) {
      var r = On.find(function(n) {
        return n[0] === t;
      });
      return r && r[1];
    }, "get"),
    has: /* @__PURE__ */ o(function(t) {
      return !!Uw.get(t);
    }, "has"),
    keys: /* @__PURE__ */ o(function() {
      return On.map(function(t) {
        var r = Fw(t, 1), n = r[0];
        return n;
      });
    }, "keys"),
    values: /* @__PURE__ */ o(function() {
      return On.map(function(t) {
        var r = Fw(t, 2), n = r[1];
        return n;
      });
    }, "values")
  }, Whe = (0, Hhe.default)(Uw, Uw.entries());
  Ch.default = Whe;
});
var FD = y$1((Mt) => {
  Object.defineProperty(Mt, "__esModule", {
    value: true
  });
  Mt.roles = Mt.roleElements = Mt.elementRoles = Mt.dom = Mt.aria = void 0;
  var Yhe = Js(Lk()), Khe = Js($k()), Xhe = Js(bh()), Jhe = Js(qD()), Qhe = Js(LD());
  function Js(e) {
    return e && e.__esModule ? e : { default: e };
  }
  o(Js, "_interopRequireDefault");
  var Zhe = Yhe.default;
  Mt.aria = Zhe;
  var eye = Khe.default;
  Mt.dom = eye;
  var tye = Xhe.default;
  Mt.roles = tye;
  var rye = Jhe.default;
  Mt.elementRoles = rye;
  var nye = Qhe.default;
  Mt.roleElements = nye;
});
var DD = y$1((EDe, Ph) => {
  var Vw = function() {
    var e = String.fromCharCode, t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", n = {};
    function i(a, l) {
      if (!n[a]) {
        n[a] = {};
        for (var u = 0; u < a.length; u++)
          n[a][a.charAt(u)] = u;
      }
      return n[a][l];
    }
    o(i, "getBaseValue");
    var s = {
      compressToBase64: /* @__PURE__ */ o(function(a) {
        if (a == null) return "";
        var l = s._compress(a, 6, function(u) {
          return t.charAt(u);
        });
        switch (l.length % 4) {
          default:
          case 0:
            return l;
          case 1:
            return l + "===";
          case 2:
            return l + "==";
          case 3:
            return l + "=";
        }
      }, "compressToBase64"),
      decompressFromBase64: /* @__PURE__ */ o(function(a) {
        return a == null ? "" : a == "" ? null : s._decompress(a.length, 32, function(l) {
          return i(t, a.charAt(l));
        });
      }, "decompressFromBase64"),
      compressToUTF16: /* @__PURE__ */ o(function(a) {
        return a == null ? "" : s._compress(a, 15, function(l) {
          return e(l + 32);
        }) + " ";
      }, "compressToUTF16"),
      decompressFromUTF16: /* @__PURE__ */ o(function(a) {
        return a == null ? "" : a == "" ? null : s._decompress(a.length, 16384, function(l) {
          return a.charCodeAt(l) - 32;
        });
      }, "decompressFromUTF16"),
      //compress into uint8array (UCS-2 big endian format)
      compressToUint8Array: /* @__PURE__ */ o(function(a) {
        for (var l = s.compress(a), u = new Uint8Array(l.length * 2), c = 0, d = l.length; c < d; c++) {
          var p = l.charCodeAt(c);
          u[c * 2] = p >>> 8, u[c * 2 + 1] = p % 256;
        }
        return u;
      }, "compressToUint8Array"),
      //decompress from uint8array (UCS-2 big endian format)
      decompressFromUint8Array: /* @__PURE__ */ o(function(a) {
        if (a == null)
          return s.decompress(a);
        for (var l = new Array(a.length / 2), u = 0, c = l.length; u < c; u++)
          l[u] = a[u * 2] * 256 + a[u * 2 + 1];
        var d = [];
        return l.forEach(function(p) {
          d.push(e(p));
        }), s.decompress(d.join(""));
      }, "decompressFromUint8Array"),
      //compress into a string that is already URI encoded
      compressToEncodedURIComponent: /* @__PURE__ */ o(function(a) {
        return a == null ? "" : s._compress(a, 6, function(l) {
          return r.charAt(l);
        });
      }, "compressToEncodedURIComponent"),
      //decompress from an output of compressToEncodedURIComponent
      decompressFromEncodedURIComponent: /* @__PURE__ */ o(function(a) {
        return a == null ? "" : a == "" ? null : (a = a.replace(/ /g, "+"), s._decompress(a.length, 32, function(l) {
          return i(r, a.charAt(l));
        }));
      }, "decompressFromEncodedURIComponent"),
      compress: /* @__PURE__ */ o(function(a) {
        return s._compress(a, 16, function(l) {
          return e(l);
        });
      }, "compress"),
      _compress: /* @__PURE__ */ o(function(a, l, u) {
        if (a == null) return "";
        var c, d, p = {}, f = {}, m = "", h = "", b = "", v = 2, g = 3, w = 2, E = [], R = 0, S = 0, P;
        for (P = 0; P < a.length; P += 1)
          if (m = a.charAt(P), Object.prototype.hasOwnProperty.call(p, m) || (p[m] = g++, f[m] = true), h = b + m, Object.prototype.hasOwnProperty.call(p, h))
            b = h;
          else {
            if (Object.prototype.hasOwnProperty.call(f, b)) {
              if (b.charCodeAt(0) < 256) {
                for (c = 0; c < w; c++)
                  R = R << 1, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++;
                for (d = b.charCodeAt(0), c = 0; c < 8; c++)
                  R = R << 1 | d & 1, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++, d = d >> 1;
              } else {
                for (d = 1, c = 0; c < w; c++)
                  R = R << 1 | d, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++, d = 0;
                for (d = b.charCodeAt(0), c = 0; c < 16; c++)
                  R = R << 1 | d & 1, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++, d = d >> 1;
              }
              v--, v == 0 && (v = Math.pow(2, w), w++), delete f[b];
            } else
              for (d = p[b], c = 0; c < w; c++)
                R = R << 1 | d & 1, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++, d = d >> 1;
            v--, v == 0 && (v = Math.pow(2, w), w++), p[h] = g++, b = String(m);
          }
        if (b !== "") {
          if (Object.prototype.hasOwnProperty.call(f, b)) {
            if (b.charCodeAt(0) < 256) {
              for (c = 0; c < w; c++)
                R = R << 1, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++;
              for (d = b.charCodeAt(0), c = 0; c < 8; c++)
                R = R << 1 | d & 1, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++, d = d >> 1;
            } else {
              for (d = 1, c = 0; c < w; c++)
                R = R << 1 | d, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++, d = 0;
              for (d = b.charCodeAt(0), c = 0; c < 16; c++)
                R = R << 1 | d & 1, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++, d = d >> 1;
            }
            v--, v == 0 && (v = Math.pow(2, w), w++), delete f[b];
          } else
            for (d = p[b], c = 0; c < w; c++)
              R = R << 1 | d & 1, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++, d = d >> 1;
          v--, v == 0 && (v = Math.pow(2, w), w++);
        }
        for (d = 2, c = 0; c < w; c++)
          R = R << 1 | d & 1, S == l - 1 ? (S = 0, E.push(u(R)), R = 0) : S++, d = d >> 1;
        for (; ; )
          if (R = R << 1, S == l - 1) {
            E.push(u(R));
            break;
          } else S++;
        return E.join("");
      }, "_compress"),
      decompress: /* @__PURE__ */ o(function(a) {
        return a == null ? "" : a == "" ? null : s._decompress(a.length, 32768, function(l) {
          return a.charCodeAt(l);
        });
      }, "decompress"),
      _decompress: /* @__PURE__ */ o(function(a, l, u) {
        var c = [], p = 4, f = 4, m = 3, h = "", b = [], v, g, w, E, R, S, P, _ = { val: u(0), position: l, index: 1 };
        for (v = 0; v < 3; v += 1)
          c[v] = v;
        for (w = 0, R = Math.pow(2, 2), S = 1; S != R; )
          E = _.val & _.position, _.position >>= 1, _.position == 0 && (_.position = l, _.val = u(_.index++)), w |= (E > 0 ? 1 : 0) * S, S <<= 1;
        switch (w) {
          case 0:
            for (w = 0, R = Math.pow(2, 8), S = 1; S != R; )
              E = _.val & _.position, _.position >>= 1, _.position == 0 && (_.position = l, _.val = u(_.index++)), w |= (E > 0 ? 1 : 0) * S, S <<= 1;
            P = e(w);
            break;
          case 1:
            for (w = 0, R = Math.pow(2, 16), S = 1; S != R; )
              E = _.val & _.position, _.position >>= 1, _.position == 0 && (_.position = l, _.val = u(_.index++)), w |= (E > 0 ? 1 : 0) * S, S <<= 1;
            P = e(w);
            break;
          case 2:
            return "";
        }
        for (c[3] = P, g = P, b.push(P); ; ) {
          if (_.index > a)
            return "";
          for (w = 0, R = Math.pow(2, m), S = 1; S != R; )
            E = _.val & _.position, _.position >>= 1, _.position == 0 && (_.position = l, _.val = u(_.index++)), w |= (E > 0 ? 1 : 0) * S, S <<= 1;
          switch (P = w) {
            case 0:
              for (w = 0, R = Math.pow(2, 8), S = 1; S != R; )
                E = _.val & _.position, _.position >>= 1, _.position == 0 && (_.position = l, _.val = u(_.index++)), w |= (E > 0 ? 1 : 0) * S, S <<= 1;
              c[f++] = e(w), P = f - 1, p--;
              break;
            case 1:
              for (w = 0, R = Math.pow(2, 16), S = 1; S != R; )
                E = _.val & _.position, _.position >>= 1, _.position == 0 && (_.position = l, _.val = u(_.index++)), w |= (E > 0 ? 1 : 0) * S, S <<= 1;
              c[f++] = e(w), P = f - 1, p--;
              break;
            case 2:
              return b.join("");
          }
          if (p == 0 && (p = Math.pow(2, m), m++), c[P])
            h = c[P];
          else if (P === f)
            h = g + g.charAt(0);
          else
            return null;
          b.push(h), c[f++] = g + h.charAt(0), p--, g = h, p == 0 && (p = Math.pow(2, m), m++);
        }
      }, "_decompress")
    };
    return s;
  }();
  typeof define == "function" && define.amd ? define(function() {
    return Vw;
  }) : typeof Ph < "u" && Ph != null ? Ph.exports = Vw : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
    return Vw;
  });
});
var vR = y$1((fU, gR) => {
  (function(e) {
    if (typeof fU == "object" && typeof gR < "u")
      gR.exports = e();
    else if (typeof define == "function" && define.amd)
      define([], e);
    else {
      var t;
      typeof window < "u" ? t = window : typeof global < "u" ? t = global : typeof self < "u" ? t = self : t = this, t.memoizerific = e();
    }
  })(function() {
    return (/* @__PURE__ */ o(function n(i, s, a) {
      function l(d, p) {
        if (!s[d]) {
          if (!i[d]) {
            var f = typeof wi == "function" && wi;
            if (!p && f) return f(d, true);
            if (u) return u(d, true);
            var m = new Error("Cannot find module '" + d + "'");
            throw m.code = "MODULE_NOT_FOUND", m;
          }
          var h = s[d] = { exports: {} };
          i[d][0].call(h.exports, function(b) {
            var v = i[d][1][b];
            return l(v || b);
          }, h, h.exports, n, i, s, a);
        }
        return s[d].exports;
      }
      o(l, "s");
      for (var u = typeof wi == "function" && wi, c = 0; c < a.length; c++) l(a[c]);
      return l;
    }, "e"))({ 1: [function(n, i, s) {
      i.exports = function(a) {
        if (typeof Map != "function" || a) {
          var l = n("./similar");
          return new l();
        } else
          return /* @__PURE__ */ new Map();
      };
    }, { "./similar": 2 }], 2: [function(n, i, s) {
      function a() {
        return this.list = [], this.lastItem = void 0, this.size = 0, this;
      }
      o(a, "Similar"), a.prototype.get = function(l) {
        var u;
        if (this.lastItem && this.isEqual(this.lastItem.key, l))
          return this.lastItem.val;
        if (u = this.indexOf(l), u >= 0)
          return this.lastItem = this.list[u], this.list[u].val;
      }, a.prototype.set = function(l, u) {
        var c;
        return this.lastItem && this.isEqual(this.lastItem.key, l) ? (this.lastItem.val = u, this) : (c = this.indexOf(l), c >= 0 ? (this.lastItem = this.list[c], this.list[c].val = u, this) : (this.lastItem = { key: l, val: u }, this.list.push(this.lastItem), this.size++, this));
      }, a.prototype.delete = function(l) {
        var u;
        if (this.lastItem && this.isEqual(this.lastItem.key, l) && (this.lastItem = void 0), u = this.indexOf(l), u >= 0)
          return this.size--, this.list.splice(u, 1)[0];
      }, a.prototype.has = function(l) {
        var u;
        return this.lastItem && this.isEqual(this.lastItem.key, l) ? true : (u = this.indexOf(l), u >= 0 ? (this.lastItem = this.list[u], true) : false);
      }, a.prototype.forEach = function(l, u) {
        var c;
        for (c = 0; c < this.size; c++)
          l.call(u || this, this.list[c].val, this.list[c].key, this);
      }, a.prototype.indexOf = function(l) {
        var u;
        for (u = 0; u < this.size; u++)
          if (this.isEqual(this.list[u].key, l))
            return u;
        return -1;
      }, a.prototype.isEqual = function(l, u) {
        return l === u || l !== l && u !== u;
      }, i.exports = a;
    }, {}], 3: [function(n, i, s) {
      var a = n("map-or-similar");
      i.exports = function(d) {
        var p = new a(false), f = [];
        return function(m) {
          var h = /* @__PURE__ */ o(function() {
            var b = p, v, g, w = arguments.length - 1, E = Array(w + 1), R = true, S;
            if ((h.numArgs || h.numArgs === 0) && h.numArgs !== w + 1)
              throw new Error("Memoizerific functions should always be called with the same number of arguments");
            for (S = 0; S < w; S++) {
              if (E[S] = {
                cacheItem: b,
                arg: arguments[S]
              }, b.has(arguments[S])) {
                b = b.get(arguments[S]);
                continue;
              }
              R = false, v = new a(false), b.set(arguments[S], v), b = v;
            }
            return R && (b.has(arguments[w]) ? g = b.get(arguments[w]) : R = false), R || (g = m.apply(null, arguments), b.set(arguments[w], g)), d > 0 && (E[w] = {
              cacheItem: b,
              arg: arguments[w]
            }, R ? l(f, E) : f.push(E), f.length > d && u(f.shift())), h.wasMemoized = R, h.numArgs = w + 1, g;
          }, "memoizerific");
          return h.limit = d, h.wasMemoized = false, h.cache = p, h.lru = f, h;
        };
      };
      function l(d, p) {
        var f = d.length, m = p.length, h, b, v;
        for (b = 0; b < f; b++) {
          for (h = true, v = 0; v < m; v++)
            if (!c(d[b][v].arg, p[v].arg)) {
              h = false;
              break;
            }
          if (h)
            break;
        }
        d.push(d.splice(b, 1)[0]);
      }
      o(l, "moveToMostRecentLru");
      function u(d) {
        var p = d.length, f = d[p - 1], m, h;
        for (f.cacheItem.delete(f.arg), h = p - 2; h >= 0 && (f = d[h], m = f.cacheItem.get(f.arg), !m || !m.size); h--)
          f.cacheItem.delete(f.arg);
      }
      o(u, "removeCachedResult");
      function c(d, p) {
        return d === p || d !== d && p !== p;
      }
      o(c, "isEqual");
    }, { "map-or-similar": 1 }] }, {}, [3])(3);
  });
});
var HR = y$1((BR) => {
  Object.defineProperty(BR, "__esModule", { value: true });
  BR.encodeString = axe;
  var lr = Array.from({ length: 256 }, (e, t) => "%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase()), sxe = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  function axe(e) {
    let t = e.length;
    if (t === 0)
      return "";
    let r = "", n = 0, i = 0;
    e: for (; i < t; i++) {
      let s = e.charCodeAt(i);
      for (; s < 128; ) {
        if (sxe[s] !== 1 && (n < i && (r += e.slice(n, i)), n = i + 1, r += lr[s]), ++i === t)
          break e;
        s = e.charCodeAt(i);
      }
      if (n < i && (r += e.slice(n, i)), s < 2048) {
        n = i + 1, r += lr[192 | s >> 6] + lr[128 | s & 63];
        continue;
      }
      if (s < 55296 || s >= 57344) {
        n = i + 1, r += lr[224 | s >> 12] + lr[128 | s >> 6 & 63] + lr[128 | s & 63];
        continue;
      }
      if (++i, i >= t)
        throw new Error("URI malformed");
      let a = e.charCodeAt(i) & 1023;
      n = i + 1, s = 65536 + ((s & 1023) << 10 | a), r += lr[240 | s >> 18] + lr[128 | s >> 12 & 63] + lr[128 | s >> 6 & 63] + lr[128 | s & 63];
    }
    return n === 0 ? e : n < t ? r + e.slice(n) : r;
  }
  o(axe, "encodeString");
});
var Cy = y$1((ur) => {
  Object.defineProperty(ur, "__esModule", { value: true });
  ur.defaultOptions = ur.defaultShouldSerializeObject = ur.defaultValueSerializer = void 0;
  var UR = HR(), lxe = /* @__PURE__ */ o((e) => {
    switch (typeof e) {
      case "string":
        return (0, UR.encodeString)(e);
      case "bigint":
      case "boolean":
        return "" + e;
      case "number":
        if (Number.isFinite(e))
          return e < 1e21 ? "" + e : (0, UR.encodeString)("" + e);
        break;
    }
    return e instanceof Date ? (0, UR.encodeString)(e.toISOString()) : "";
  }, "defaultValueSerializer");
  ur.defaultValueSerializer = lxe;
  var uxe = /* @__PURE__ */ o((e) => e instanceof Date, "defaultShouldSerializeObject");
  ur.defaultShouldSerializeObject = uxe;
  var FU = /* @__PURE__ */ o((e) => e, "identityFunc");
  ur.defaultOptions = {
    nesting: true,
    nestingSyntax: "dot",
    arrayRepeat: false,
    arrayRepeatSyntax: "repeat",
    delimiter: 38,
    valueDeserializer: FU,
    valueSerializer: ur.defaultValueSerializer,
    keyDeserializer: FU,
    shouldSerializeObject: ur.defaultShouldSerializeObject
  };
});
var VR = y$1((Py) => {
  Object.defineProperty(Py, "__esModule", { value: true });
  Py.getDeepObject = pxe;
  Py.stringifyObject = DU;
  var eo = Cy(), cxe = HR();
  function dxe(e) {
    return e === "__proto__" || e === "constructor" || e === "prototype";
  }
  o(dxe, "isPrototypeKey");
  function pxe(e, t, r, n, i) {
    if (dxe(t))
      return e;
    let s = e[t];
    return typeof s == "object" && s !== null ? s : !n && (i || typeof r == "number" || typeof r == "string" && r * 0 === 0 && r.indexOf(".") === -1) ? e[t] = [] : e[t] = {};
  }
  o(pxe, "getDeepObject");
  var fxe = 20, mxe = "[]", hxe = "[", yxe = "]", bxe = ".";
  function DU(e, t, r = 0, n, i) {
    let { nestingSyntax: s = eo.defaultOptions.nestingSyntax, arrayRepeat: a = eo.defaultOptions.arrayRepeat, arrayRepeatSyntax: l = eo.defaultOptions.arrayRepeatSyntax, nesting: u = eo.defaultOptions.nesting, delimiter: c = eo.defaultOptions.delimiter, valueSerializer: d = eo.defaultOptions.valueSerializer, shouldSerializeObject: p = eo.defaultOptions.shouldSerializeObject } = t, f = typeof c == "number" ? String.fromCharCode(
      c
    ) : c, m = i === true && a, h = s === "dot" || s === "js" && !i;
    if (r > fxe)
      return "";
    let b = "", v = true, g = false;
    for (let w in e) {
      let E = e[w], R;
      n ? (R = n, m ? l === "bracket" && (R += mxe) : h ? (R += bxe, R += w) : (R += hxe, R += w, R += yxe)) : R = w, v || (b += f), typeof E == "object" && E !== null && !p(E) ? (g = E.pop !== void 0, (u || a && g) && (b += DU(E, t, r + 1, R, g))) : (b += (0, cxe.encodeString)(
        R
      ), b += "=", b += d(E, w)), v && (v = false);
    }
    return b;
  }
  o(DU, "stringifyObject");
});
var UU = y$1((eYe, HU) => {
  var $U = 12, gxe = 0, zR = [
    // The first part of the table maps bytes to character to a transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    // The second part of the table maps a state to a new state when adding a
    // transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // The third part maps the current transition to a mask that needs to apply
    // to the byte.
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function vxe(e) {
    var t = e.indexOf("%");
    if (t === -1) return e;
    for (var r = e.length, n = "", i = 0, s = 0, a = t, l = $U; t > -1 && t < r; ) {
      var u = BU(e[t + 1], 4), c = BU(e[t + 2], 0), d = u | c, p = zR[d];
      if (l = zR[256 + l + p], s = s << 6 | d & zR[364 + p], l === $U)
        n += e.slice(i, a), n += s <= 65535 ? String.fromCharCode(s) : String.fromCharCode(
          55232 + (s >> 10),
          56320 + (s & 1023)
        ), s = 0, i = t + 3, t = a = e.indexOf("%", i);
      else {
        if (l === gxe)
          return null;
        if (t += 3, t < r && e.charCodeAt(t) === 37) continue;
        return null;
      }
    }
    return n + e.slice(i);
  }
  o(vxe, "decodeURIComponent");
  var Exe = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function BU(e, t) {
    var r = Exe[e];
    return r === void 0 ? 255 : r << t;
  }
  o(BU, "hexCodeToInt");
  HU.exports = vxe;
});
var WU = y$1((Pr) => {
  var xxe = Pr && Pr.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Pr, "__esModule", { value: true });
  Pr.numberValueDeserializer = Pr.numberKeyDeserializer = void 0;
  Pr.parse = Rxe;
  var Ay = VR(), to = Cy(), VU = xxe(UU()), wxe = /* @__PURE__ */ o((e) => {
    let t = Number(e);
    return Number.isNaN(t) ? e : t;
  }, "numberKeyDeserializer");
  Pr.numberKeyDeserializer = wxe;
  var Txe = /* @__PURE__ */ o((e) => {
    let t = Number(e);
    return Number.isNaN(t) ? e : t;
  }, "numberValueDeserializer");
  Pr.numberValueDeserializer = Txe;
  var zU = /\+/g, GU = /* @__PURE__ */ o(function() {
  }, "Empty");
  GU.prototype = /* @__PURE__ */ Object.create(null);
  function Oy(e, t, r, n, i) {
    let s = e.substring(t, r);
    return n && (s = s.replace(zU, " ")), i && (s = (0, VU.default)(s) || s), s;
  }
  o(Oy, "computeKeySlice");
  function Rxe(e, t) {
    let { valueDeserializer: r = to.defaultOptions.valueDeserializer, keyDeserializer: n = to.defaultOptions.keyDeserializer, arrayRepeatSyntax: i = to.defaultOptions.arrayRepeatSyntax, nesting: s = to.defaultOptions.nesting, arrayRepeat: a = to.defaultOptions.arrayRepeat, nestingSyntax: l = to.defaultOptions.nestingSyntax, delimiter: u = to.defaultOptions.delimiter } = t ?? {}, c = typeof u == "string" ? u.charCodeAt(0) : u, d = l === "js", p = new GU();
    if (typeof e != "string")
      return p;
    let f = e.length, m = "", h = -1, b = -1, v = -1, g = p, w, E = "", R = "", S = false, P = false, _ = false, C = false, O = false, L = false, q = false, D = 0, H = -1, M = -1, U = -1;
    for (let N = 0; N < f + 1; N++) {
      if (D = N !== f ? e.charCodeAt(N) : c, D === c) {
        if (q = b > h, q || (b = N), v !== b - 1 && (R = Oy(e, v + 1, H > -1 ? H : b, _, S), E = n(R), w !== void 0 && (g = (0, Ay.getDeepObject)(
          g,
          w,
          E,
          d && O,
          d && L
        ))), q || E !== "") {
          q && (m = e.slice(b + 1, N), C && (m = m.replace(zU, " ")), P && (m = (0, VU.default)(m) || m));
          let W = r(m, E);
          if (a) {
            let Y = g[E];
            Y === void 0 ? H > -1 ? g[E] = [W] : g[E] = W : Y.pop ? Y.push(W) : g[E] = [Y, W];
          } else
            g[E] = W;
        }
        m = "", h = N, b = N, S = false, P = false, _ = false, C = false, O = false, L = false, H = -1, v = N, g = p, w = void 0, E = "";
      } else D === 93 ? (a && i === "bracket" && U === 91 && (H = M), s && (l === "index" || d) && b <= h && (v !== M && (R = Oy(
        e,
        v + 1,
        N,
        _,
        S
      ), E = n(R), w !== void 0 && (g = (0, Ay.getDeepObject)(g, w, E, void 0, d)), w = E, _ = false, S = false), v = N, L = true, O = false)) : D === 46 ? s && (l === "dot" || d) && b <= h && (v !== M && (R = Oy(e, v + 1, N, _, S), E = n(R), w !== void 0 && (g = (0, Ay.getDeepObject)(
        g,
        w,
        E,
        d
      )), w = E, _ = false, S = false), O = true, L = false, v = N) : D === 91 ? s && (l === "index" || d) && b <= h && (v !== M && (R = Oy(
        e,
        v + 1,
        N,
        _,
        S
      ), E = n(R), d && w !== void 0 && (g = (0, Ay.getDeepObject)(g, w, E, d)), w = E, _ = false, S = false, O = false, L = true), v = N) : D === 61 ? b <= h ? b = N : P = true : D === 43 ? b > h ? C = true : _ = true : D === 37 && (b > h ? P = true : S = true);
      M = N, U = D;
    }
    return p;
  }
  o(Rxe, "parse");
});
var YU = y$1((GR) => {
  Object.defineProperty(GR, "__esModule", { value: true });
  GR.stringify = _xe;
  var Sxe = VR();
  function _xe(e, t) {
    if (e === null || typeof e != "object")
      return "";
    let r = t ?? {};
    return (0, Sxe.stringifyObject)(e, r);
  }
  o(_xe, "stringify");
});
var qy = y$1((Zt) => {
  var Cxe = Zt && Zt.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: /* @__PURE__ */ o(function() {
      return t[r];
    }, "get") }), Object.defineProperty(e, n, i);
  } : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
  }), Pxe = Zt && Zt.__exportStar || function(e, t) {
    for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && Cxe(t, e, r);
  };
  Object.defineProperty(Zt, "__esModule", { value: true });
  Zt.stringify = Zt.parse = void 0;
  var Axe = WU();
  Object.defineProperty(Zt, "parse", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return Axe.parse;
  }, "get") });
  var Oxe = YU();
  Object.defineProperty(Zt, "stringify", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return Oxe.stringify;
  }, "get") });
  Pxe(Cy(), Zt);
});
var XR = y$1((bYe, Lxe) => {
  Lxe.exports = {
    Aacute: "",
    aacute: "",
    Abreve: "",
    abreve: "",
    ac: "",
    acd: "",
    acE: "",
    Acirc: "",
    acirc: "",
    acute: "",
    Acy: "",
    acy: "",
    AElig: "",
    aelig: "",
    af: "",
    Afr: "",
    afr: "",
    Agrave: "",
    agrave: "",
    alefsym: "",
    aleph: "",
    Alpha: "",
    alpha: "",
    Amacr: "",
    amacr: "",
    amalg: "",
    amp: "&",
    AMP: "&",
    andand: "",
    And: "",
    and: "",
    andd: "",
    andslope: "",
    andv: "",
    ang: "",
    ange: "",
    angle: "",
    angmsdaa: "",
    angmsdab: "",
    angmsdac: "",
    angmsdad: "",
    angmsdae: "",
    angmsdaf: "",
    angmsdag: "",
    angmsdah: "",
    angmsd: "",
    angrt: "",
    angrtvb: "",
    angrtvbd: "",
    angsph: "",
    angst: "",
    angzarr: "",
    Aogon: "",
    aogon: "",
    Aopf: "",
    aopf: "",
    apacir: "",
    ap: "",
    apE: "",
    ape: "",
    apid: "",
    apos: "'",
    ApplyFunction: "",
    approx: "",
    approxeq: "",
    Aring: "",
    aring: "",
    Ascr: "",
    ascr: "",
    Assign: "",
    ast: "*",
    asymp: "",
    asympeq: "",
    Atilde: "",
    atilde: "",
    Auml: "",
    auml: "",
    awconint: "",
    awint: "",
    backcong: "",
    backepsilon: "",
    backprime: "",
    backsim: "",
    backsimeq: "",
    Backslash: "",
    Barv: "",
    barvee: "",
    barwed: "",
    Barwed: "",
    barwedge: "",
    bbrk: "",
    bbrktbrk: "",
    bcong: "",
    Bcy: "",
    bcy: "",
    bdquo: "",
    becaus: "",
    because: "",
    Because: "",
    bemptyv: "",
    bepsi: "",
    bernou: "",
    Bernoullis: "",
    Beta: "",
    beta: "",
    beth: "",
    between: "",
    Bfr: "",
    bfr: "",
    bigcap: "",
    bigcirc: "",
    bigcup: "",
    bigodot: "",
    bigoplus: "",
    bigotimes: "",
    bigsqcup: "",
    bigstar: "",
    bigtriangledown: "",
    bigtriangleup: "",
    biguplus: "",
    bigvee: "",
    bigwedge: "",
    bkarow: "",
    blacklozenge: "",
    blacksquare: "",
    blacktriangle: "",
    blacktriangledown: "",
    blacktriangleleft: "",
    blacktriangleright: "",
    blank: "",
    blk12: "",
    blk14: "",
    blk34: "",
    block: "",
    bne: "=",
    bnequiv: "",
    bNot: "",
    bnot: "",
    Bopf: "",
    bopf: "",
    bot: "",
    bottom: "",
    bowtie: "",
    boxbox: "",
    boxdl: "",
    boxdL: "",
    boxDl: "",
    boxDL: "",
    boxdr: "",
    boxdR: "",
    boxDr: "",
    boxDR: "",
    boxh: "",
    boxH: "",
    boxhd: "",
    boxHd: "",
    boxhD: "",
    boxHD: "",
    boxhu: "",
    boxHu: "",
    boxhU: "",
    boxHU: "",
    boxminus: "",
    boxplus: "",
    boxtimes: "",
    boxul: "",
    boxuL: "",
    boxUl: "",
    boxUL: "",
    boxur: "",
    boxuR: "",
    boxUr: "",
    boxUR: "",
    boxv: "",
    boxV: "",
    boxvh: "",
    boxvH: "",
    boxVh: "",
    boxVH: "",
    boxvl: "",
    boxvL: "",
    boxVl: "",
    boxVL: "",
    boxvr: "",
    boxvR: "",
    boxVr: "",
    boxVR: "",
    bprime: "",
    breve: "",
    Breve: "",
    brvbar: "",
    bscr: "",
    Bscr: "",
    bsemi: "",
    bsim: "",
    bsime: "",
    bsolb: "",
    bsol: "\\",
    bsolhsub: "",
    bull: "",
    bullet: "",
    bump: "",
    bumpE: "",
    bumpe: "",
    Bumpeq: "",
    bumpeq: "",
    Cacute: "",
    cacute: "",
    capand: "",
    capbrcup: "",
    capcap: "",
    cap: "",
    Cap: "",
    capcup: "",
    capdot: "",
    CapitalDifferentialD: "",
    caps: "",
    caret: "",
    caron: "",
    Cayleys: "",
    ccaps: "",
    Ccaron: "",
    ccaron: "",
    Ccedil: "",
    ccedil: "",
    Ccirc: "",
    ccirc: "",
    Cconint: "",
    ccups: "",
    ccupssm: "",
    Cdot: "",
    cdot: "",
    cedil: "",
    Cedilla: "",
    cemptyv: "",
    cent: "",
    centerdot: "",
    CenterDot: "",
    cfr: "",
    Cfr: "",
    CHcy: "",
    chcy: "",
    check: "",
    checkmark: "",
    Chi: "",
    chi: "",
    circ: "",
    circeq: "",
    circlearrowleft: "",
    circlearrowright: "",
    circledast: "",
    circledcirc: "",
    circleddash: "",
    CircleDot: "",
    circledR: "",
    circledS: "",
    CircleMinus: "",
    CirclePlus: "",
    CircleTimes: "",
    cir: "",
    cirE: "",
    cire: "",
    cirfnint: "",
    cirmid: "",
    cirscir: "",
    ClockwiseContourIntegral: "",
    CloseCurlyDoubleQuote: "",
    CloseCurlyQuote: "",
    clubs: "",
    clubsuit: "",
    colon: ":",
    Colon: "",
    Colone: "",
    colone: "",
    coloneq: "",
    comma: ",",
    commat: "@",
    comp: "",
    compfn: "",
    complement: "",
    complexes: "",
    cong: "",
    congdot: "",
    Congruent: "",
    conint: "",
    Conint: "",
    ContourIntegral: "",
    copf: "",
    Copf: "",
    coprod: "",
    Coproduct: "",
    copy: "",
    COPY: "",
    copysr: "",
    CounterClockwiseContourIntegral: "",
    crarr: "",
    cross: "",
    Cross: "",
    Cscr: "",
    cscr: "",
    csub: "",
    csube: "",
    csup: "",
    csupe: "",
    ctdot: "",
    cudarrl: "",
    cudarrr: "",
    cuepr: "",
    cuesc: "",
    cularr: "",
    cularrp: "",
    cupbrcap: "",
    cupcap: "",
    CupCap: "",
    cup: "",
    Cup: "",
    cupcup: "",
    cupdot: "",
    cupor: "",
    cups: "",
    curarr: "",
    curarrm: "",
    curlyeqprec: "",
    curlyeqsucc: "",
    curlyvee: "",
    curlywedge: "",
    curren: "",
    curvearrowleft: "",
    curvearrowright: "",
    cuvee: "",
    cuwed: "",
    cwconint: "",
    cwint: "",
    cylcty: "",
    dagger: "",
    Dagger: "",
    daleth: "",
    darr: "",
    Darr: "",
    dArr: "",
    dash: "",
    Dashv: "",
    dashv: "",
    dbkarow: "",
    dblac: "",
    Dcaron: "",
    dcaron: "",
    Dcy: "",
    dcy: "",
    ddagger: "",
    ddarr: "",
    DD: "",
    dd: "",
    DDotrahd: "",
    ddotseq: "",
    deg: "",
    Del: "",
    Delta: "",
    delta: "",
    demptyv: "",
    dfisht: "",
    Dfr: "",
    dfr: "",
    dHar: "",
    dharl: "",
    dharr: "",
    DiacriticalAcute: "",
    DiacriticalDot: "",
    DiacriticalDoubleAcute: "",
    DiacriticalGrave: "`",
    DiacriticalTilde: "",
    diam: "",
    diamond: "",
    Diamond: "",
    diamondsuit: "",
    diams: "",
    die: "",
    DifferentialD: "",
    digamma: "",
    disin: "",
    div: "",
    divide: "",
    divideontimes: "",
    divonx: "",
    DJcy: "",
    djcy: "",
    dlcorn: "",
    dlcrop: "",
    dollar: "$",
    Dopf: "",
    dopf: "",
    Dot: "",
    dot: "",
    DotDot: "",
    doteq: "",
    doteqdot: "",
    DotEqual: "",
    dotminus: "",
    dotplus: "",
    dotsquare: "",
    doublebarwedge: "",
    DoubleContourIntegral: "",
    DoubleDot: "",
    DoubleDownArrow: "",
    DoubleLeftArrow: "",
    DoubleLeftRightArrow: "",
    DoubleLeftTee: "",
    DoubleLongLeftArrow: "",
    DoubleLongLeftRightArrow: "",
    DoubleLongRightArrow: "",
    DoubleRightArrow: "",
    DoubleRightTee: "",
    DoubleUpArrow: "",
    DoubleUpDownArrow: "",
    DoubleVerticalBar: "",
    DownArrowBar: "",
    downarrow: "",
    DownArrow: "",
    Downarrow: "",
    DownArrowUpArrow: "",
    DownBreve: "",
    downdownarrows: "",
    downharpoonleft: "",
    downharpoonright: "",
    DownLeftRightVector: "",
    DownLeftTeeVector: "",
    DownLeftVectorBar: "",
    DownLeftVector: "",
    DownRightTeeVector: "",
    DownRightVectorBar: "",
    DownRightVector: "",
    DownTeeArrow: "",
    DownTee: "",
    drbkarow: "",
    drcorn: "",
    drcrop: "",
    Dscr: "",
    dscr: "",
    DScy: "",
    dscy: "",
    dsol: "",
    Dstrok: "",
    dstrok: "",
    dtdot: "",
    dtri: "",
    dtrif: "",
    duarr: "",
    duhar: "",
    dwangle: "",
    DZcy: "",
    dzcy: "",
    dzigrarr: "",
    Eacute: "",
    eacute: "",
    easter: "",
    Ecaron: "",
    ecaron: "",
    Ecirc: "",
    ecirc: "",
    ecir: "",
    ecolon: "",
    Ecy: "",
    ecy: "",
    eDDot: "",
    Edot: "",
    edot: "",
    eDot: "",
    ee: "",
    efDot: "",
    Efr: "",
    efr: "",
    eg: "",
    Egrave: "",
    egrave: "",
    egs: "",
    egsdot: "",
    el: "",
    Element: "",
    elinters: "",
    ell: "",
    els: "",
    elsdot: "",
    Emacr: "",
    emacr: "",
    empty: "",
    emptyset: "",
    EmptySmallSquare: "",
    emptyv: "",
    EmptyVerySmallSquare: "",
    emsp13: "",
    emsp14: "",
    emsp: "",
    ENG: "",
    eng: "",
    ensp: "",
    Eogon: "",
    eogon: "",
    Eopf: "",
    eopf: "",
    epar: "",
    eparsl: "",
    eplus: "",
    epsi: "",
    Epsilon: "",
    epsilon: "",
    epsiv: "",
    eqcirc: "",
    eqcolon: "",
    eqsim: "",
    eqslantgtr: "",
    eqslantless: "",
    Equal: "",
    equals: "=",
    EqualTilde: "",
    equest: "",
    Equilibrium: "",
    equiv: "",
    equivDD: "",
    eqvparsl: "",
    erarr: "",
    erDot: "",
    escr: "",
    Escr: "",
    esdot: "",
    Esim: "",
    esim: "",
    Eta: "",
    eta: "",
    ETH: "",
    eth: "",
    Euml: "",
    euml: "",
    euro: "",
    excl: "!",
    exist: "",
    Exists: "",
    expectation: "",
    exponentiale: "",
    ExponentialE: "",
    fallingdotseq: "",
    Fcy: "",
    fcy: "",
    female: "",
    ffilig: "",
    fflig: "",
    ffllig: "",
    Ffr: "",
    ffr: "",
    filig: "",
    FilledSmallSquare: "",
    FilledVerySmallSquare: "",
    fjlig: "fj",
    flat: "",
    fllig: "",
    fltns: "",
    fnof: "",
    Fopf: "",
    fopf: "",
    forall: "",
    ForAll: "",
    fork: "",
    forkv: "",
    Fouriertrf: "",
    fpartint: "",
    frac12: "",
    frac13: "",
    frac14: "",
    frac15: "",
    frac16: "",
    frac18: "",
    frac23: "",
    frac25: "",
    frac34: "",
    frac35: "",
    frac38: "",
    frac45: "",
    frac56: "",
    frac58: "",
    frac78: "",
    frasl: "",
    frown: "",
    fscr: "",
    Fscr: "",
    gacute: "",
    Gamma: "",
    gamma: "",
    Gammad: "",
    gammad: "",
    gap: "",
    Gbreve: "",
    gbreve: "",
    Gcedil: "",
    Gcirc: "",
    gcirc: "",
    Gcy: "",
    gcy: "",
    Gdot: "",
    gdot: "",
    ge: "",
    gE: "",
    gEl: "",
    gel: "",
    geq: "",
    geqq: "",
    geqslant: "",
    gescc: "",
    ges: "",
    gesdot: "",
    gesdoto: "",
    gesdotol: "",
    gesl: "",
    gesles: "",
    Gfr: "",
    gfr: "",
    gg: "",
    Gg: "",
    ggg: "",
    gimel: "",
    GJcy: "",
    gjcy: "",
    gla: "",
    gl: "",
    glE: "",
    glj: "",
    gnap: "",
    gnapprox: "",
    gne: "",
    gnE: "",
    gneq: "",
    gneqq: "",
    gnsim: "",
    Gopf: "",
    gopf: "",
    grave: "`",
    GreaterEqual: "",
    GreaterEqualLess: "",
    GreaterFullEqual: "",
    GreaterGreater: "",
    GreaterLess: "",
    GreaterSlantEqual: "",
    GreaterTilde: "",
    Gscr: "",
    gscr: "",
    gsim: "",
    gsime: "",
    gsiml: "",
    gtcc: "",
    gtcir: "",
    gt: ">",
    GT: ">",
    Gt: "",
    gtdot: "",
    gtlPar: "",
    gtquest: "",
    gtrapprox: "",
    gtrarr: "",
    gtrdot: "",
    gtreqless: "",
    gtreqqless: "",
    gtrless: "",
    gtrsim: "",
    gvertneqq: "",
    gvnE: "",
    Hacek: "",
    hairsp: "",
    half: "",
    hamilt: "",
    HARDcy: "",
    hardcy: "",
    harrcir: "",
    harr: "",
    hArr: "",
    harrw: "",
    Hat: "^",
    hbar: "",
    Hcirc: "",
    hcirc: "",
    hearts: "",
    heartsuit: "",
    hellip: "",
    hercon: "",
    hfr: "",
    Hfr: "",
    HilbertSpace: "",
    hksearow: "",
    hkswarow: "",
    hoarr: "",
    homtht: "",
    hookleftarrow: "",
    hookrightarrow: "",
    hopf: "",
    Hopf: "",
    horbar: "",
    HorizontalLine: "",
    hscr: "",
    Hscr: "",
    hslash: "",
    Hstrok: "",
    hstrok: "",
    HumpDownHump: "",
    HumpEqual: "",
    hybull: "",
    hyphen: "",
    Iacute: "",
    iacute: "",
    ic: "",
    Icirc: "",
    icirc: "",
    Icy: "",
    icy: "",
    Idot: "",
    IEcy: "",
    iecy: "",
    iexcl: "",
    iff: "",
    ifr: "",
    Ifr: "",
    Igrave: "",
    igrave: "",
    ii: "",
    iiiint: "",
    iiint: "",
    iinfin: "",
    iiota: "",
    IJlig: "",
    ijlig: "",
    Imacr: "",
    imacr: "",
    image: "",
    ImaginaryI: "",
    imagline: "",
    imagpart: "",
    imath: "",
    Im: "",
    imof: "",
    imped: "",
    Implies: "",
    incare: "",
    in: "",
    infin: "",
    infintie: "",
    inodot: "",
    intcal: "",
    int: "",
    Int: "",
    integers: "",
    Integral: "",
    intercal: "",
    Intersection: "",
    intlarhk: "",
    intprod: "",
    InvisibleComma: "",
    InvisibleTimes: "",
    IOcy: "",
    iocy: "",
    Iogon: "",
    iogon: "",
    Iopf: "",
    iopf: "",
    Iota: "",
    iota: "",
    iprod: "",
    iquest: "",
    iscr: "",
    Iscr: "",
    isin: "",
    isindot: "",
    isinE: "",
    isins: "",
    isinsv: "",
    isinv: "",
    it: "",
    Itilde: "",
    itilde: "",
    Iukcy: "",
    iukcy: "",
    Iuml: "",
    iuml: "",
    Jcirc: "",
    jcirc: "",
    Jcy: "",
    jcy: "",
    Jfr: "",
    jfr: "",
    jmath: "",
    Jopf: "",
    jopf: "",
    Jscr: "",
    jscr: "",
    Jsercy: "",
    jsercy: "",
    Jukcy: "",
    jukcy: "",
    Kappa: "",
    kappa: "",
    kappav: "",
    Kcedil: "",
    kcedil: "",
    Kcy: "",
    kcy: "",
    Kfr: "",
    kfr: "",
    kgreen: "",
    KHcy: "",
    khcy: "",
    KJcy: "",
    kjcy: "",
    Kopf: "",
    kopf: "",
    Kscr: "",
    kscr: "",
    lAarr: "",
    Lacute: "",
    lacute: "",
    laemptyv: "",
    lagran: "",
    Lambda: "",
    lambda: "",
    lang: "",
    Lang: "",
    langd: "",
    langle: "",
    lap: "",
    Laplacetrf: "",
    laquo: "",
    larrb: "",
    larrbfs: "",
    larr: "",
    Larr: "",
    lArr: "",
    larrfs: "",
    larrhk: "",
    larrlp: "",
    larrpl: "",
    larrsim: "",
    larrtl: "",
    latail: "",
    lAtail: "",
    lat: "",
    late: "",
    lates: "",
    lbarr: "",
    lBarr: "",
    lbbrk: "",
    lbrace: "{",
    lbrack: "[",
    lbrke: "",
    lbrksld: "",
    lbrkslu: "",
    Lcaron: "",
    lcaron: "",
    Lcedil: "",
    lcedil: "",
    lceil: "",
    lcub: "{",
    Lcy: "",
    lcy: "",
    ldca: "",
    ldquo: "",
    ldquor: "",
    ldrdhar: "",
    ldrushar: "",
    ldsh: "",
    le: "",
    lE: "",
    LeftAngleBracket: "",
    LeftArrowBar: "",
    leftarrow: "",
    LeftArrow: "",
    Leftarrow: "",
    LeftArrowRightArrow: "",
    leftarrowtail: "",
    LeftCeiling: "",
    LeftDoubleBracket: "",
    LeftDownTeeVector: "",
    LeftDownVectorBar: "",
    LeftDownVector: "",
    LeftFloor: "",
    leftharpoondown: "",
    leftharpoonup: "",
    leftleftarrows: "",
    leftrightarrow: "",
    LeftRightArrow: "",
    Leftrightarrow: "",
    leftrightarrows: "",
    leftrightharpoons: "",
    leftrightsquigarrow: "",
    LeftRightVector: "",
    LeftTeeArrow: "",
    LeftTee: "",
    LeftTeeVector: "",
    leftthreetimes: "",
    LeftTriangleBar: "",
    LeftTriangle: "",
    LeftTriangleEqual: "",
    LeftUpDownVector: "",
    LeftUpTeeVector: "",
    LeftUpVectorBar: "",
    LeftUpVector: "",
    LeftVectorBar: "",
    LeftVector: "",
    lEg: "",
    leg: "",
    leq: "",
    leqq: "",
    leqslant: "",
    lescc: "",
    les: "",
    lesdot: "",
    lesdoto: "",
    lesdotor: "",
    lesg: "",
    lesges: "",
    lessapprox: "",
    lessdot: "",
    lesseqgtr: "",
    lesseqqgtr: "",
    LessEqualGreater: "",
    LessFullEqual: "",
    LessGreater: "",
    lessgtr: "",
    LessLess: "",
    lesssim: "",
    LessSlantEqual: "",
    LessTilde: "",
    lfisht: "",
    lfloor: "",
    Lfr: "",
    lfr: "",
    lg: "",
    lgE: "",
    lHar: "",
    lhard: "",
    lharu: "",
    lharul: "",
    lhblk: "",
    LJcy: "",
    ljcy: "",
    llarr: "",
    ll: "",
    Ll: "",
    llcorner: "",
    Lleftarrow: "",
    llhard: "",
    lltri: "",
    Lmidot: "",
    lmidot: "",
    lmoustache: "",
    lmoust: "",
    lnap: "",
    lnapprox: "",
    lne: "",
    lnE: "",
    lneq: "",
    lneqq: "",
    lnsim: "",
    loang: "",
    loarr: "",
    lobrk: "",
    longleftarrow: "",
    LongLeftArrow: "",
    Longleftarrow: "",
    longleftrightarrow: "",
    LongLeftRightArrow: "",
    Longleftrightarrow: "",
    longmapsto: "",
    longrightarrow: "",
    LongRightArrow: "",
    Longrightarrow: "",
    looparrowleft: "",
    looparrowright: "",
    lopar: "",
    Lopf: "",
    lopf: "",
    loplus: "",
    lotimes: "",
    lowast: "",
    lowbar: "_",
    LowerLeftArrow: "",
    LowerRightArrow: "",
    loz: "",
    lozenge: "",
    lozf: "",
    lpar: "(",
    lparlt: "",
    lrarr: "",
    lrcorner: "",
    lrhar: "",
    lrhard: "",
    lrm: "",
    lrtri: "",
    lsaquo: "",
    lscr: "",
    Lscr: "",
    lsh: "",
    Lsh: "",
    lsim: "",
    lsime: "",
    lsimg: "",
    lsqb: "[",
    lsquo: "",
    lsquor: "",
    Lstrok: "",
    lstrok: "",
    ltcc: "",
    ltcir: "",
    lt: "<",
    LT: "<",
    Lt: "",
    ltdot: "",
    lthree: "",
    ltimes: "",
    ltlarr: "",
    ltquest: "",
    ltri: "",
    ltrie: "",
    ltrif: "",
    ltrPar: "",
    lurdshar: "",
    luruhar: "",
    lvertneqq: "",
    lvnE: "",
    macr: "",
    male: "",
    malt: "",
    maltese: "",
    Map: "",
    map: "",
    mapsto: "",
    mapstodown: "",
    mapstoleft: "",
    mapstoup: "",
    marker: "",
    mcomma: "",
    Mcy: "",
    mcy: "",
    mdash: "",
    mDDot: "",
    measuredangle: "",
    MediumSpace: "",
    Mellintrf: "",
    Mfr: "",
    mfr: "",
    mho: "",
    micro: "",
    midast: "*",
    midcir: "",
    mid: "",
    middot: "",
    minusb: "",
    minus: "",
    minusd: "",
    minusdu: "",
    MinusPlus: "",
    mlcp: "",
    mldr: "",
    mnplus: "",
    models: "",
    Mopf: "",
    mopf: "",
    mp: "",
    mscr: "",
    Mscr: "",
    mstpos: "",
    Mu: "",
    mu: "",
    multimap: "",
    mumap: "",
    nabla: "",
    Nacute: "",
    nacute: "",
    nang: "",
    nap: "",
    napE: "",
    napid: "",
    napos: "",
    napprox: "",
    natural: "",
    naturals: "",
    natur: "",
    nbsp: "",
    nbump: "",
    nbumpe: "",
    ncap: "",
    Ncaron: "",
    ncaron: "",
    Ncedil: "",
    ncedil: "",
    ncong: "",
    ncongdot: "",
    ncup: "",
    Ncy: "",
    ncy: "",
    ndash: "",
    nearhk: "",
    nearr: "",
    neArr: "",
    nearrow: "",
    ne: "",
    nedot: "",
    NegativeMediumSpace: "",
    NegativeThickSpace: "",
    NegativeThinSpace: "",
    NegativeVeryThinSpace: "",
    nequiv: "",
    nesear: "",
    nesim: "",
    NestedGreaterGreater: "",
    NestedLessLess: "",
    NewLine: `
`,
    nexist: "",
    nexists: "",
    Nfr: "",
    nfr: "",
    ngE: "",
    nge: "",
    ngeq: "",
    ngeqq: "",
    ngeqslant: "",
    nges: "",
    nGg: "",
    ngsim: "",
    nGt: "",
    ngt: "",
    ngtr: "",
    nGtv: "",
    nharr: "",
    nhArr: "",
    nhpar: "",
    ni: "",
    nis: "",
    nisd: "",
    niv: "",
    NJcy: "",
    njcy: "",
    nlarr: "",
    nlArr: "",
    nldr: "",
    nlE: "",
    nle: "",
    nleftarrow: "",
    nLeftarrow: "",
    nleftrightarrow: "",
    nLeftrightarrow: "",
    nleq: "",
    nleqq: "",
    nleqslant: "",
    nles: "",
    nless: "",
    nLl: "",
    nlsim: "",
    nLt: "",
    nlt: "",
    nltri: "",
    nltrie: "",
    nLtv: "",
    nmid: "",
    NoBreak: "",
    NonBreakingSpace: "",
    nopf: "",
    Nopf: "",
    Not: "",
    not: "",
    NotCongruent: "",
    NotCupCap: "",
    NotDoubleVerticalBar: "",
    NotElement: "",
    NotEqual: "",
    NotEqualTilde: "",
    NotExists: "",
    NotGreater: "",
    NotGreaterEqual: "",
    NotGreaterFullEqual: "",
    NotGreaterGreater: "",
    NotGreaterLess: "",
    NotGreaterSlantEqual: "",
    NotGreaterTilde: "",
    NotHumpDownHump: "",
    NotHumpEqual: "",
    notin: "",
    notindot: "",
    notinE: "",
    notinva: "",
    notinvb: "",
    notinvc: "",
    NotLeftTriangleBar: "",
    NotLeftTriangle: "",
    NotLeftTriangleEqual: "",
    NotLess: "",
    NotLessEqual: "",
    NotLessGreater: "",
    NotLessLess: "",
    NotLessSlantEqual: "",
    NotLessTilde: "",
    NotNestedGreaterGreater: "",
    NotNestedLessLess: "",
    notni: "",
    notniva: "",
    notnivb: "",
    notnivc: "",
    NotPrecedes: "",
    NotPrecedesEqual: "",
    NotPrecedesSlantEqual: "",
    NotReverseElement: "",
    NotRightTriangleBar: "",
    NotRightTriangle: "",
    NotRightTriangleEqual: "",
    NotSquareSubset: "",
    NotSquareSubsetEqual: "",
    NotSquareSuperset: "",
    NotSquareSupersetEqual: "",
    NotSubset: "",
    NotSubsetEqual: "",
    NotSucceeds: "",
    NotSucceedsEqual: "",
    NotSucceedsSlantEqual: "",
    NotSucceedsTilde: "",
    NotSuperset: "",
    NotSupersetEqual: "",
    NotTilde: "",
    NotTildeEqual: "",
    NotTildeFullEqual: "",
    NotTildeTilde: "",
    NotVerticalBar: "",
    nparallel: "",
    npar: "",
    nparsl: "",
    npart: "",
    npolint: "",
    npr: "",
    nprcue: "",
    nprec: "",
    npreceq: "",
    npre: "",
    nrarrc: "",
    nrarr: "",
    nrArr: "",
    nrarrw: "",
    nrightarrow: "",
    nRightarrow: "",
    nrtri: "",
    nrtrie: "",
    nsc: "",
    nsccue: "",
    nsce: "",
    Nscr: "",
    nscr: "",
    nshortmid: "",
    nshortparallel: "",
    nsim: "",
    nsime: "",
    nsimeq: "",
    nsmid: "",
    nspar: "",
    nsqsube: "",
    nsqsupe: "",
    nsub: "",
    nsubE: "",
    nsube: "",
    nsubset: "",
    nsubseteq: "",
    nsubseteqq: "",
    nsucc: "",
    nsucceq: "",
    nsup: "",
    nsupE: "",
    nsupe: "",
    nsupset: "",
    nsupseteq: "",
    nsupseteqq: "",
    ntgl: "",
    Ntilde: "",
    ntilde: "",
    ntlg: "",
    ntriangleleft: "",
    ntrianglelefteq: "",
    ntriangleright: "",
    ntrianglerighteq: "",
    Nu: "",
    nu: "",
    num: "#",
    numero: "",
    numsp: "",
    nvap: "",
    nvdash: "",
    nvDash: "",
    nVdash: "",
    nVDash: "",
    nvge: "",
    nvgt: ">",
    nvHarr: "",
    nvinfin: "",
    nvlArr: "",
    nvle: "",
    nvlt: "<",
    nvltrie: "",
    nvrArr: "",
    nvrtrie: "",
    nvsim: "",
    nwarhk: "",
    nwarr: "",
    nwArr: "",
    nwarrow: "",
    nwnear: "",
    Oacute: "",
    oacute: "",
    oast: "",
    Ocirc: "",
    ocirc: "",
    ocir: "",
    Ocy: "",
    ocy: "",
    odash: "",
    Odblac: "",
    odblac: "",
    odiv: "",
    odot: "",
    odsold: "",
    OElig: "",
    oelig: "",
    ofcir: "",
    Ofr: "",
    ofr: "",
    ogon: "",
    Ograve: "",
    ograve: "",
    ogt: "",
    ohbar: "",
    ohm: "",
    oint: "",
    olarr: "",
    olcir: "",
    olcross: "",
    oline: "",
    olt: "",
    Omacr: "",
    omacr: "",
    Omega: "",
    omega: "",
    Omicron: "",
    omicron: "",
    omid: "",
    ominus: "",
    Oopf: "",
    oopf: "",
    opar: "",
    OpenCurlyDoubleQuote: "",
    OpenCurlyQuote: "",
    operp: "",
    oplus: "",
    orarr: "",
    Or: "",
    or: "",
    ord: "",
    order: "",
    orderof: "",
    ordf: "",
    ordm: "",
    origof: "",
    oror: "",
    orslope: "",
    orv: "",
    oS: "",
    Oscr: "",
    oscr: "",
    Oslash: "",
    oslash: "",
    osol: "",
    Otilde: "",
    otilde: "",
    otimesas: "",
    Otimes: "",
    otimes: "",
    Ouml: "",
    ouml: "",
    ovbar: "",
    OverBar: "",
    OverBrace: "",
    OverBracket: "",
    OverParenthesis: "",
    para: "",
    parallel: "",
    par: "",
    parsim: "",
    parsl: "",
    part: "",
    PartialD: "",
    Pcy: "",
    pcy: "",
    percnt: "%",
    period: ".",
    permil: "",
    perp: "",
    pertenk: "",
    Pfr: "",
    pfr: "",
    Phi: "",
    phi: "",
    phiv: "",
    phmmat: "",
    phone: "",
    Pi: "",
    pi: "",
    pitchfork: "",
    piv: "",
    planck: "",
    planckh: "",
    plankv: "",
    plusacir: "",
    plusb: "",
    pluscir: "",
    plus: "+",
    plusdo: "",
    plusdu: "",
    pluse: "",
    PlusMinus: "",
    plusmn: "",
    plussim: "",
    plustwo: "",
    pm: "",
    Poincareplane: "",
    pointint: "",
    popf: "",
    Popf: "",
    pound: "",
    prap: "",
    Pr: "",
    pr: "",
    prcue: "",
    precapprox: "",
    prec: "",
    preccurlyeq: "",
    Precedes: "",
    PrecedesEqual: "",
    PrecedesSlantEqual: "",
    PrecedesTilde: "",
    preceq: "",
    precnapprox: "",
    precneqq: "",
    precnsim: "",
    pre: "",
    prE: "",
    precsim: "",
    prime: "",
    Prime: "",
    primes: "",
    prnap: "",
    prnE: "",
    prnsim: "",
    prod: "",
    Product: "",
    profalar: "",
    profline: "",
    profsurf: "",
    prop: "",
    Proportional: "",
    Proportion: "",
    propto: "",
    prsim: "",
    prurel: "",
    Pscr: "",
    pscr: "",
    Psi: "",
    psi: "",
    puncsp: "",
    Qfr: "",
    qfr: "",
    qint: "",
    qopf: "",
    Qopf: "",
    qprime: "",
    Qscr: "",
    qscr: "",
    quaternions: "",
    quatint: "",
    quest: "?",
    questeq: "",
    quot: '"',
    QUOT: '"',
    rAarr: "",
    race: "",
    Racute: "",
    racute: "",
    radic: "",
    raemptyv: "",
    rang: "",
    Rang: "",
    rangd: "",
    range: "",
    rangle: "",
    raquo: "",
    rarrap: "",
    rarrb: "",
    rarrbfs: "",
    rarrc: "",
    rarr: "",
    Rarr: "",
    rArr: "",
    rarrfs: "",
    rarrhk: "",
    rarrlp: "",
    rarrpl: "",
    rarrsim: "",
    Rarrtl: "",
    rarrtl: "",
    rarrw: "",
    ratail: "",
    rAtail: "",
    ratio: "",
    rationals: "",
    rbarr: "",
    rBarr: "",
    RBarr: "",
    rbbrk: "",
    rbrace: "}",
    rbrack: "]",
    rbrke: "",
    rbrksld: "",
    rbrkslu: "",
    Rcaron: "",
    rcaron: "",
    Rcedil: "",
    rcedil: "",
    rceil: "",
    rcub: "}",
    Rcy: "",
    rcy: "",
    rdca: "",
    rdldhar: "",
    rdquo: "",
    rdquor: "",
    rdsh: "",
    real: "",
    realine: "",
    realpart: "",
    reals: "",
    Re: "",
    rect: "",
    reg: "",
    REG: "",
    ReverseElement: "",
    ReverseEquilibrium: "",
    ReverseUpEquilibrium: "",
    rfisht: "",
    rfloor: "",
    rfr: "",
    Rfr: "",
    rHar: "",
    rhard: "",
    rharu: "",
    rharul: "",
    Rho: "",
    rho: "",
    rhov: "",
    RightAngleBracket: "",
    RightArrowBar: "",
    rightarrow: "",
    RightArrow: "",
    Rightarrow: "",
    RightArrowLeftArrow: "",
    rightarrowtail: "",
    RightCeiling: "",
    RightDoubleBracket: "",
    RightDownTeeVector: "",
    RightDownVectorBar: "",
    RightDownVector: "",
    RightFloor: "",
    rightharpoondown: "",
    rightharpoonup: "",
    rightleftarrows: "",
    rightleftharpoons: "",
    rightrightarrows: "",
    rightsquigarrow: "",
    RightTeeArrow: "",
    RightTee: "",
    RightTeeVector: "",
    rightthreetimes: "",
    RightTriangleBar: "",
    RightTriangle: "",
    RightTriangleEqual: "",
    RightUpDownVector: "",
    RightUpTeeVector: "",
    RightUpVectorBar: "",
    RightUpVector: "",
    RightVectorBar: "",
    RightVector: "",
    ring: "",
    risingdotseq: "",
    rlarr: "",
    rlhar: "",
    rlm: "",
    rmoustache: "",
    rmoust: "",
    rnmid: "",
    roang: "",
    roarr: "",
    robrk: "",
    ropar: "",
    ropf: "",
    Ropf: "",
    roplus: "",
    rotimes: "",
    RoundImplies: "",
    rpar: ")",
    rpargt: "",
    rppolint: "",
    rrarr: "",
    Rrightarrow: "",
    rsaquo: "",
    rscr: "",
    Rscr: "",
    rsh: "",
    Rsh: "",
    rsqb: "]",
    rsquo: "",
    rsquor: "",
    rthree: "",
    rtimes: "",
    rtri: "",
    rtrie: "",
    rtrif: "",
    rtriltri: "",
    RuleDelayed: "",
    ruluhar: "",
    rx: "",
    Sacute: "",
    sacute: "",
    sbquo: "",
    scap: "",
    Scaron: "",
    scaron: "",
    Sc: "",
    sc: "",
    sccue: "",
    sce: "",
    scE: "",
    Scedil: "",
    scedil: "",
    Scirc: "",
    scirc: "",
    scnap: "",
    scnE: "",
    scnsim: "",
    scpolint: "",
    scsim: "",
    Scy: "",
    scy: "",
    sdotb: "",
    sdot: "",
    sdote: "",
    searhk: "",
    searr: "",
    seArr: "",
    searrow: "",
    sect: "",
    semi: ";",
    seswar: "",
    setminus: "",
    setmn: "",
    sext: "",
    Sfr: "",
    sfr: "",
    sfrown: "",
    sharp: "",
    SHCHcy: "",
    shchcy: "",
    SHcy: "",
    shcy: "",
    ShortDownArrow: "",
    ShortLeftArrow: "",
    shortmid: "",
    shortparallel: "",
    ShortRightArrow: "",
    ShortUpArrow: "",
    shy: "",
    Sigma: "",
    sigma: "",
    sigmaf: "",
    sigmav: "",
    sim: "",
    simdot: "",
    sime: "",
    simeq: "",
    simg: "",
    simgE: "",
    siml: "",
    simlE: "",
    simne: "",
    simplus: "",
    simrarr: "",
    slarr: "",
    SmallCircle: "",
    smallsetminus: "",
    smashp: "",
    smeparsl: "",
    smid: "",
    smile: "",
    smt: "",
    smte: "",
    smtes: "",
    SOFTcy: "",
    softcy: "",
    solbar: "",
    solb: "",
    sol: "/",
    Sopf: "",
    sopf: "",
    spades: "",
    spadesuit: "",
    spar: "",
    sqcap: "",
    sqcaps: "",
    sqcup: "",
    sqcups: "",
    Sqrt: "",
    sqsub: "",
    sqsube: "",
    sqsubset: "",
    sqsubseteq: "",
    sqsup: "",
    sqsupe: "",
    sqsupset: "",
    sqsupseteq: "",
    square: "",
    Square: "",
    SquareIntersection: "",
    SquareSubset: "",
    SquareSubsetEqual: "",
    SquareSuperset: "",
    SquareSupersetEqual: "",
    SquareUnion: "",
    squarf: "",
    squ: "",
    squf: "",
    srarr: "",
    Sscr: "",
    sscr: "",
    ssetmn: "",
    ssmile: "",
    sstarf: "",
    Star: "",
    star: "",
    starf: "",
    straightepsilon: "",
    straightphi: "",
    strns: "",
    sub: "",
    Sub: "",
    subdot: "",
    subE: "",
    sube: "",
    subedot: "",
    submult: "",
    subnE: "",
    subne: "",
    subplus: "",
    subrarr: "",
    subset: "",
    Subset: "",
    subseteq: "",
    subseteqq: "",
    SubsetEqual: "",
    subsetneq: "",
    subsetneqq: "",
    subsim: "",
    subsub: "",
    subsup: "",
    succapprox: "",
    succ: "",
    succcurlyeq: "",
    Succeeds: "",
    SucceedsEqual: "",
    SucceedsSlantEqual: "",
    SucceedsTilde: "",
    succeq: "",
    succnapprox: "",
    succneqq: "",
    succnsim: "",
    succsim: "",
    SuchThat: "",
    sum: "",
    Sum: "",
    sung: "",
    sup1: "",
    sup2: "",
    sup3: "",
    sup: "",
    Sup: "",
    supdot: "",
    supdsub: "",
    supE: "",
    supe: "",
    supedot: "",
    Superset: "",
    SupersetEqual: "",
    suphsol: "",
    suphsub: "",
    suplarr: "",
    supmult: "",
    supnE: "",
    supne: "",
    supplus: "",
    supset: "",
    Supset: "",
    supseteq: "",
    supseteqq: "",
    supsetneq: "",
    supsetneqq: "",
    supsim: "",
    supsub: "",
    supsup: "",
    swarhk: "",
    swarr: "",
    swArr: "",
    swarrow: "",
    swnwar: "",
    szlig: "",
    Tab: "	",
    target: "",
    Tau: "",
    tau: "",
    tbrk: "",
    Tcaron: "",
    tcaron: "",
    Tcedil: "",
    tcedil: "",
    Tcy: "",
    tcy: "",
    tdot: "",
    telrec: "",
    Tfr: "",
    tfr: "",
    there4: "",
    therefore: "",
    Therefore: "",
    Theta: "",
    theta: "",
    thetasym: "",
    thetav: "",
    thickapprox: "",
    thicksim: "",
    ThickSpace: "",
    ThinSpace: "",
    thinsp: "",
    thkap: "",
    thksim: "",
    THORN: "",
    thorn: "",
    tilde: "",
    Tilde: "",
    TildeEqual: "",
    TildeFullEqual: "",
    TildeTilde: "",
    timesbar: "",
    timesb: "",
    times: "",
    timesd: "",
    tint: "",
    toea: "",
    topbot: "",
    topcir: "",
    top: "",
    Topf: "",
    topf: "",
    topfork: "",
    tosa: "",
    tprime: "",
    trade: "",
    TRADE: "",
    triangle: "",
    triangledown: "",
    triangleleft: "",
    trianglelefteq: "",
    triangleq: "",
    triangleright: "",
    trianglerighteq: "",
    tridot: "",
    trie: "",
    triminus: "",
    TripleDot: "",
    triplus: "",
    trisb: "",
    tritime: "",
    trpezium: "",
    Tscr: "",
    tscr: "",
    TScy: "",
    tscy: "",
    TSHcy: "",
    tshcy: "",
    Tstrok: "",
    tstrok: "",
    twixt: "",
    twoheadleftarrow: "",
    twoheadrightarrow: "",
    Uacute: "",
    uacute: "",
    uarr: "",
    Uarr: "",
    uArr: "",
    Uarrocir: "",
    Ubrcy: "",
    ubrcy: "",
    Ubreve: "",
    ubreve: "",
    Ucirc: "",
    ucirc: "",
    Ucy: "",
    ucy: "",
    udarr: "",
    Udblac: "",
    udblac: "",
    udhar: "",
    ufisht: "",
    Ufr: "",
    ufr: "",
    Ugrave: "",
    ugrave: "",
    uHar: "",
    uharl: "",
    uharr: "",
    uhblk: "",
    ulcorn: "",
    ulcorner: "",
    ulcrop: "",
    ultri: "",
    Umacr: "",
    umacr: "",
    uml: "",
    UnderBar: "_",
    UnderBrace: "",
    UnderBracket: "",
    UnderParenthesis: "",
    Union: "",
    UnionPlus: "",
    Uogon: "",
    uogon: "",
    Uopf: "",
    uopf: "",
    UpArrowBar: "",
    uparrow: "",
    UpArrow: "",
    Uparrow: "",
    UpArrowDownArrow: "",
    updownarrow: "",
    UpDownArrow: "",
    Updownarrow: "",
    UpEquilibrium: "",
    upharpoonleft: "",
    upharpoonright: "",
    uplus: "",
    UpperLeftArrow: "",
    UpperRightArrow: "",
    upsi: "",
    Upsi: "",
    upsih: "",
    Upsilon: "",
    upsilon: "",
    UpTeeArrow: "",
    UpTee: "",
    upuparrows: "",
    urcorn: "",
    urcorner: "",
    urcrop: "",
    Uring: "",
    uring: "",
    urtri: "",
    Uscr: "",
    uscr: "",
    utdot: "",
    Utilde: "",
    utilde: "",
    utri: "",
    utrif: "",
    uuarr: "",
    Uuml: "",
    uuml: "",
    uwangle: "",
    vangrt: "",
    varepsilon: "",
    varkappa: "",
    varnothing: "",
    varphi: "",
    varpi: "",
    varpropto: "",
    varr: "",
    vArr: "",
    varrho: "",
    varsigma: "",
    varsubsetneq: "",
    varsubsetneqq: "",
    varsupsetneq: "",
    varsupsetneqq: "",
    vartheta: "",
    vartriangleleft: "",
    vartriangleright: "",
    vBar: "",
    Vbar: "",
    vBarv: "",
    Vcy: "",
    vcy: "",
    vdash: "",
    vDash: "",
    Vdash: "",
    VDash: "",
    Vdashl: "",
    veebar: "",
    vee: "",
    Vee: "",
    veeeq: "",
    vellip: "",
    verbar: "|",
    Verbar: "",
    vert: "|",
    Vert: "",
    VerticalBar: "",
    VerticalLine: "|",
    VerticalSeparator: "",
    VerticalTilde: "",
    VeryThinSpace: "",
    Vfr: "",
    vfr: "",
    vltri: "",
    vnsub: "",
    vnsup: "",
    Vopf: "",
    vopf: "",
    vprop: "",
    vrtri: "",
    Vscr: "",
    vscr: "",
    vsubnE: "",
    vsubne: "",
    vsupnE: "",
    vsupne: "",
    Vvdash: "",
    vzigzag: "",
    Wcirc: "",
    wcirc: "",
    wedbar: "",
    wedge: "",
    Wedge: "",
    wedgeq: "",
    weierp: "",
    Wfr: "",
    wfr: "",
    Wopf: "",
    wopf: "",
    wp: "",
    wr: "",
    wreath: "",
    Wscr: "",
    wscr: "",
    xcap: "",
    xcirc: "",
    xcup: "",
    xdtri: "",
    Xfr: "",
    xfr: "",
    xharr: "",
    xhArr: "",
    Xi: "",
    xi: "",
    xlarr: "",
    xlArr: "",
    xmap: "",
    xnis: "",
    xodot: "",
    Xopf: "",
    xopf: "",
    xoplus: "",
    xotime: "",
    xrarr: "",
    xrArr: "",
    Xscr: "",
    xscr: "",
    xsqcup: "",
    xuplus: "",
    xutri: "",
    xvee: "",
    xwedge: "",
    Yacute: "",
    yacute: "",
    YAcy: "",
    yacy: "",
    Ycirc: "",
    ycirc: "",
    Ycy: "",
    ycy: "",
    yen: "",
    Yfr: "",
    yfr: "",
    YIcy: "",
    yicy: "",
    Yopf: "",
    yopf: "",
    Yscr: "",
    yscr: "",
    YUcy: "",
    yucy: "",
    yuml: "",
    Yuml: "",
    Zacute: "",
    zacute: "",
    Zcaron: "",
    zcaron: "",
    Zcy: "",
    zcy: "",
    Zdot: "",
    zdot: "",
    zeetrf: "",
    ZeroWidthSpace: "",
    Zeta: "",
    zeta: "",
    zfr: "",
    Zfr: "",
    ZHcy: "",
    zhcy: "",
    zigrarr: "",
    zopf: "",
    Zopf: "",
    Zscr: "",
    zscr: "",
    zwj: "",
    zwnj: ""
  };
});
var t5 = y$1((gYe, Fxe) => {
  Fxe.exports = {
    Aacute: "",
    aacute: "",
    Acirc: "",
    acirc: "",
    acute: "",
    AElig: "",
    aelig: "",
    Agrave: "",
    agrave: "",
    amp: "&",
    AMP: "&",
    Aring: "",
    aring: "",
    Atilde: "",
    atilde: "",
    Auml: "",
    auml: "",
    brvbar: "",
    Ccedil: "",
    ccedil: "",
    cedil: "",
    cent: "",
    copy: "",
    COPY: "",
    curren: "",
    deg: "",
    divide: "",
    Eacute: "",
    eacute: "",
    Ecirc: "",
    ecirc: "",
    Egrave: "",
    egrave: "",
    ETH: "",
    eth: "",
    Euml: "",
    euml: "",
    frac12: "",
    frac14: "",
    frac34: "",
    gt: ">",
    GT: ">",
    Iacute: "",
    iacute: "",
    Icirc: "",
    icirc: "",
    iexcl: "",
    Igrave: "",
    igrave: "",
    iquest: "",
    Iuml: "",
    iuml: "",
    laquo: "",
    lt: "<",
    LT: "<",
    macr: "",
    micro: "",
    middot: "",
    nbsp: "",
    not: "",
    Ntilde: "",
    ntilde: "",
    Oacute: "",
    oacute: "",
    Ocirc: "",
    ocirc: "",
    Ograve: "",
    ograve: "",
    ordf: "",
    ordm: "",
    Oslash: "",
    oslash: "",
    Otilde: "",
    otilde: "",
    Ouml: "",
    ouml: "",
    para: "",
    plusmn: "",
    pound: "",
    quot: '"',
    QUOT: '"',
    raquo: "",
    reg: "",
    REG: "",
    sect: "",
    shy: "",
    sup1: "",
    sup2: "",
    sup3: "",
    szlig: "",
    THORN: "",
    thorn: "",
    times: "",
    Uacute: "",
    uacute: "",
    Ucirc: "",
    ucirc: "",
    Ugrave: "",
    ugrave: "",
    uml: "",
    Uuml: "",
    uuml: "",
    Yacute: "",
    yacute: "",
    yen: "",
    yuml: ""
  };
});
var JR = y$1((vYe, Dxe) => {
  Dxe.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
});
var r5 = y$1((EYe, $xe) => {
  $xe.exports = {
    "0": 65533,
    "128": 8364,
    "130": 8218,
    "131": 402,
    "132": 8222,
    "133": 8230,
    "134": 8224,
    "135": 8225,
    "136": 710,
    "137": 8240,
    "138": 352,
    "139": 8249,
    "140": 338,
    "142": 381,
    "145": 8216,
    "146": 8217,
    "147": 8220,
    "148": 8221,
    "149": 8226,
    "150": 8211,
    "151": 8212,
    "152": 732,
    "153": 8482,
    "154": 353,
    "155": 8250,
    "156": 339,
    "158": 382,
    "159": 376
  };
});
var o5 = y$1((Oa) => {
  var Bxe = Oa && Oa.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Oa, "__esModule", { value: true });
  var n5 = Bxe(r5()), Hxe = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.fromCodePoint || function(e) {
      var t = "";
      return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
    }
  );
  function Uxe(e) {
    return e >= 55296 && e <= 57343 || e > 1114111 ? "" : (e in n5.default && (e = n5.default[e]), Hxe(e));
  }
  o(Uxe, "decodeCodePoint");
  Oa.default = Uxe;
});
var ZR = y$1((cr) => {
  var Iy = cr && cr.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(cr, "__esModule", { value: true });
  cr.decodeHTML = cr.decodeHTMLStrict = cr.decodeXML = void 0;
  var QR = Iy(XR()), Vxe = Iy(t5()), zxe = Iy(JR()), i5 = Iy(o5()), Gxe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  cr.decodeXML = a5(zxe.default);
  cr.decodeHTMLStrict = a5(QR.default);
  function a5(e) {
    var t = l5(e);
    return function(r) {
      return String(r).replace(Gxe, t);
    };
  }
  o(a5, "getStrictDecoder");
  var s5 = /* @__PURE__ */ o(function(e, t) {
    return e < t ? 1 : -1;
  }, "sorter");
  cr.decodeHTML = function() {
    for (var e = Object.keys(Vxe.default).sort(s5), t = Object.keys(QR.default).sort(s5), r = 0, n = 0; r < t.length; r++)
      e[n] === t[r] ? (t[r] += ";?", n++) : t[r] += ";";
    var i = new RegExp("&(?:" + t.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), s = l5(QR.default);
    function a(l) {
      return l.substr(-1) !== ";" && (l += ";"), s(l);
    }
    return o(a, "replacer"), function(l) {
      return String(l).replace(i, a);
    };
  }();
  function l5(e) {
    return /* @__PURE__ */ o(function(r) {
      if (r.charAt(1) === "#") {
        var n = r.charAt(2);
        return n === "X" || n === "x" ? i5.default(parseInt(r.substr(3), 16)) : i5.default(parseInt(r.substr(2), 10));
      }
      return e[r.slice(1, -1)] || r;
    }, "replace");
  }
  o(l5, "getReplacer");
});
var tS = y$1((yt) => {
  var u5 = yt && yt.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(yt, "__esModule", { value: true });
  yt.escapeUTF8 = yt.escape = yt.encodeNonAsciiHTML = yt.encodeHTML = yt.encodeXML = void 0;
  var Wxe = u5(JR()), c5 = p5(Wxe.default), d5 = f5(c5);
  yt.encodeXML = y5(c5);
  var Yxe = u5(XR()), eS = p5(Yxe.default), Kxe = f5(eS);
  yt.encodeHTML = Jxe(eS, Kxe);
  yt.encodeNonAsciiHTML = y5(eS);
  function p5(e) {
    return Object.keys(e).sort().reduce(function(t, r) {
      return t[e[r]] = "&" + r + ";", t;
    }, {});
  }
  o(p5, "getInverseObj");
  function f5(e) {
    for (var t = [], r = [], n = 0, i = Object.keys(e); n < i.length; n++) {
      var s = i[n];
      s.length === 1 ? t.push("\\" + s) : r.push(s);
    }
    t.sort();
    for (var a = 0; a < t.length - 1; a++) {
      for (var l = a; l < t.length - 1 && t[l].charCodeAt(1) + 1 === t[l + 1].charCodeAt(1); )
        l += 1;
      var u = 1 + l - a;
      u < 3 || t.splice(a, u, t[a] + "-" + t[l]);
    }
    return r.unshift("[" + t.join("") + "]"), new RegExp(r.join("|"), "g");
  }
  o(f5, "getInverseReplacer");
  var m5 = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, Xxe = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      function(e) {
        return e.codePointAt(0);
      }
    ) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(e) {
        return (e.charCodeAt(0) - 55296) * 1024 + e.charCodeAt(1) - 56320 + 65536;
      }
    )
  );
  function My(e) {
    return "&#x" + (e.length > 1 ? Xxe(e) : e.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  o(My, "singleCharReplacer");
  function Jxe(e, t) {
    return function(r) {
      return r.replace(t, function(n) {
        return e[n];
      }).replace(m5, My);
    };
  }
  o(Jxe, "getInverse");
  var h5 = new RegExp(d5.source + "|" + m5.source, "g");
  function Qxe(e) {
    return e.replace(h5, My);
  }
  o(Qxe, "escape");
  yt.escape = Qxe;
  function Zxe(e) {
    return e.replace(d5, My);
  }
  o(Zxe, "escapeUTF8");
  yt.escapeUTF8 = Zxe;
  function y5(e) {
    return function(t) {
      return t.replace(h5, function(r) {
        return e[r] || My(r);
      });
    };
  }
  o(y5, "getASCIIEncoder");
});
var g5 = y$1((oe) => {
  Object.defineProperty(oe, "__esModule", { value: true });
  oe.decodeXMLStrict = oe.decodeHTML5Strict = oe.decodeHTML4Strict = oe.decodeHTML5 = oe.decodeHTML4 = oe.decodeHTMLStrict = oe.decodeHTML = oe.decodeXML = oe.encodeHTML5 = oe.encodeHTML4 = oe.escapeUTF8 = oe.escape = oe.encodeNonAsciiHTML = oe.encodeHTML = oe.encodeXML = oe.encode = oe.decodeStrict = oe.decode = void 0;
  var Ny = ZR(), b5 = tS();
  function ewe(e, t) {
    return (!t || t <= 0 ? Ny.decodeXML : Ny.decodeHTML)(e);
  }
  o(ewe, "decode");
  oe.decode = ewe;
  function twe(e, t) {
    return (!t || t <= 0 ? Ny.decodeXML : Ny.decodeHTMLStrict)(e);
  }
  o(twe, "decodeStrict");
  oe.decodeStrict = twe;
  function rwe(e, t) {
    return (!t || t <= 0 ? b5.encodeXML : b5.encodeHTML)(e);
  }
  o(rwe, "encode");
  oe.encode = rwe;
  var no = tS();
  Object.defineProperty(oe, "encodeXML", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return no.encodeXML;
  }, "get") });
  Object.defineProperty(oe, "encodeHTML", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return no.encodeHTML;
  }, "get") });
  Object.defineProperty(oe, "encodeNonAsciiHTML", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return no.encodeNonAsciiHTML;
  }, "get") });
  Object.defineProperty(oe, "escape", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return no.escape;
  }, "get") });
  Object.defineProperty(oe, "escapeUTF8", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return no.escapeUTF8;
  }, "get") });
  Object.defineProperty(oe, "encodeHTML4", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return no.encodeHTML;
  }, "get") });
  Object.defineProperty(oe, "encodeHTML5", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return no.encodeHTML;
  }, "get") });
  var hn = ZR();
  Object.defineProperty(oe, "decodeXML", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return hn.decodeXML;
  }, "get") });
  Object.defineProperty(oe, "decodeHTML", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return hn.decodeHTML;
  }, "get") });
  Object.defineProperty(oe, "decodeHTMLStrict", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return hn.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(oe, "decodeHTML4", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return hn.decodeHTML;
  }, "get") });
  Object.defineProperty(oe, "decodeHTML5", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return hn.decodeHTML;
  }, "get") });
  Object.defineProperty(oe, "decodeHTML4Strict", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return hn.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(oe, "decodeHTML5Strict", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return hn.decodeHTMLStrict;
  }, "get") });
  Object.defineProperty(oe, "decodeXMLStrict", { enumerable: true, get: /* @__PURE__ */ o(function() {
    return hn.decodeXML;
  }, "get") });
});
var A5 = y$1((AYe, P5) => {
  function nwe(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  o(nwe, "_classCallCheck");
  function v5(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
    }
  }
  o(v5, "_defineProperties");
  function owe(e, t, r) {
    return t && v5(e.prototype, t), r && v5(e, r), e;
  }
  o(owe, "_createClass");
  function S5(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = iwe(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var n = 0, i = /* @__PURE__ */ o(function() {
        }, "F");
        return { s: i, n: /* @__PURE__ */ o(function() {
          return n >= e.length ? { done: true } : { done: false, value: e[n++] };
        }, "n"), e: /* @__PURE__ */ o(function(c) {
          throw c;
        }, "e"), f: i };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var s = true, a = false, l;
    return { s: /* @__PURE__ */ o(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ o(function() {
      var c = r.next();
      return s = c.done, c;
    }, "n"), e: /* @__PURE__ */ o(function(c) {
      a = true, l = c;
    }, "e"), f: /* @__PURE__ */ o(function() {
      try {
        !s && r.return != null && r.return();
      } finally {
        if (a) throw l;
      }
    }, "f") };
  }
  o(S5, "_createForOfIteratorHelper");
  function iwe(e, t) {
    if (e) {
      if (typeof e == "string") return E5(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return E5(e, t);
    }
  }
  o(iwe, "_unsupportedIterableToArray");
  function E5(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++)
      n[r] = e[r];
    return n;
  }
  o(E5, "_arrayLikeToArray");
  var swe = g5(), x5 = {
    fg: "#FFF",
    bg: "#000",
    newline: false,
    escapeXML: false,
    stream: false,
    colors: awe()
  };
  function awe() {
    var e = {
      0: "#000",
      1: "#A00",
      2: "#0A0",
      3: "#A50",
      4: "#00A",
      5: "#A0A",
      6: "#0AA",
      7: "#AAA",
      8: "#555",
      9: "#F55",
      10: "#5F5",
      11: "#FF5",
      12: "#55F",
      13: "#F5F",
      14: "#5FF",
      15: "#FFF"
    };
    return jy(0, 5).forEach(function(t) {
      jy(0, 5).forEach(function(r) {
        jy(0, 5).forEach(function(n) {
          return lwe(t, r, n, e);
        });
      });
    }), jy(0, 23).forEach(function(t) {
      var r = t + 232, n = _5(t * 10 + 8);
      e[r] = "#" + n + n + n;
    }), e;
  }
  o(awe, "getDefaultColors");
  function lwe(e, t, r, n) {
    var i = 16 + e * 36 + t * 6 + r, s = e > 0 ? e * 40 + 55 : 0, a = t > 0 ? t * 40 + 55 : 0, l = r > 0 ? r * 40 + 55 : 0;
    n[i] = uwe([s, a, l]);
  }
  o(lwe, "setStyleColor");
  function _5(e) {
    for (var t = e.toString(16); t.length < 2; )
      t = "0" + t;
    return t;
  }
  o(_5, "toHexString");
  function uwe(e) {
    var t = [], r = S5(e), n;
    try {
      for (r.s(); !(n = r.n()).done; ) {
        var i = n.value;
        t.push(_5(i));
      }
    } catch (s) {
      r.e(s);
    } finally {
      r.f();
    }
    return "#" + t.join("");
  }
  o(uwe, "toColorHexString");
  function w5(e, t, r, n) {
    var i;
    return t === "text" ? i = fwe(r, n) : t === "display" ? i = dwe(e, r, n) : t === "xterm256Foreground" ? i = Ly(e, n.colors[r]) : t === "xterm256Background" ? i = Fy(e, n.colors[r]) : t === "rgb" && (i = cwe(e, r)), i;
  }
  o(w5, "generateOutput");
  function cwe(e, t) {
    t = t.substring(2).slice(0, -1);
    var r = +t.substr(0, 2), n = t.substring(5).split(";"), i = n.map(function(s) {
      return ("0" + Number(s).toString(16)).substr(-2);
    }).join("");
    return ky(e, (r === 38 ? "color:#" : "background-color:#") + i);
  }
  o(cwe, "handleRgb");
  function dwe(e, t, r) {
    t = parseInt(t, 10);
    var n = {
      "-1": /* @__PURE__ */ o(function() {
        return "<br/>";
      }, "_"),
      0: /* @__PURE__ */ o(function() {
        return e.length && C5(e);
      }, "_"),
      1: /* @__PURE__ */ o(function() {
        return yn(e, "b");
      }, "_"),
      3: /* @__PURE__ */ o(function() {
        return yn(e, "i");
      }, "_"),
      4: /* @__PURE__ */ o(function() {
        return yn(e, "u");
      }, "_"),
      8: /* @__PURE__ */ o(function() {
        return ky(e, "display:none");
      }, "_"),
      9: /* @__PURE__ */ o(function() {
        return yn(e, "strike");
      }, "_"),
      22: /* @__PURE__ */ o(function() {
        return ky(e, "font-weight:normal;text-decoration:none;font-style:normal");
      }, "_"),
      23: /* @__PURE__ */ o(function() {
        return R5(e, "i");
      }, "_"),
      24: /* @__PURE__ */ o(function() {
        return R5(e, "u");
      }, "_"),
      39: /* @__PURE__ */ o(function() {
        return Ly(e, r.fg);
      }, "_"),
      49: /* @__PURE__ */ o(function() {
        return Fy(e, r.bg);
      }, "_"),
      53: /* @__PURE__ */ o(function() {
        return ky(e, "text-decoration:overline");
      }, "_")
    }, i;
    return n[t] ? i = n[t]() : 4 < t && t < 7 ? i = yn(e, "blink") : 29 < t && t < 38 ? i = Ly(e, r.colors[t - 30]) : 39 < t && t < 48 ? i = Fy(e, r.colors[t - 40]) : 89 < t && t < 98 ? i = Ly(e, r.colors[8 + (t - 90)]) : 99 < t && t < 108 && (i = Fy(e, r.colors[8 + (t - 100)])), i;
  }
  o(dwe, "handleDisplay");
  function C5(e) {
    var t = e.slice(0);
    return e.length = 0, t.reverse().map(function(r) {
      return "</" + r + ">";
    }).join("");
  }
  o(C5, "resetStyles");
  function jy(e, t) {
    for (var r = [], n = e; n <= t; n++)
      r.push(n);
    return r;
  }
  o(jy, "range");
  function pwe(e) {
    return function(t) {
      return (e === null || t.category !== e) && e !== "all";
    };
  }
  o(pwe, "notCategory");
  function T5(e) {
    e = parseInt(e, 10);
    var t = null;
    return e === 0 ? t = "all" : e === 1 ? t = "bold" : 2 < e && e < 5 ? t = "underline" : 4 < e && e < 7 ? t = "blink" : e === 8 ? t = "hide" : e === 9 ? t = "strike" : 29 < e && e < 38 || e === 39 || 89 < e && e < 98 ? t = "foreground-color" : (39 < e && e < 48 || e === 49 || 99 < e && e < 108) && (t = "background-color"), t;
  }
  o(T5, "categoryForCode");
  function fwe(e, t) {
    return t.escapeXML ? swe.encodeXML(e) : e;
  }
  o(fwe, "pushText");
  function yn(e, t, r) {
    return r || (r = ""), e.push(t), "<".concat(t).concat(r ? ' style="'.concat(r, '"') : "", ">");
  }
  o(yn, "pushTag");
  function ky(e, t) {
    return yn(e, "span", t);
  }
  o(ky, "pushStyle");
  function Ly(e, t) {
    return yn(e, "span", "color:" + t);
  }
  o(Ly, "pushForegroundColor");
  function Fy(e, t) {
    return yn(e, "span", "background-color:" + t);
  }
  o(Fy, "pushBackgroundColor");
  function R5(e, t) {
    var r;
    if (e.slice(-1)[0] === t && (r = e.pop()), r)
      return "</" + t + ">";
  }
  o(R5, "closeTag");
  function mwe(e, t, r) {
    var n = false, i = 3;
    function s() {
      return "";
    }
    o(s, "remove");
    function a(S, P) {
      return r("xterm256Foreground", P), "";
    }
    o(a, "removeXterm256Foreground");
    function l(S, P) {
      return r("xterm256Background", P), "";
    }
    o(l, "removeXterm256Background");
    function u(S) {
      return t.newline ? r("display", -1) : r("text", S), "";
    }
    o(u, "newline");
    function c(S, P) {
      n = true, P.trim().length === 0 && (P = "0"), P = P.trimRight(";").split(";");
      var _ = S5(P), C;
      try {
        for (_.s(); !(C = _.n()).done; ) {
          var O = C.value;
          r("display", O);
        }
      } catch (L) {
        _.e(L);
      } finally {
        _.f();
      }
      return "";
    }
    o(c, "ansiMess");
    function d(S) {
      return r("text", S), "";
    }
    o(d, "realText");
    function p(S) {
      return r("rgb", S), "";
    }
    o(p, "rgb");
    var f = [{
      pattern: /^\x08+/,
      sub: s
    }, {
      pattern: /^\x1b\[[012]?K/,
      sub: s
    }, {
      pattern: /^\x1b\[\(B/,
      sub: s
    }, {
      pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
      sub: p
    }, {
      pattern: /^\x1b\[38;5;(\d+)m/,
      sub: a
    }, {
      pattern: /^\x1b\[48;5;(\d+)m/,
      sub: l
    }, {
      pattern: /^\n/,
      sub: u
    }, {
      pattern: /^\r+\n/,
      sub: u
    }, {
      pattern: /^\r/,
      sub: u
    }, {
      pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
      sub: c
    }, {
      // CSI n J
      // ED - Erase in Display Clears part of the screen.
      // If n is 0 (or missing), clear from cursor to end of screen.
      // If n is 1, clear from cursor to beginning of the screen.
      // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
      // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
      //   (this feature was added for xterm and is supported by other terminal applications).
      pattern: /^\x1b\[\d?J/,
      sub: s
    }, {
      // CSI n ; m f
      // HVP - Horizontal Vertical Position Same as CUP
      pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
      sub: s
    }, {
      // catch-all for CSI sequences?
      pattern: /^\x1b\[?[\d;]{0,3}/,
      sub: s
    }, {
      /**
       * extracts real text - not containing:
       * - `\x1b' - ESC - escape (Ascii 27)
       * - '\x08' - BS - backspace (Ascii 8)
       * - `\n` - Newline - linefeed (LF) (ascii 10)
       * - `\r` - Windows Carriage Return (CR)
       */
      pattern: /^(([^\x1b\x08\r\n])+)/,
      sub: d
    }];
    function m(S, P) {
      P > i && n || (n = false, e = e.replace(S.pattern, S.sub));
    }
    o(m, "process");
    var h = [], b = e, v = b.length;
    e: for (; v > 0; ) {
      for (var g = 0, w = 0, E = f.length; w < E; g = ++w) {
        var R = f[g];
        if (m(R, g), e.length !== v) {
          v = e.length;
          continue e;
        }
      }
      if (e.length === v)
        break;
      h.push(0), v = e.length;
    }
    return h;
  }
  o(mwe, "tokenize");
  function hwe(e, t, r) {
    return t !== "text" && (e = e.filter(pwe(T5(r))), e.push({
      token: t,
      data: r,
      category: T5(r)
    })), e;
  }
  o(hwe, "updateStickyStack");
  var ywe = /* @__PURE__ */ function() {
    function e(t) {
      nwe(this, e), t = t || {}, t.colors && (t.colors = Object.assign({}, x5.colors, t.colors)), this.options = Object.assign({}, x5, t), this.stack = [], this.stickyStack = [];
    }
    return o(e, "Filter"), owe(e, [{
      key: "toHtml",
      value: /* @__PURE__ */ o(function(r) {
        var n = this;
        r = typeof r == "string" ? [r] : r;
        var i = this.stack, s = this.options, a = [];
        return this.stickyStack.forEach(function(l) {
          var u = w5(i, l.token, l.data, s);
          u && a.push(u);
        }), mwe(r.join(""), s, function(l, u) {
          var c = w5(i, l, u, s);
          c && a.push(c), s.stream && (n.stickyStack = hwe(n.stickyStack, l, u));
        }), i.length && a.push(C5(i)), a.join("");
      }, "toHtml")
    }]), e;
  }();
  P5.exports = ywe;
});
var H5 = y$1((uS, cS) => {
  (function(e, t) {
    typeof uS == "object" && typeof cS < "u" ? cS.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis < "u" ? globalThis : e || self).BrowserDetector = t();
  })(uS, function() {
    function e(a, l) {
      for (var u = 0; u < l.length; u++) {
        var c = l[u];
        c.enumerable = c.enumerable || false, c.configurable = true, "value" in c && (c.writable = true), Object.defineProperty(a, (d = c.key, p = void 0, typeof (p = function(f, m) {
          if (typeof f != "object" || f === null) return f;
          var h = f[Symbol.toPrimitive];
          if (h !== void 0) {
            var b = h.call(f, m || "default");
            if (typeof b != "object") return b;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (m === "string" ? String : Number)(f);
        }(d, "string")) == "symbol" ? p : String(p)), c);
      }
      var d, p;
    }
    o(e, "e");
    var t = { chrome: "Google Chrome", brave: "Brave", crios: "Google Chrome", edge: "Microsoft Edge", edg: "Microsoft Edge", edgios: "Microsoft Edge", fennec: "Mozilla Firefox", jsdom: "JsDOM", mozilla: "Mozilla Firefox", fxios: "Mozilla Firefox", msie: "Microsoft Internet Explorer", opera: "Opera", opios: "Opera", opr: "Opera", opt: "Opera", rv: "Microsoft Internet Explorer", safari: "Safari", samsungbrowser: "Samsung Browser", electron: "Electron" }, r = {
      android: "Android",
      androidTablet: "Android Tablet",
      cros: "Chrome OS",
      fennec: "Android Tablet",
      ipad: "IPad",
      iphone: "IPhone",
      jsdom: "JsDOM",
      linux: "Linux",
      mac: "Macintosh",
      tablet: "Android Tablet",
      win: "Windows",
      "windows phone": "Windows Phone",
      xbox: "Microsoft Xbox"
    }, n = /* @__PURE__ */ o(function(a) {
      var l = new RegExp("^-?\\d+(?:.\\d{0,".concat(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, "})?")), u = Number(
        a
      ).toString().match(l);
      return u ? u[0] : null;
    }, "n"), i = /* @__PURE__ */ o(function() {
      return typeof window < "u" ? window.navigator : null;
    }, "i"), s = function() {
      function a(d) {
        var p;
        ((function(f, m) {
          if (!(f instanceof m)) throw new TypeError("Cannot call a class as a function");
        }))(this, a), this.userAgent = d || ((p = i()) === null || p === void 0 ? void 0 : p.userAgent) || null;
      }
      o(a, "t");
      var l, u, c;
      return l = a, u = [{ key: "parseUserAgent", value: /* @__PURE__ */ o(function(d) {
        var p, f, m, h = {}, b = d || this.userAgent || "", v = b.toLowerCase().replace(/\s\s+/g, " "), g = /(edge)\/([\w.]+)/.exec(v) || /(edg)[/]([\w.]+)/.exec(v) || /(opr)[/]([\w.]+)/.exec(v) || /(opt)[/]([\w.]+)/.exec(v) || /(fxios)[/]([\w.]+)/.exec(v) || /(edgios)[/]([\w.]+)/.exec(v) || /(jsdom)[/]([\w.]+)/.exec(v) || /(samsungbrowser)[/]([\w.]+)/.exec(v) || /(electron)[/]([\w.]+)/.exec(v) || /(chrome)[/]([\w.]+)/.exec(
          v
        ) || /(crios)[/]([\w.]+)/.exec(v) || /(opios)[/]([\w.]+)/.exec(v) || /(version)(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(
          v
        ) || /(webkit)[/]([\w.]+).*(version)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(v) || /(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(
          v
        ) || /(webkit)[/]([\w.]+)/.exec(v) || /(opera)(?:.*version|)[/]([\w.]+)/.exec(v) || /(msie) ([\w.]+)/.exec(v) || /(fennec)[/]([\w.]+)/.exec(v) || v.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(v) || v.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(v) || [], w = /(ipad)/.exec(v) || /(ipod)/.exec(v) || /(iphone)/.exec(v) || /(jsdom)/.exec(v) || /(windows phone)/.exec(v) || /(xbox)/.exec(v) || /(win)/.exec(v) || /(tablet)/.exec(v) || /(android)/.test(v) && /(mobile)/.test(v) === false && ["androidTablet"] || /(android)/.exec(v) || /(mac)/.exec(v) || /(linux)/.exec(v) || /(cros)/.exec(v) || [], E = g[5] || g[3] || g[1] || null, R = w[0] || null, S = g[4] || g[2] || null, P = i();
        E === "chrome" && typeof (P == null || (p = P.brave) === null || p === void 0 ? void 0 : p.isBrave) == "function" && (E = "brave"), E && (h[E] = true), R && (h[R] = true);
        var _ = !!(h.tablet || h.android || h.androidTablet), C = !!(h.ipad || h.tablet || h.androidTablet), O = !!(h.android || h.androidTablet || h.tablet || h.ipad || h.ipod || h.iphone || h["windows phone"]), L = !!(h.cros || h.mac || h.linux || h.win), q = !!(h.brave || h.chrome || h.crios || h.opr || h.safari || h.edg || h.electron), D = !!(h.msie || h.rv);
        return {
          name: (f = t[E]) !== null && f !== void 0 ? f : null,
          platform: (m = r[R]) !== null && m !== void 0 ? m : null,
          userAgent: b,
          version: S,
          shortVersion: S ? n(parseFloat(S), 2) : null,
          isAndroid: _,
          isTablet: C,
          isMobile: O,
          isDesktop: L,
          isWebkit: q,
          isIE: D
        };
      }, "value") }, { key: "getBrowserInfo", value: /* @__PURE__ */ o(function() {
        var d = this.parseUserAgent();
        return { name: d.name, platform: d.platform, userAgent: d.userAgent, version: d.version, shortVersion: d.shortVersion };
      }, "value") }], c = [{ key: "VERSION", get: /* @__PURE__ */ o(function() {
        return "3.4.0";
      }, "get") }], u && e(l.prototype, u), c && e(l, c), Object.defineProperty(l, "prototype", { writable: false }), a;
    }();
    return s;
  });
});
var co = {};
st$1(co, {
  ARGTYPES_INFO_REQUEST: () => ab,
  ARGTYPES_INFO_RESPONSE: () => $a,
  CHANNEL_CREATED: () => Z5,
  CHANNEL_WS_DISCONNECT: () => Hy,
  CONFIG_ERROR: () => Uy,
  CREATE_NEW_STORYFILE_REQUEST: () => e3,
  CREATE_NEW_STORYFILE_RESPONSE: () => t3,
  CURRENT_STORY_WAS_SET: () => La,
  DOCS_PREPARED: () => Vy,
  DOCS_RENDERED: () => Ti,
  FILE_COMPONENT_SEARCH_REQUEST: () => r3,
  FILE_COMPONENT_SEARCH_RESPONSE: () => n3,
  FORCE_REMOUNT: () => lo,
  FORCE_RE_RENDER: () => Ri,
  GLOBALS_UPDATED: () => bn,
  NAVIGATE_URL: () => o3,
  PLAY_FUNCTION_THREW_EXCEPTION: () => zy,
  PRELOAD_ENTRIES: () => Wy,
  PREVIEW_BUILDER_PROGRESS: () => i3,
  PREVIEW_KEYDOWN: () => Yy,
  REGISTER_SUBSCRIPTION: () => s3,
  REQUEST_WHATS_NEW_DATA: () => y3,
  RESET_STORY_ARGS: () => Si,
  RESULT_WHATS_NEW_DATA: () => b3,
  SAVE_STORY_REQUEST: () => E3,
  SAVE_STORY_RESPONSE: () => x3,
  SELECT_STORY: () => a3,
  SET_CONFIG: () => l3,
  SET_CURRENT_STORY: () => _i,
  SET_FILTER: () => u3,
  SET_GLOBALS: () => Ky,
  SET_INDEX: () => c3,
  SET_STORIES: () => d3,
  SET_WHATS_NEW_CACHE: () => g3,
  SHARED_STATE_CHANGED: () => p3,
  SHARED_STATE_SET: () => f3,
  STORIES_COLLAPSE_ALL: () => m3,
  STORIES_EXPAND_ALL: () => h3,
  STORY_ARGS_UPDATED: () => Xy,
  STORY_CHANGED: () => Jy,
  STORY_ERRORED: () => Qy,
  STORY_FINISHED: () => Da,
  STORY_HOT_UPDATED: () => ob,
  STORY_INDEX_INVALIDATED: () => Zy,
  STORY_MISSING: () => Fa,
  STORY_PREPARED: () => eb,
  STORY_RENDERED: () => uo,
  STORY_RENDER_PHASE_CHANGED: () => jt,
  STORY_SPECIFIED: () => tb,
  STORY_THREW_EXCEPTION: () => rb,
  STORY_UNCHANGED: () => nb,
  TELEMETRY_ERROR: () => sb,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: () => v3,
  UNHANDLED_ERRORS_WHILE_PLAYING: () => Gy,
  UPDATE_GLOBALS: () => Ci,
  UPDATE_QUERY_PARAMS: () => ib,
  UPDATE_STORY_ARGS: () => Pi,
  default: () => Q5
});
var By = /* @__PURE__ */ ((V) => (V.CHANNEL_WS_DISCONNECT = "channelWSDisconnect", V.CHANNEL_CREATED = "channelCreated", V.CONFIG_ERROR = "configError", V.STORY_INDEX_INVALIDATED = "storyIndexInvalidated", V.STORY_SPECIFIED = "storySpecified", V.SET_CONFIG = "setConfig", V.SET_STORIES = "setStories", V.SET_INDEX = "setIndex", V.SET_CURRENT_STORY = "setCurrentStory", V.CURRENT_STORY_WAS_SET = "currentStoryWasSet", V.FORCE_RE_RENDER = "forceReRender", V.FORCE_REMOUNT = "forceRemount", V.PRELOAD_ENTRIES = "preloadStories", V.STORY_PREPARED = "storyPrepared", V.DOCS_PREPARED = "docsPrepared", V.STORY_CHANGED = "storyChanged", V.STORY_UNCHANGED = "storyUnchanged", V.STORY_RENDERED = "storyRendered", V.STORY_FINISHED = "storyFinished", V.STORY_MISSING = "storyMissing", V.STORY_ERRORED = "storyErrored", V.STORY_THREW_EXCEPTION = "storyThrewException", V.STORY_RENDER_PHASE_CHANGED = "storyRenderPhaseChanged", V.STORY_HOT_UPDATED = "storyHotUpdated", V.PLAY_FUNCTION_THREW_EXCEPTION = "playFunctionThrewException", V.UNHANDLED_ERRORS_WHILE_PLAYING = "unhandledErrorsWhilePlaying", V.UPDATE_STORY_ARGS = "updateStoryArgs", V.STORY_ARGS_UPDATED = "storyArgsUpdated", V.RESET_STORY_ARGS = "resetStoryArgs", V.SET_FILTER = "setFilter", V.SET_GLOBALS = "setGlobals", V.UPDATE_GLOBALS = "updateGlobals", V.GLOBALS_UPDATED = "globalsUpdated", V.REGISTER_SUBSCRIPTION = "registerSubscription", V.PREVIEW_KEYDOWN = "previewKeydown", V.PREVIEW_BUILDER_PROGRESS = "preview_builder_progress", V.SELECT_STORY = "selectStory", V.STORIES_COLLAPSE_ALL = "storiesCollapseAll", V.STORIES_EXPAND_ALL = "storiesExpandAll", V.DOCS_RENDERED = "docsRendered", V.SHARED_STATE_CHANGED = "sharedStateChanged", V.SHARED_STATE_SET = "sharedStateSet", V.NAVIGATE_URL = "navigateUrl", V.UPDATE_QUERY_PARAMS = "updateQueryParams", V.REQUEST_WHATS_NEW_DATA = "requestWhatsNewData", V.RESULT_WHATS_NEW_DATA = "resultWhatsNewData", V.SET_WHATS_NEW_CACHE = "setWhatsNewCache", V.TOGGLE_WHATS_NEW_NOTIFICATIONS = "toggleWhatsNewNotifications", V.TELEMETRY_ERROR = "telemetryError", V.FILE_COMPONENT_SEARCH_REQUEST = "fileComponentSearchRequest", V.FILE_COMPONENT_SEARCH_RESPONSE = "fileComponentSearchResponse", V.SAVE_STORY_REQUEST = "saveStoryRequest", V.SAVE_STORY_RESPONSE = "saveStoryResponse", V.ARGTYPES_INFO_REQUEST = "argtypesInfoRequest", V.ARGTYPES_INFO_RESPONSE = "argtypesInfoResponse", V.CREATE_NEW_STORYFILE_REQUEST = "createNewStoryfileRequest", V.CREATE_NEW_STORYFILE_RESPONSE = "createNewStoryfileResponse", V))(By || {}), Q5 = By, {
  CHANNEL_WS_DISCONNECT: Hy,
  CHANNEL_CREATED: Z5,
  CONFIG_ERROR: Uy,
  CREATE_NEW_STORYFILE_REQUEST: e3,
  CREATE_NEW_STORYFILE_RESPONSE: t3,
  CURRENT_STORY_WAS_SET: La,
  DOCS_PREPARED: Vy,
  DOCS_RENDERED: Ti,
  FILE_COMPONENT_SEARCH_REQUEST: r3,
  FILE_COMPONENT_SEARCH_RESPONSE: n3,
  FORCE_RE_RENDER: Ri,
  FORCE_REMOUNT: lo,
  GLOBALS_UPDATED: bn,
  NAVIGATE_URL: o3,
  PLAY_FUNCTION_THREW_EXCEPTION: zy,
  UNHANDLED_ERRORS_WHILE_PLAYING: Gy,
  PRELOAD_ENTRIES: Wy,
  PREVIEW_BUILDER_PROGRESS: i3,
  PREVIEW_KEYDOWN: Yy,
  REGISTER_SUBSCRIPTION: s3,
  RESET_STORY_ARGS: Si,
  SELECT_STORY: a3,
  SET_CONFIG: l3,
  SET_CURRENT_STORY: _i,
  SET_FILTER: u3,
  SET_GLOBALS: Ky,
  SET_INDEX: c3,
  SET_STORIES: d3,
  SHARED_STATE_CHANGED: p3,
  SHARED_STATE_SET: f3,
  STORIES_COLLAPSE_ALL: m3,
  STORIES_EXPAND_ALL: h3,
  STORY_ARGS_UPDATED: Xy,
  STORY_CHANGED: Jy,
  STORY_ERRORED: Qy,
  STORY_INDEX_INVALIDATED: Zy,
  STORY_MISSING: Fa,
  STORY_PREPARED: eb,
  STORY_RENDER_PHASE_CHANGED: jt,
  STORY_RENDERED: uo,
  STORY_FINISHED: Da,
  STORY_SPECIFIED: tb,
  STORY_THREW_EXCEPTION: rb,
  STORY_UNCHANGED: nb,
  STORY_HOT_UPDATED: ob,
  UPDATE_GLOBALS: Ci,
  UPDATE_QUERY_PARAMS: ib,
  UPDATE_STORY_ARGS: Pi,
  REQUEST_WHATS_NEW_DATA: y3,
  RESULT_WHATS_NEW_DATA: b3,
  SET_WHATS_NEW_CACHE: g3,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: v3,
  TELEMETRY_ERROR: sb,
  SAVE_STORY_REQUEST: E3,
  SAVE_STORY_RESPONSE: x3,
  ARGTYPES_INFO_REQUEST: ab,
  ARGTYPES_INFO_RESPONSE: $a
} = By;
var lb = {};
st$1(lb, {
  global: () => k
});
var k = (() => {
  let e;
  return typeof window < "u" ? e = window : typeof globalThis < "u" ? e = globalThis : typeof global < "u" ? e = global : typeof self < "u" ? e = self : e = {}, e;
})();
var ub = {
  "@storybook/global": "__STORYBOOK_MODULE_GLOBAL__",
  "storybook/test": "__STORYBOOK_MODULE_TEST__",
  "storybook/actions": "__STORYBOOK_MODULE_ACTIONS__",
  "storybook/preview-api": "__STORYBOOK_MODULE_PREVIEW_API__",
  "storybook/internal/channels": "__STORYBOOK_MODULE_CHANNELS__",
  "storybook/internal/client-logger": "__STORYBOOK_MODULE_CLIENT_LOGGER__",
  "storybook/internal/core-events": "__STORYBOOK_MODULE_CORE_EVENTS__",
  "storybook/internal/preview-errors": "__STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__",
  "storybook/internal/types": "__STORYBOOK_MODULE_TYPES__",
  // @deprecated TODO: Remove in 9.1
  "storybook/internal/preview-api": "__STORYBOOK_MODULE_PREVIEW_API__"
}, fS = Object.keys(ub);
var qb = {};
st$1(qb, {
  Channel: () => Ar$1,
  HEARTBEAT_INTERVAL: () => Pb,
  HEARTBEAT_MAX_LATENCY: () => Ab,
  PostMessageTransport: () => go,
  WebsocketTransport: () => vo,
  createBrowserChannel: () => NG,
  default: () => MG
});
function Q$1(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  var n = Array.from(typeof e == "string" ? [e] : e);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var i = n.reduce(function(l, u) {
    var c = u.match(/\n([\t ]+|(?!\s).)/g);
    return c ? l.concat(c.map(function(d) {
      var p, f;
      return (f = (p = d.match(/[\t ]/g)) === null || p === void 0 ? void 0 : p.length) !== null && f !== void 0 ? f : 0;
    })) : l;
  }, []);
  if (i.length) {
    var s = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}", "g");
    n = n.map(function(l) {
      return l.replace(s, `
`);
    });
  }
  n[0] = n[0].replace(/^\r?\n/, "");
  var a = n[0];
  return t.forEach(function(l, u) {
    var c = a.match(/(?:^|\n)( *)$/), d = c ? c[1] : "", p = l;
    typeof l == "string" && l.includes(`
`) && (p = String(l).split(`
`).map(function(f, m) {
      return m === 0 ? f : "" + d + f;
    }).join(`
`)), a += p + n[u + 1];
  }), a;
}
o(Q$1, "dedent");
var mS = Q$1;
var cb = /* @__PURE__ */ new Map();
var w3 = "UNIVERSAL_STORE:", Rt = {
  PENDING: "PENDING",
  RESOLVED: "RESOLVED",
  REJECTED: "REJECTED"
}, J$1 = class J2 {
  constructor(t, r) {
    this.debugging = false;
    this.listeners = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set()]]);
    this.getState = /* @__PURE__ */ o(() => (this.debug("getState", { state: this.state }), this.state), "getState");
    this.subscribe = /* @__PURE__ */ o((t7, r7) => {
      let n = typeof t7 == "function", i = n ? "*" : t7, s = n ? t7 : r7;
      if (this.debug("subscribe", { eventType: i, listener: s }), !s)
        throw new TypeError(
          `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`
        );
      return this.listeners.has(i) || this.listeners.set(i, /* @__PURE__ */ new Set()), this.listeners.get(i).add(s), () => {
        this.debug("unsubscribe", { eventType: i, listener: s }), this.listeners.has(i) && (this.listeners.get(i).delete(s), this.listeners.get(i)?.size === 0 && this.listeners.delete(i));
      };
    }, "subscribe");
    this.send = /* @__PURE__ */ o((t7) => {
      if (this.debug("send", { event: t7 }), this.status !== J2.Status.READY)
        throw new TypeError(
          Q$1`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
            {
              event: t7,
              id: this.id,
              actor: this.actor,
              environment: this.environment
            },
            null,
            2
          )}`
        );
      this.emitToListeners(t7, { actor: this.actor }), this.emitToChannel(t7, { actor: this.actor });
    }, "send");
    if (this.debugging = t.debug ?? false, !J2.isInternalConstructing)
      throw new TypeError(
        "UniversalStore is not constructable - use UniversalStore.create() instead"
      );
    if (J2.isInternalConstructing = false, this.id = t.id, this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2), this.actorType = t.leader ? J2.ActorType.LEADER : J2.ActorType.FOLLOWER, this.state = t.initialState, this.channelEventName = `${w3}${this.id}`, this.debug("constructor", {
      options: t,
      environmentOverrides: r,
      channelEventName: this.channelEventName
    }), this.actor.type === J2.ActorType.LEADER)
      this.syncing = {
        state: Rt.RESOLVED,
        promise: Promise.resolve()
      };
    else {
      let n, i, s = new Promise((a, l) => {
        n = /* @__PURE__ */ o(() => {
          this.syncing.state === Rt.PENDING && (this.syncing.state = Rt.RESOLVED, a());
        }, "syncingResolve"), i = /* @__PURE__ */ o((u) => {
          this.syncing.state === Rt.PENDING && (this.syncing.state = Rt.REJECTED, l(u));
        }, "syncingReject");
      });
      this.syncing = {
        state: Rt.PENDING,
        promise: s,
        resolve: n,
        reject: i
      };
    }
    this.getState = this.getState.bind(this), this.setState = this.setState.bind(this), this.subscribe = this.subscribe.bind(this), this.onStateChange = this.onStateChange.bind(this), this.send = this.send.bind(this), this.emitToChannel = this.emitToChannel.bind(this), this.prepareThis = this.prepareThis.bind(this), this.emitToListeners = this.emitToListeners.bind(this), this.handleChannelEvents = this.handleChannelEvents.bind(
      this
    ), this.debug = this.debug.bind(this), this.channel = r?.channel ?? J2.preparation.channel, this.environment = r?.environment ?? J2.preparation.environment, this.channel && this.environment ? (J2.preparation.resolve({ channel: this.channel, environment: this.environment }), this.prepareThis(
      { channel: this.channel, environment: this.environment }
    )) : J2.preparation.promise.then(this.prepareThis);
  }
  static setupPreparationPromise() {
    let t, r, n = new Promise(
      (i, s) => {
        t = /* @__PURE__ */ o((a) => {
          i(a);
        }, "resolveRef"), r = /* @__PURE__ */ o((...a) => {
          s(a);
        }, "rejectRef");
      }
    );
    J2.preparation = {
      resolve: t,
      reject: r,
      promise: n
    };
  }
  /** The actor object representing the store instance with a unique ID and a type */
  get actor() {
    return Object.freeze({
      id: this.actorId,
      type: this.actorType,
      environment: this.environment ?? J2.Environment.UNKNOWN
    });
  }
  /**
   * The current state of the store, that signals both if the store is prepared by Storybook and
   * also - in the case of a follower - if the state has been synced with the leader's state.
   */
  get status() {
    if (!this.channel || !this.environment)
      return J2.Status.UNPREPARED;
    switch (this.syncing?.state) {
      case Rt.PENDING:
      case void 0:
        return J2.Status.SYNCING;
      case Rt.REJECTED:
        return J2.Status.ERROR;
      case Rt.RESOLVED:
      default:
        return J2.Status.READY;
    }
  }
  /**
   * A promise that resolves when the store is fully ready. A leader will be ready when the store
   * has been prepared by Storybook, which is almost instantly.
   *
   * A follower will be ready when the state has been synced with the leader's state, within a few
   * hundred milliseconds.
   */
  untilReady() {
    return Promise.all([J2.preparation.promise, this.syncing?.promise]);
  }
  /** Creates a new instance of UniversalStore */
  static create(t) {
    if (!t || typeof t?.id != "string")
      throw new TypeError("id is required and must be a string, when creating a UniversalStore");
    t.debug && console.debug(
      Q$1`[UniversalStore]
        create`,
      { options: t }
    );
    let r = cb.get(t.id);
    if (r)
      return console.warn(Q$1`UniversalStore with id "${t.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`), r;
    J2.isInternalConstructing = true;
    let n = new J2(t);
    return cb.set(t.id, n), n;
  }
  /**
   * Used by Storybook to set the channel for all instances of UniversalStore in the given
   * environment.
   *
   * @internal
   */
  static __prepare(t, r) {
    J2.preparation.channel = t, J2.preparation.environment = r, J2.preparation.resolve({ channel: t, environment: r });
  }
  /**
   * Updates the store's state
   *
   * Either a new state or a state updater function can be passed to the method.
   */
  setState(t) {
    let r = this.state, n = typeof t == "function" ? t(r) : t;
    if (this.debug("setState", { newState: n, previousState: r, updater: t }), this.status !== J2.Status.READY)
      throw new TypeError(
        Q$1`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
          {
            newState: n,
            id: this.id,
            actor: this.actor,
            environment: this.environment
          },
          null,
          2
        )}`
      );
    this.state = n;
    let i = {
      type: J2.InternalEventType.SET_STATE,
      payload: {
        state: n,
        previousState: r
      }
    };
    this.emitToChannel(i, { actor: this.actor }), this.emitToListeners(i, { actor: this.actor });
  }
  /**
   * Subscribes to state changes
   *
   * @returns Unsubscribe function
   */
  onStateChange(t) {
    return this.debug("onStateChange", { listener: t }), this.subscribe(
      J2.InternalEventType.SET_STATE,
      ({ payload: r }, n) => {
        t(r.state, r.previousState, n);
      }
    );
  }
  emitToChannel(t, r) {
    this.debug("emitToChannel", { event: t, eventInfo: r, channel: !!this.channel }), this.channel?.emit(this.channelEventName, {
      event: t,
      eventInfo: r
    });
  }
  prepareThis({
    channel: t,
    environment: r
  }) {
    this.channel = t, this.environment = r, this.debug("prepared", { channel: !!t, environment: r }), this.channel.on(
      this.channelEventName,
      this.handleChannelEvents
    ), this.actor.type === J2.ActorType.LEADER ? this.emitToChannel(
      { type: J2.InternalEventType.LEADER_CREATED },
      { actor: this.actor }
    ) : (this.emitToChannel(
      { type: J2.InternalEventType.FOLLOWER_CREATED },
      { actor: this.actor }
    ), this.emitToChannel(
      { type: J2.InternalEventType.EXISTING_STATE_REQUEST },
      { actor: this.actor }
    ), setTimeout(() => {
      this.syncing.reject(
        new TypeError(
          `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`
        )
      );
    }, 1e3));
  }
  emitToListeners(t, r) {
    let n = this.listeners.get(t.type), i = this.listeners.get("*");
    this.debug("emitToListeners", {
      event: t,
      eventInfo: r,
      eventTypeListeners: n,
      everythingListeners: i
    }), [...n ?? [], ...i ?? []].forEach(
      (s) => s(t, r)
    );
  }
  handleChannelEvents(t) {
    let { event: r, eventInfo: n } = t;
    if ([n.actor.id, n.forwardingActor?.id].includes(this.actor.id)) {
      this.debug("handleChannelEvents: Ignoring event from self", { channelEvent: t });
      return;
    } else if (this.syncing?.state === Rt.PENDING && r.type !== J2.InternalEventType.EXISTING_STATE_RESPONSE) {
      this.debug("handleChannelEvents: Ignoring event while syncing", { channelEvent: t });
      return;
    }
    if (this.debug("handleChannelEvents", { channelEvent: t }), this.actor.type === J2.ActorType.LEADER) {
      let i = true;
      switch (r.type) {
        case J2.InternalEventType.EXISTING_STATE_REQUEST:
          i = false;
          let s = {
            type: J2.InternalEventType.EXISTING_STATE_RESPONSE,
            payload: this.state
          };
          this.debug("handleChannelEvents: responding to existing state request", {
            responseEvent: s
          }), this.emitToChannel(s, { actor: this.actor }), this.emitToListeners(s, { actor: this.actor });
          break;
        case J2.InternalEventType.LEADER_CREATED:
          i = false, this.syncing.state = Rt.REJECTED, this.debug("handleChannelEvents: erroring due to second leader being created", {
            event: r
          }), console.error(
            Q$1`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(n.actor, null, 2)}`
          );
          break;
      }
      i && (this.debug("handleChannelEvents: forwarding event", { channelEvent: t }), this.emitToChannel(r, { actor: n.actor, forwardingActor: this.actor }));
    }
    if (this.actor.type === J2.ActorType.FOLLOWER)
      switch (r.type) {
        case J2.InternalEventType.EXISTING_STATE_RESPONSE:
          if (this.debug("handleChannelEvents: Setting state from leader's existing state response", {
            event: r
          }), this.syncing?.state !== Rt.PENDING)
            break;
          this.syncing.resolve?.();
          let i = {
            type: J2.InternalEventType.SET_STATE,
            payload: {
              state: r.payload,
              previousState: this.state
            }
          };
          this.state = r.payload, this.emitToListeners(i, n);
          break;
      }
    switch (r.type) {
      case J2.InternalEventType.SET_STATE:
        this.debug("handleChannelEvents: Setting state", { event: r }), this.state = r.payload.state;
        break;
    }
    this.emitToListeners(r, { actor: n.actor });
  }
  debug(t, r) {
    this.debugging && console.debug(
      Q$1`[UniversalStore::${this.id}::${this.environment ?? J2.Environment.UNKNOWN}]
        ${t}`,
      JSON.stringify(
        {
          data: r,
          actor: this.actor,
          state: this.state,
          status: this.status
        },
        null,
        2
      )
    );
  }
  /**
   * Used to reset the static fields of the UniversalStore class when cleaning up tests
   *
   * @internal
   */
  static __reset() {
    J2.preparation.reject(new Error("reset")), J2.setupPreparationPromise(), J2.isInternalConstructing = false;
  }
};
o(J$1, "UniversalStore"), /**
* Defines the possible actor types in the store system
*
* @readonly
*/
J$1.ActorType = {
  LEADER: "LEADER",
  FOLLOWER: "FOLLOWER"
}, /**
* Defines the possible environments the store can run in
*
* @readonly
*/
J$1.Environment = {
  SERVER: "SERVER",
  MANAGER: "MANAGER",
  PREVIEW: "PREVIEW",
  UNKNOWN: "UNKNOWN",
  MOCK: "MOCK"
}, /**
* Internal event types used for store synchronization
*
* @readonly
*/
J$1.InternalEventType = {
  EXISTING_STATE_REQUEST: "__EXISTING_STATE_REQUEST",
  EXISTING_STATE_RESPONSE: "__EXISTING_STATE_RESPONSE",
  SET_STATE: "__SET_STATE",
  LEADER_CREATED: "__LEADER_CREATED",
  FOLLOWER_CREATED: "__FOLLOWER_CREATED"
}, J$1.Status = {
  UNPREPARED: "UNPREPARED",
  SYNCING: "SYNCING",
  READY: "READY",
  ERROR: "ERROR"
}, // This is used to check if constructor was called from the static factory create()
J$1.isInternalConstructing = false, J$1.setupPreparationPromise();
var po = J$1;
var T3 = /* @__PURE__ */ o((e) => e.transports !== void 0, "isMulti"), R3 = /* @__PURE__ */ o(() => Math.random().toString(16).slice(2), "generateRandomId"), db = class db2 {
  constructor(t = {}) {
    this.sender = R3();
    this.events = {};
    this.data = {};
    this.transports = [];
    this.isAsync = t.async || false, T3(t) ? (this.transports = t.transports || [], this.transports.forEach((r) => {
      r.setHandler((n) => this.handleEvent(n));
    })) : this.transports = t.transport ? [t.transport] : [], this.transports.forEach((r) => {
      r.setHandler((n) => this.handleEvent(n));
    });
  }
  get hasTransport() {
    return this.transports.length > 0;
  }
  addListener(t, r) {
    this.events[t] = this.events[t] || [], this.events[t].push(r);
  }
  emit(t, ...r) {
    let n = { type: t, args: r, from: this.sender }, i = {};
    r.length >= 1 && r[0] && r[0].options && (i = r[0].options);
    let s = /* @__PURE__ */ o(() => {
      this.transports.forEach((a) => {
        a.send(n, i);
      }), this.handleEvent(n);
    }, "handler");
    this.isAsync ? setImmediate(s) : s();
  }
  last(t) {
    return this.data[t];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(t) {
    let r = this.listeners(t);
    return r ? r.length : 0;
  }
  listeners(t) {
    return this.events[t] || void 0;
  }
  once(t, r) {
    let n = this.onceListener(t, r);
    this.addListener(t, n);
  }
  removeAllListeners(t) {
    t ? this.events[t] && delete this.events[t] : this.events = {};
  }
  removeListener(t, r) {
    let n = this.listeners(t);
    n && (this.events[t] = n.filter((i) => i !== r));
  }
  on(t, r) {
    this.addListener(t, r);
  }
  off(t, r) {
    this.removeListener(t, r);
  }
  handleEvent(t) {
    let r = this.listeners(t.type);
    r && r.length && r.forEach((n) => {
      n.apply(t, t.args);
    }), this.data[t.type] = t.args;
  }
  onceListener(t, r) {
    let n = /* @__PURE__ */ o((...i) => (this.removeListener(t, n), r(...i)), "onceListener");
    return n;
  }
};
o(db, "Channel");
var Ar$1 = db;
var fb = {};
st$1(fb, {
  deprecate: () => Ai,
  logger: () => se,
  once: () => be,
  pretty: () => pt$1
});
var { LOGLEVEL: S3 } = k, Or$1 = {
  trace: 1,
  debug: 2,
  info: 3,
  warn: 4,
  error: 5,
  silent: 10
}, _3 = S3, fo = Or$1[_3] || Or$1.info, se = {
  trace: /* @__PURE__ */ o((e, ...t) => {
    fo <= Or$1.trace && console.trace(e, ...t);
  }, "trace"),
  debug: /* @__PURE__ */ o((e, ...t) => {
    fo <= Or$1.debug && console.debug(e, ...t);
  }, "debug"),
  info: /* @__PURE__ */ o((e, ...t) => {
    fo <= Or$1.info && console.info(e, ...t);
  }, "info"),
  warn: /* @__PURE__ */ o((e, ...t) => {
    fo <= Or$1.warn && console.warn(e, ...t);
  }, "warn"),
  error: /* @__PURE__ */ o((e, ...t) => {
    fo <= Or$1.error && console.error(e, ...t);
  }, "error"),
  log: /* @__PURE__ */ o((e, ...t) => {
    fo < Or$1.silent && console.log(e, ...t);
  }, "log")
}, pb = /* @__PURE__ */ new Set(), be = /* @__PURE__ */ o((e) => (t, ...r) => {
  if (!pb.has(t))
    return pb.add(t), se[e](t, ...r);
}, "once");
be.clear = () => pb.clear();
be.trace = be("trace");
be.debug = be("debug");
be.info = be("info");
be.warn = be("warn");
be.error = be("error");
be.log = be("log");
var Ai = be("warn"), pt$1 = /* @__PURE__ */ o((e) => (...t) => {
  let r = [];
  if (t.length) {
    let n = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, i = /<\/span>/gi, s;
    for (r.push(t[0].replace(n, "%c").replace(i, "%c")); s = n.exec(t[0]); )
      r.push(s[2]), r.push("");
    for (let a = 1; a < t.length; a++)
      r.push(t[a]);
  }
  se[e].apply(se, r);
}, "pretty");
pt$1.trace = pt$1("trace");
pt$1.debug = pt$1("debug");
pt$1.info = pt$1("info");
pt$1.warn = pt$1("warn");
pt$1.error = pt$1("error");
var C3 = Object.create, hS = Object.defineProperty, P3 = Object.getOwnPropertyDescriptor, yS = Object.getOwnPropertyNames, A3 = Object.getPrototypeOf, O3 = Object.prototype.hasOwnProperty, te = /* @__PURE__ */ o((e, t) => /* @__PURE__ */ o(function() {
  return t || (0, e[yS(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, "__require"), "__commonJS"), q3 = /* @__PURE__ */ o((e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of yS(t))
      !O3.call(e, i) && i !== r && hS(e, i, { get: /* @__PURE__ */ o(() => t[i], "get"), enumerable: !(n = P3(t, i)) || n.enumerable });
  return e;
}, "__copyProps"), Ba = /* @__PURE__ */ o((e, t, r) => (r = e != null ? C3(A3(e)) : {}, q3(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? hS(r, "default", { value: e, enumerable: true }) : r,
  e
)), "__toESM"), I3 = [
  "bubbles",
  "cancelBubble",
  "cancelable",
  "composed",
  "currentTarget",
  "defaultPrevented",
  "eventPhase",
  "isTrusted",
  "returnValue",
  "srcElement",
  "target",
  "timeStamp",
  "type"
], M3 = ["detail"];
function bS(e) {
  let t = I3.filter((r) => e[r] !== void 0).reduce((r, n) => (r[n] = e[n], r), {});
  if (e instanceof CustomEvent)
    for (let r of M3.filter(
      (n) => e[n] !== void 0
    ))
      t[r] = e[r];
  return t;
}
o(bS, "extractEventHiddenProperties");
var TS = te({
  "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(e, t) {
    t.exports = Object;
  }
}), N3 = te({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(e, t) {
    t.exports = Error;
  }
}), j3 = te({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(e, t) {
    t.exports = EvalError;
  }
}), k3 = te({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(e, t) {
    t.exports = RangeError;
  }
}), L3 = te({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(e, t) {
    t.exports = ReferenceError;
  }
}), F3 = te({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(e, t) {
    t.exports = SyntaxError;
  }
}), hb = te({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(e, t) {
    t.exports = TypeError;
  }
}), D3 = te({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(e, t) {
    t.exports = URIError;
  }
}), $3 = te({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(e, t) {
    t.exports = Math.abs;
  }
}), B3 = te({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(e, t) {
    t.exports = Math.floor;
  }
}), H3 = te({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(e, t) {
    t.exports = Math.max;
  }
}), U3 = te({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(e, t) {
    t.exports = Math.min;
  }
}), V3 = te({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(e, t) {
    t.exports = Math.pow;
  }
}), z3 = te({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(e, t) {
    t.exports = Math.round;
  }
}), G3 = te({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(e, t) {
    t.exports = Number.isNaN || /* @__PURE__ */ o(function(n) {
      return n !== n;
    }, "isNaN2");
  }
}), W3 = te({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(e, t) {
    var r = G3();
    t.exports = /* @__PURE__ */ o(function(i) {
      return r(i) || i === 0 ? i : i < 0 ? -1 : 1;
    }, "sign");
  }
}), Y3 = te({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(e, t) {
    t.exports = Object.getOwnPropertyDescriptor;
  }
}), yb = te({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(e, t) {
    var r = Y3();
    if (r)
      try {
        r([], "length");
      } catch {
        r = null;
      }
    t.exports = r;
  }
}), K3 = te({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(e, t) {
    var r = Object.defineProperty || false;
    if (r)
      try {
        r({}, "a", { value: 1 });
      } catch {
        r = false;
      }
    t.exports = r;
  }
}), RS = te({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(e, t) {
    t.exports = /* @__PURE__ */ o(function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var n = {}, i = Symbol("test"), s = Object(i);
      if (typeof i == "string" || Object.prototype.toString.call(i) !== "[object Symbol]" || Object.prototype.toString.call(s) !== "[object Symbol]")
        return false;
      var a = 42;
      n[i] = a;
      for (var l in n)
        return false;
      if (typeof Object.keys == "function" && Object.keys(n).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(
        n
      ).length !== 0)
        return false;
      var u = Object.getOwnPropertySymbols(n);
      if (u.length !== 1 || u[0] !== i || !Object.prototype.propertyIsEnumerable.call(n, i))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var c = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(n, i)
        );
        if (c.value !== a || c.enumerable !== true)
          return false;
      }
      return true;
    }, "hasSymbols");
  }
}), SS = te({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(e, t) {
    var r = typeof Symbol < "u" && Symbol, n = RS();
    t.exports = /* @__PURE__ */ o(function() {
      return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : n();
    }, "hasNativeSymbols");
  }
}), _S = te({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(e, t) {
    t.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
  }
}), CS = te({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(e, t) {
    var r = TS();
    t.exports = r.getPrototypeOf || null;
  }
}), X3 = te({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(e, t) {
    var r = "Function.prototype.bind called on incompatible ", n = Object.prototype.toString, i = Math.max, s = "[object Function]", a = /* @__PURE__ */ o(
      function(d, p) {
        for (var f = [], m = 0; m < d.length; m += 1)
          f[m] = d[m];
        for (var h = 0; h < p.length; h += 1)
          f[h + d.length] = p[h];
        return f;
      },
      "concatty2"
    ), l = /* @__PURE__ */ o(function(d, p) {
      for (var f = [], m = p || 0, h = 0; m < d.length; m += 1, h += 1)
        f[h] = d[m];
      return f;
    }, "slicy2"), u = /* @__PURE__ */ o(function(c, d) {
      for (var p = "", f = 0; f < c.length; f += 1)
        p += c[f], f + 1 < c.length && (p += d);
      return p;
    }, "joiny");
    t.exports = /* @__PURE__ */ o(function(d) {
      var p = this;
      if (typeof p != "function" || n.apply(p) !== s)
        throw new TypeError(r + p);
      for (var f = l(arguments, 1), m, h = /* @__PURE__ */ o(function() {
        if (this instanceof m) {
          var E = p.apply(
            this,
            a(f, arguments)
          );
          return Object(E) === E ? E : this;
        }
        return p.apply(
          d,
          a(f, arguments)
        );
      }, "binder"), b = i(0, p.length - f.length), v = [], g = 0; g < b; g++)
        v[g] = "$" + g;
      if (m = Function("binder", "return function (" + u(v, ",") + "){ return binder.apply(this,arguments); }")(h), p.prototype) {
        var w = /* @__PURE__ */ o(function() {
        }, "Empty2");
        w.prototype = p.prototype, m.prototype = new w(), w.prototype = null;
      }
      return m;
    }, "bind");
  }
}), Ha = te({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(e, t) {
    var r = X3();
    t.exports = Function.prototype.bind || r;
  }
}), bb = te({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(e, t) {
    t.exports = Function.prototype.call;
  }
}), PS = te({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(e, t) {
    t.exports = Function.prototype.apply;
  }
}), J3 = te({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(e, t) {
    t.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
  }
}), Q3 = te({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(e, t) {
    var r = Ha(), n = PS(), i = bb(), s = J3();
    t.exports = s || r.call(i, n);
  }
}), AS = te({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(e, t) {
    var r = Ha(), n = hb(), i = bb(), s = Q3();
    t.exports = /* @__PURE__ */ o(function(l) {
      if (l.length < 1 || typeof l[0] != "function")
        throw new n("a function is required");
      return s(r, i, l);
    }, "callBindBasic");
  }
}), Z3 = te({
  "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(e, t) {
    var r = AS(), n = yb(), i;
    try {
      i = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (u) {
      if (!u || typeof u != "object" || !("code" in u) || u.code !== "ERR_PROTO_ACCESS")
        throw u;
    }
    var s = !!i && n && n(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    ), a = Object, l = a.getPrototypeOf;
    t.exports = s && typeof s.get == "function" ? r([s.get]) : typeof l == "function" ? (
      /** @type {import('./get')} */
      /* @__PURE__ */ o(function(c) {
        return l(c == null ? c : a(c));
      }, "getDunder")
    ) : false;
  }
}), eV = te({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(e, t) {
    var r = _S(), n = CS(), i = Z3();
    t.exports = r ? /* @__PURE__ */ o(function(a) {
      return r(a);
    }, "getProto") : n ? /* @__PURE__ */ o(function(a) {
      if (!a || typeof a != "object" && typeof a != "function")
        throw new TypeError("getProto: not an object");
      return n(a);
    }, "getProto") : i ? /* @__PURE__ */ o(function(a) {
      return i(a);
    }, "getProto") : null;
  }
}), OS = te({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(e, t) {
    var r = Function.prototype.call, n = Object.prototype.hasOwnProperty, i = Ha();
    t.exports = i.call(r, n);
  }
}), tV = te({
  "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(e, t) {
    var r, n = TS(), i = N3(), s = j3(), a = k3(), l = L3(), u = F3(), c = hb(), d = D3(), p = $3(), f = B3(), m = H3(), h = U3(), b = V3(), v = z3(), g = W3(), w = Function, E = /* @__PURE__ */ o(function(bt) {
      try {
        return w('"use strict"; return (' + bt + ").constructor;")();
      } catch {
      }
    }, "getEvalledConstructor"), R = yb(), S = K3(), P = /* @__PURE__ */ o(function() {
      throw new c();
    }, "throwTypeError"), _ = R ? function() {
      try {
        return arguments.callee, P;
      } catch {
        try {
          return R(arguments, "callee").get;
        } catch {
          return P;
        }
      }
    }() : P, C = SS()(), O = eV(), L = CS(), q = _S(), D = PS(), H = bb(), M = {}, U = typeof Uint8Array > "u" || !O ? r : O(Uint8Array), N = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError > "u" ? r : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer,
      "%ArrayIteratorPrototype%": C && O ? O([][Symbol.iterator]()) : r,
      "%AsyncFromSyncIteratorPrototype%": r,
      "%AsyncFunction%": M,
      "%AsyncGenerator%": M,
      "%AsyncGeneratorFunction%": M,
      "%AsyncIteratorPrototype%": M,
      "%Atomics%": typeof Atomics > "u" ? r : Atomics,
      "%BigInt%": typeof BigInt > "u" ? r : BigInt,
      "%BigInt64Array%": typeof BigInt64Array > "u" ? r : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array > "u" ? r : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? r : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": i,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": s,
      "%Float16Array%": typeof Float16Array > "u" ? r : Float16Array,
      "%Float32Array%": typeof Float32Array > "u" ? r : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? r : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry,
      "%Function%": w,
      "%GeneratorFunction%": M,
      "%Int8Array%": typeof Int8Array > "u" ? r : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? r : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? r : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": C && O ? O(O([][Symbol.iterator]())) : r,
      "%JSON%": typeof JSON == "object" ? JSON : r,
      "%Map%": typeof Map > "u" ? r : Map,
      "%MapIteratorPrototype%": typeof Map > "u" || !C || !O ? r : O((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": n,
      "%Object.getOwnPropertyDescriptor%": R,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? r : Promise,
      "%Proxy%": typeof Proxy > "u" ? r : Proxy,
      "%RangeError%": a,
      "%ReferenceError%": l,
      "%Reflect%": typeof Reflect > "u" ? r : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? r : Set,
      "%SetIteratorPrototype%": typeof Set > "u" || !C || !O ? r : O((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": C && O ? O(""[Symbol.iterator]()) : r,
      "%Symbol%": C ? Symbol : r,
      "%SyntaxError%": u,
      "%ThrowTypeError%": _,
      "%TypedArray%": U,
      "%TypeError%": c,
      "%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array,
      "%URIError%": d,
      "%WeakMap%": typeof WeakMap > "u" ? r : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? r : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? r : WeakSet,
      "%Function.prototype.call%": H,
      "%Function.prototype.apply%": D,
      "%Object.defineProperty%": S,
      "%Object.getPrototypeOf%": L,
      "%Math.abs%": p,
      "%Math.floor%": f,
      "%Math.max%": m,
      "%Math.min%": h,
      "%Math.pow%": b,
      "%Math.round%": v,
      "%Math.sign%": g,
      "%Reflect.getPrototypeOf%": q
    };
    if (O)
      try {
        null.error;
      } catch (bt) {
        W = O(O(bt)), N["%Error.prototype%"] = W;
      }
    var W, Y = /* @__PURE__ */ o(function bt(we) {
      var Ze;
      if (we === "%AsyncFunction%")
        Ze = E("async function () {}");
      else if (we === "%GeneratorFunction%")
        Ze = E("function* () {}");
      else if (we === "%AsyncGeneratorFunction%")
        Ze = E("async function* () {}");
      else if (we === "%AsyncGenerator%") {
        var je = bt("%AsyncGeneratorFunction%");
        je && (Ze = je.prototype);
      } else if (we === "%AsyncIteratorPrototype%") {
        var it = bt("%AsyncGenerator%");
        it && O && (Ze = O(it.prototype));
      }
      return N[we] = Ze, Ze;
    }, "doEval2"), ae = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }, pe = Ha(), Oe = OS(), F = pe.call(H, Array.prototype.concat), j = pe.call(D, Array.prototype.splice), K = pe.call(H, String.prototype.replace), G = pe.call(H, String.prototype.slice), Z = pe.call(H, RegExp.prototype.exec), ve = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, qe = /\\(\\)?/g, Qe = /* @__PURE__ */ o(function(we) {
      var Ze = G(we, 0, 1), je = G(we, -1);
      if (Ze === "%" && je !== "%")
        throw new u("invalid intrinsic syntax, expected closing `%`");
      if (je === "%" && Ze !== "%")
        throw new u("invalid intrinsic syntax, expected opening `%`");
      var it = [];
      return K(we, ve, function(er, ao, dt, Ma) {
        it[it.length] = dt ? K(Ma, qe, "$1") : ao || er;
      }), it;
    }, "stringToPath3"), vi = /* @__PURE__ */ o(function(we, Ze) {
      var je = we, it;
      if (Oe(ae, je) && (it = ae[je], je = "%" + it[0] + "%"), Oe(N, je)) {
        var er = N[je];
        if (er === M && (er = Y(je)), typeof er > "u" && !Ze)
          throw new c("intrinsic " + we + " exists, but is not available. Please file an issue!");
        return {
          alias: it,
          name: je,
          value: er
        };
      }
      throw new u("intrinsic " + we + " does not exist!");
    }, "getBaseIntrinsic2");
    t.exports = /* @__PURE__ */ o(function(we, Ze) {
      if (typeof we != "string" || we.length === 0)
        throw new c("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof Ze != "boolean")
        throw new c('"allowMissing" argument must be a boolean');
      if (Z(/^%?[^%]*%?$/, we) === null)
        throw new u("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var je = Qe(we), it = je.length > 0 ? je[0] : "", er = vi("%" + it + "%", Ze), ao = er.name, dt = er.value, Ma = false, $y = er.alias;
      $y && (it = $y[0], j(je, F([0, 1], $y)));
      for (var V = 1, Ei = true; V < je.length; V += 1) {
        var dr = je[V], Na = G(dr, 0, 1), ja = G(dr, -1);
        if ((Na === '"' || Na === "'" || Na === "`" || ja === '"' || ja === "'" || ja === "`") && Na !== ja)
          throw new u("property names with quotes must have matching quotes");
        if ((dr === "constructor" || !Ei) && (Ma = true), it += "." + dr, ao = "%" + it + "%", Oe(N, ao))
          dt = N[ao];
        else if (dt != null) {
          if (!(dr in dt)) {
            if (!Ze)
              throw new c("base intrinsic for " + we + " exists, but the property is not available.");
            return;
          }
          if (R && V + 1 >= je.length) {
            var ka = R(dt, dr);
            Ei = !!ka, Ei && "get" in ka && !("originalValue" in ka.get) ? dt = ka.get : dt = dt[dr];
          } else
            Ei = Oe(dt, dr), dt = dt[dr];
          Ei && !Ma && (N[ao] = dt);
        }
      }
      return dt;
    }, "GetIntrinsic");
  }
}), gb = te({
  "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(e, t) {
    var r = tV(), n = AS(), i = n([r("%String.prototype.indexOf%")]);
    t.exports = /* @__PURE__ */ o(function(a, l) {
      var u = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        r(a, !!l)
      );
      return typeof u == "function" && i(a, ".prototype.") > -1 ? n(
        /** @type {const} */
        [u]
      ) : u;
    }, "callBoundIntrinsic");
  }
}), rV = te({
  "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(e, t) {
    var r = RS();
    t.exports = /* @__PURE__ */ o(function() {
      return r() && !!Symbol.toStringTag;
    }, "hasToStringTagShams");
  }
}), qS = te({
  "node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js"(e, t) {
    var r = gb(), n = rV()(), i = OS(), s = yb(), a;
    n ? (l = r("RegExp.prototype.exec"), u = {}, c = /* @__PURE__ */ o(function() {
      throw u;
    }, "throwRegexMarker"), d = {
      toString: c,
      valueOf: c
    }, typeof Symbol.toPrimitive == "symbol" && (d[Symbol.toPrimitive] = c), a = /* @__PURE__ */ o(function(h) {
      if (!h || typeof h != "object")
        return false;
      var b = (
        /** @type {NonNullable<typeof gOPD>} */
        s(
          /** @type {{ lastIndex?: unknown }} */
          h,
          "lastIndex"
        )
      ), v = b && i(b, "value");
      if (!v)
        return false;
      try {
        l(
          h,
          /** @type {string} */
          /** @type {unknown} */
          d
        );
      } catch (g) {
        return g === u;
      }
    }, "isRegex")) : (p = r("Object.prototype.toString"), f = "[object RegExp]", a = /* @__PURE__ */ o(function(h) {
      return !h || typeof h != "object" && typeof h != "function" ? false : p(h) === f;
    }, "isRegex"));
    var l, u, c, d, p, f;
    t.exports = a;
  }
}), nV = te({
  "node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js"(e, t) {
    t.exports = n;
    var r = Object.prototype.toString;
    function n(i) {
      if (!i)
        return false;
      var s = r.call(i);
      return s === "[object Function]" || typeof i == "function" && s !== "[object RegExp]" || typeof window < "u" && // IE8 and below
      (i === window.setTimeout || i === window.alert || i === window.confirm || i === window.prompt);
    }
    o(n, "isFunction3");
  }
}), oV = te({
  "node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js"(e, t) {
    var r = gb(), n = qS(), i = r("RegExp.prototype.exec"), s = hb();
    t.exports = /* @__PURE__ */ o(function(l) {
      if (!n(l))
        throw new s("`regex` must be a RegExp");
      return /* @__PURE__ */ o(function(c) {
        return i(l, c) !== null;
      }, "test");
    }, "regexTester");
  }
}), iV = te({
  "node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js"(e, t) {
    var r = gb(), n = r("Object.prototype.toString"), i = SS()(), s = oV();
    i ? (a = r("Symbol.prototype.toString"), l = s(/^Symbol\(.*\)$/), u = /* @__PURE__ */ o(function(d) {
      return typeof d.valueOf() != "symbol" ? false : l(a(d));
    }, "isRealSymbolObject"), t.exports = /* @__PURE__ */ o(function(d) {
      if (typeof d == "symbol")
        return true;
      if (!d || typeof d != "object" || n(d) !== "[object Symbol]")
        return false;
      try {
        return u(d);
      } catch {
        return false;
      }
    }, "isSymbol3")) : t.exports = /* @__PURE__ */ o(function(d) {
      return false;
    }, "isSymbol3");
    var a, l, u;
  }
}), sV = Ba(qS()), aV = Ba(nV()), lV = Ba(iV());
function uV(e) {
  return e != null && typeof e == "object" && Array.isArray(e) === false;
}
o(uV, "isObject");
var cV = typeof global == "object" && global && global.Object === Object && global, dV = cV, pV = typeof self == "object" && self && self.Object === Object && self, fV = dV || pV || Function("return this")(), vb = fV, mV = vb.Symbol, mo = mV, IS = Object.prototype, hV = IS.hasOwnProperty, yV = IS.toString, Oi = mo ? mo.toStringTag : void 0;
function bV(e) {
  var t = hV.call(e, Oi), r = e[Oi];
  try {
    e[Oi] = void 0;
    var n = true;
  } catch {
  }
  var i = yV.call(e);
  return n && (t ? e[Oi] = r : delete e[Oi]), i;
}
o(bV, "getRawTag");
var gV = bV, vV = Object.prototype, EV = vV.toString;
function xV(e) {
  return EV.call(e);
}
o(xV, "objectToString");
var wV = xV, TV = "[object Null]", RV = "[object Undefined]", gS = mo ? mo.toStringTag : void 0;
function SV(e) {
  return e == null ? e === void 0 ? RV : TV : gS && gS in Object(e) ? gV(e) : wV(e);
}
o(SV, "baseGetTag");
var MS = SV;
function _V(e) {
  return e != null && typeof e == "object";
}
o(_V, "isObjectLike");
var CV = _V, PV = "[object Symbol]";
function AV(e) {
  return typeof e == "symbol" || CV(e) && MS(e) == PV;
}
o(AV, "isSymbol");
var Eb = AV;
function OV(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; )
    i[r] = t(e[r], r, e);
  return i;
}
o(OV, "arrayMap");
var qV = OV, IV = Array.isArray, xb = IV, MV = 1 / 0, vS = mo ? mo.prototype : void 0, ES = vS ? vS.toString : void 0;
function NS(e) {
  if (typeof e == "string")
    return e;
  if (xb(e))
    return qV(e, NS) + "";
  if (Eb(e))
    return ES ? ES.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -MV ? "-0" : t;
}
o(NS, "baseToString");
var NV = NS;
function jV(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
o(jV, "isObject2");
var jS = jV, kV = "[object AsyncFunction]", LV = "[object Function]", FV = "[object GeneratorFunction]", DV = "[object Proxy]";
function $V(e) {
  if (!jS(e))
    return false;
  var t = MS(e);
  return t == LV || t == FV || t == kV || t == DV;
}
o($V, "isFunction");
var BV = $V, HV = vb["__core-js_shared__"], mb = HV, xS = function() {
  var e = /[^.]+$/.exec(mb && mb.keys && mb.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function UV(e) {
  return !!xS && xS in e;
}
o(UV, "isMasked");
var VV = UV, zV = Function.prototype, GV = zV.toString;
function WV(e) {
  if (e != null) {
    try {
      return GV.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
o(WV, "toSource");
var YV = WV, KV = /[\\^$.*+?()[\]{}|]/g, XV = /^\[object .+?Constructor\]$/, JV = Function.prototype, QV = Object.prototype, ZV = JV.toString, ez = QV.hasOwnProperty, tz = RegExp(
  "^" + ZV.call(ez).replace(KV, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function rz(e) {
  if (!jS(e) || VV(e))
    return false;
  var t = BV(e) ? tz : XV;
  return t.test(YV(e));
}
o(rz, "baseIsNative");
var nz = rz;
function oz(e, t) {
  return e?.[t];
}
o(oz, "getValue");
var iz = oz;
function sz(e, t) {
  var r = iz(e, t);
  return nz(r) ? r : void 0;
}
o(sz, "getNative");
var kS = sz;
function az(e, t) {
  return e === t || e !== e && t !== t;
}
o(az, "eq");
var lz = az, uz = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, cz = /^\w*$/;
function dz(e, t) {
  if (xb(e))
    return false;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || Eb(e) ? true : cz.test(e) || !uz.test(e) || t != null && e in Object(
    t
  );
}
o(dz, "isKey");
var pz = dz, fz = kS(Object, "create"), qi = fz;
function mz() {
  this.__data__ = qi ? qi(null) : {}, this.size = 0;
}
o(mz, "hashClear");
var hz = mz;
function yz(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
o(yz, "hashDelete");
var bz = yz, gz = "__lodash_hash_undefined__", vz = Object.prototype, Ez = vz.hasOwnProperty;
function xz(e) {
  var t = this.__data__;
  if (qi) {
    var r = t[e];
    return r === gz ? void 0 : r;
  }
  return Ez.call(t, e) ? t[e] : void 0;
}
o(xz, "hashGet");
var wz = xz, Tz = Object.prototype, Rz = Tz.hasOwnProperty;
function Sz(e) {
  var t = this.__data__;
  return qi ? t[e] !== void 0 : Rz.call(t, e);
}
o(Sz, "hashHas");
var _z = Sz, Cz = "__lodash_hash_undefined__";
function Pz(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = qi && t === void 0 ? Cz : t, this;
}
o(Pz, "hashSet");
var Az = Pz;
function ho(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
o(ho, "Hash");
ho.prototype.clear = hz;
ho.prototype.delete = bz;
ho.prototype.get = wz;
ho.prototype.has = _z;
ho.prototype.set = Az;
var wS = ho;
function Oz() {
  this.__data__ = [], this.size = 0;
}
o(Oz, "listCacheClear");
var qz = Oz;
function Iz(e, t) {
  for (var r = e.length; r--; )
    if (lz(e[r][0], t))
      return r;
  return -1;
}
o(Iz, "assocIndexOf");
var Ua = Iz, Mz = Array.prototype, Nz = Mz.splice;
function jz(e) {
  var t = this.__data__, r = Ua(t, e);
  if (r < 0)
    return false;
  var n = t.length - 1;
  return r == n ? t.pop() : Nz.call(t, r, 1), --this.size, true;
}
o(jz, "listCacheDelete");
var kz = jz;
function Lz(e) {
  var t = this.__data__, r = Ua(t, e);
  return r < 0 ? void 0 : t[r][1];
}
o(Lz, "listCacheGet");
var Fz = Lz;
function Dz(e) {
  return Ua(this.__data__, e) > -1;
}
o(Dz, "listCacheHas");
var $z = Dz;
function Bz(e, t) {
  var r = this.__data__, n = Ua(r, e);
  return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
}
o(Bz, "listCacheSet");
var Hz = Bz;
function yo(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
o(yo, "ListCache");
yo.prototype.clear = qz;
yo.prototype.delete = kz;
yo.prototype.get = Fz;
yo.prototype.has = $z;
yo.prototype.set = Hz;
var Uz = yo, Vz = kS(vb, "Map"), zz = Vz;
function Gz() {
  this.size = 0, this.__data__ = {
    hash: new wS(),
    map: new (zz || Uz)(),
    string: new wS()
  };
}
o(Gz, "mapCacheClear");
var Wz = Gz;
function Yz(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
o(Yz, "isKeyable");
var Kz = Yz;
function Xz(e, t) {
  var r = e.__data__;
  return Kz(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
o(Xz, "getMapData");
var Va = Xz;
function Jz(e) {
  var t = Va(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
o(Jz, "mapCacheDelete");
var Qz = Jz;
function Zz(e) {
  return Va(this, e).get(e);
}
o(Zz, "mapCacheGet");
var eG = Zz;
function tG(e) {
  return Va(this, e).has(e);
}
o(tG, "mapCacheHas");
var rG = tG;
function nG(e, t) {
  var r = Va(this, e), n = r.size;
  return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
}
o(nG, "mapCacheSet");
var oG = nG;
function bo(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
o(bo, "MapCache");
bo.prototype.clear = Wz;
bo.prototype.delete = Qz;
bo.prototype.get = eG;
bo.prototype.has = rG;
bo.prototype.set = oG;
var LS = bo, iG = "Expected a function";
function wb(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(iG);
  var r = /* @__PURE__ */ o(function() {
    var n = arguments, i = t ? t.apply(this, n) : n[0], s = r.cache;
    if (s.has(i))
      return s.get(i);
    var a = e.apply(this, n);
    return r.cache = s.set(i, a) || s, a;
  }, "memoized");
  return r.cache = new (wb.Cache || LS)(), r;
}
o(wb, "memoize");
wb.Cache = LS;
var sG = wb, aG = 500;
function lG(e) {
  var t = sG(e, function(n) {
    return r.size === aG && r.clear(), n;
  }), r = t.cache;
  return t;
}
o(lG, "memoizeCapped");
var uG = lG, cG = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, dG = /\\(\\)?/g, pG = uG(
  function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""), e.replace(cG, function(r, n, i, s) {
      t.push(i ? s.replace(dG, "$1") : n || r);
    }), t;
  }
), fG = pG;
function mG(e) {
  return e == null ? "" : NV(e);
}
o(mG, "toString");
var hG = mG;
function yG(e, t) {
  return xb(e) ? e : pz(e, t) ? [e] : fG(hG(e));
}
o(yG, "castPath");
var bG = yG, gG = 1 / 0;
function vG(e) {
  if (typeof e == "string" || Eb(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -gG ? "-0" : t;
}
o(vG, "toKey");
var EG = vG;
function xG(e, t) {
  t = bG(t, e);
  for (var r = 0, n = t.length; e != null && r < n; )
    e = e[EG(t[r++])];
  return r && r == n ? e : void 0;
}
o(xG, "baseGet");
var wG = xG;
function TG(e, t, r) {
  var n = e == null ? void 0 : wG(e, t);
  return n === void 0 ? r : n;
}
o(TG, "get");
var RG = TG, Tb = uV, SG = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/, Ii = /* @__PURE__ */ o(
  (e) => e.match(/^[\[\{\"\}].*[\]\}\"]$/),
  "isJSON"
);
function FS(e) {
  if (!Tb(e))
    return e;
  let t = e, r = false;
  return typeof Event < "u" && e instanceof Event && (t = bS(t), r = true), t = Object.keys(t).reduce((n, i) => {
    try {
      t[i] && t[i].toJSON, n[i] = t[i];
    } catch {
      r = true;
    }
    return n;
  }, {}), r ? t : e;
}
o(FS, "convertUnconventionalData");
var _G = /* @__PURE__ */ o(function(t) {
  let r, n, i, s;
  return /* @__PURE__ */ o(function(l, u) {
    try {
      if (l === "")
        return s = [], r = /* @__PURE__ */ new Map([[u, "[]"]]), n = /* @__PURE__ */ new Map(), i = [], u;
      let c = n.get(this) || this;
      for (; i.length && c !== i[0]; )
        i.shift(), s.pop();
      if (typeof u == "boolean")
        return u;
      if (u === void 0)
        return t.allowUndefined ? "_undefined_" : void 0;
      if (u === null)
        return null;
      if (typeof u == "number")
        return u === Number.NEGATIVE_INFINITY ? "_-Infinity_" : u === Number.POSITIVE_INFINITY ? "_Infinity_" : Number.isNaN(u) ? "_NaN_" : u;
      if (typeof u == "bigint")
        return `_bigint_${u.toString()}`;
      if (typeof u == "string")
        return SG.test(u) ? t.allowDate ? `_date_${u}` : void 0 : u;
      if ((0, sV.default)(u))
        return t.allowRegExp ? `_regexp_${u.flags}|${u.source}` : void 0;
      if ((0, aV.default)(u))
        return;
      if ((0, lV.default)(u)) {
        if (!t.allowSymbol)
          return;
        let p = Symbol.keyFor(u);
        return p !== void 0 ? `_gsymbol_${p}` : `_symbol_${u.toString().slice(7, -1)}`;
      }
      if (i.length >= t.maxDepth)
        return Array.isArray(u) ? `[Array(${u.length})]` : "[Object]";
      if (u === this)
        return `_duplicate_${JSON.stringify(s)}`;
      if (u instanceof Error && t.allowError)
        return {
          __isConvertedError__: true,
          errorProperties: {
            // @ts-expect-error cause is not defined in the current tsconfig target(es2020)
            ...u.cause ? { cause: u.cause } : {},
            ...u,
            name: u.name,
            message: u.message,
            stack: u.stack,
            "_constructor-name_": u.constructor.name
          }
        };
      if (u?.constructor?.name && u.constructor.name !== "Object" && !Array.isArray(u)) {
        let p = r.get(u);
        if (!p) {
          let f = {
            __isClassInstance__: true,
            __className__: u.constructor.name,
            ...Object.getOwnPropertyNames(u).reduce(
              (m, h) => {
                try {
                  m[h] = u[h];
                } catch {
                }
                return m;
              },
              {}
            )
          };
          return s.push(l), i.unshift(f), r.set(u, JSON.stringify(s)), u !== f && n.set(u, f), f;
        }
        return `_duplicate_${p}`;
      }
      let d = r.get(u);
      if (!d) {
        let p = Array.isArray(u) ? u : FS(u);
        return s.push(l), i.unshift(p), r.set(u, JSON.stringify(s)), u !== p && n.set(u, p), p;
      }
      return `_duplicate_${d}`;
    } catch {
      return;
    }
  }, "replace");
}, "replacer2"), CG = /* @__PURE__ */ o(function(t) {
  let r = [], n;
  return /* @__PURE__ */ o(function(s, a) {
    if (s === "" && (n = a, r.forEach(({ target: l, container: u, replacement: c }) => {
      let d = Ii(c) ? JSON.parse(c) : c.split(".");
      d.length === 0 ? u[l] = n : u[l] = RG(n, d);
    })), s === "_constructor-name_")
      return a;
    if (Tb(a) && a.__isConvertedError__) {
      let { message: l, ...u } = a.errorProperties, c = new Error(l);
      return Object.assign(c, u), c;
    }
    if (typeof a == "string" && a.startsWith("_regexp_") && t.allowRegExp) {
      let [, l, u] = a.match(/_regexp_([^|]*)\|(.*)/) || [];
      return new RegExp(u, l);
    }
    return typeof a == "string" && a.startsWith("_date_") && t.allowDate ? new Date(a.replace("_date_", "")) : typeof a == "string" && a.startsWith(
      "_duplicate_"
    ) ? (r.push({ target: s, container: this, replacement: a.replace(/^_duplicate_/, "") }), null) : typeof a == "string" && a.startsWith("_symbol_") && t.allowSymbol ? Symbol(a.replace("_symbol_", "")) : typeof a == "string" && a.startsWith("_gsymbol_") && t.allowSymbol ? Symbol.for(a.replace("_gsymbol_", "")) : typeof a == "string" && a === "_-Infinity_" ? Number.NEGATIVE_INFINITY : typeof a == "string" && a === "_Infinity_" ? Number.POSITIVE_INFINITY : typeof a == "string" && a === "_NaN_" ? Number.NaN : typeof a == "string" && a.startsWith(
      "_bigint_"
    ) && typeof BigInt == "function" ? BigInt(a.replace("_bigint_", "")) : a;
  }, "revive");
}, "reviver2"), DS = {
  maxDepth: 10,
  space: void 0,
  allowRegExp: true,
  allowDate: true,
  allowError: true,
  allowUndefined: true,
  allowSymbol: true
}, za = /* @__PURE__ */ o((e, t = {}) => {
  let r = { ...DS, ...t };
  return JSON.stringify(FS(e), _G(r), t.space);
}, "stringify"), PG = /* @__PURE__ */ o(() => {
  let e = /* @__PURE__ */ new Map();
  return /* @__PURE__ */ o(function t(r) {
    Tb(r) && Object.entries(r).forEach(([n, i]) => {
      i === "_undefined_" ? r[n] = void 0 : e.get(i) || (e.set(i, true), t(i));
    }), Array.isArray(r) && r.forEach((n, i) => {
      n === "_undefined_" ? (e.set(n, true), r[i] = void 0) : e.get(n) || (e.set(n, true), t(n));
    });
  }, "mutateUndefined");
}, "mutator"), Ga = /* @__PURE__ */ o((e, t = {}) => {
  let r = { ...DS, ...t }, n = JSON.parse(e, CG(r));
  return PG()(n), n;
}, "parse");
var Rb = "Invariant failed";
function gt$1(e, t) {
  if (!e) {
    throw new Error(Rb);
  }
}
o(gt$1, "invariant");
var $S = /* @__PURE__ */ o((e) => {
  let t = Array.from(
    document.querySelectorAll("iframe[data-is-storybook]")
  ), [r, ...n] = t.filter((s) => {
    try {
      return s.contentWindow?.location.origin === e.source.location.origin && s.contentWindow?.location.pathname === e.source.location.pathname;
    } catch {
    }
    try {
      return s.contentWindow === e.source;
    } catch {
    }
    let a = s.getAttribute("src"), l;
    try {
      if (!a)
        return false;
      ({ origin: l } = new URL(a, document.location.toString()));
    } catch {
      return false;
    }
    return l === e.origin;
  }), i = r?.getAttribute("src");
  if (i && n.length === 0) {
    let { protocol: s, host: a, pathname: l } = new URL(i, document.location.toString());
    return `${s}//${a}${l}`;
  }
  return n.length > 0 && se.error("found multiple candidates for event source"), null;
}, "getEventSourceUrl");
var { document: Sb, location: _b } = k, BS = "storybook-channel", OG = { maxDepth: 25 }, Cb = class Cb2 {
  constructor(t) {
    this.config = t;
    this.connected = false;
    if (this.buffer = [], typeof k?.addEventListener == "function" && k.addEventListener("message", this.handleEvent.bind(this), false), t.page !== "manager" && t.page !== "preview")
      throw new Error(`postmsg-channel: "config.page" cannot be "${t.page}"`);
  }
  setHandler(t) {
    this.handler = (...r) => {
      t.apply(this, r), !this.connected && this.getLocalFrame().length && (this.flush(), this.connected = true);
    };
  }
  /**
   * Sends `event` to the associated window. If the window does not yet exist the event will be
   * stored in a buffer and sent when the window exists.
   *
   * @param event
   */
  send(t, r) {
    let {
      target: n,
      // telejson options
      allowRegExp: i,
      allowSymbol: s,
      allowDate: a,
      allowError: l,
      allowUndefined: u,
      maxDepth: c,
      space: d
    } = r || {}, p = Object.fromEntries(
      Object.entries({
        allowRegExp: i,
        allowSymbol: s,
        allowDate: a,
        allowError: l,
        allowUndefined: u,
        maxDepth: c,
        space: d
      }).filter(([v, g]) => typeof g < "u")
    ), f = {
      ...OG,
      ...k.CHANNEL_OPTIONS || {},
      ...p
    }, m = this.getFrames(n), h = new URLSearchParams(_b?.search || ""), b = za(
      {
        key: BS,
        event: t,
        refId: h.get("refId")
      },
      f
    );
    return m.length ? (this.buffer.length && this.flush(), m.forEach((v) => {
      try {
        v.postMessage(b, "*");
      } catch {
        se.error("sending over postmessage fail");
      }
    }), Promise.resolve(null)) : new Promise((v, g) => {
      this.buffer.push({ event: t, resolve: v, reject: g });
    });
  }
  flush() {
    let { buffer: t } = this;
    this.buffer = [], t.forEach((r) => {
      this.send(r.event).then(r.resolve).catch(r.reject);
    });
  }
  getFrames(t) {
    if (this.config.page === "manager") {
      let n = Array.from(
        Sb.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")
      ).flatMap((i) => {
        try {
          return i.contentWindow && i.dataset.isStorybook !== void 0 && i.id === t ? [i.contentWindow] : [];
        } catch {
          return [];
        }
      });
      return n?.length ? n : this.getCurrentFrames();
    }
    return k && k.parent && k.parent !== k.self ? [k.parent] : [];
  }
  getCurrentFrames() {
    return this.config.page === "manager" ? Array.from(
      Sb.querySelectorAll('[data-is-storybook="true"]')
    ).flatMap((r) => r.contentWindow ? [r.contentWindow] : []) : k && k.parent ? [k.parent] : [];
  }
  getLocalFrame() {
    return this.config.page === "manager" ? Array.from(
      Sb.querySelectorAll("#storybook-preview-iframe")
    ).flatMap((r) => r.contentWindow ? [r.contentWindow] : []) : k && k.parent ? [k.parent] : [];
  }
  handleEvent(t) {
    try {
      let { data: r } = t, { key: n, event: i, refId: s } = typeof r == "string" && Ii(r) ? Ga(r, k.CHANNEL_OPTIONS || {}) : r;
      if (n === BS) {
        let a = this.config.page === "manager" ? '<span style="color: #37D5D3; background: black"> manager </span>' : '<span style="color: #1EA7FD; background: black"> preview </span>', l = Object.values(co).includes(i.type) ? `<span style="color: #FF4785">${i.type}</span>` : `<span style="color: #FFAE00">${i.type}</span>`;
        if (s && (i.refId = s), i.source = this.config.page === "preview" ? t.origin : $S(t), !i.source) {
          pt$1.error(
            `${a} received ${l} but was unable to determine the source of the event`
          );
          return;
        }
        let u = `${a} received ${l} (${r.length})`;
        pt$1.debug(
          _b.origin !== i.source ? u : `${u} <span style="color: gray">(on ${_b.origin} from ${i.source})</span>`,
          ...i.args
        ), gt$1(this.handler, "ChannelHandler should be set"), this.handler(i);
      }
    } catch (r) {
      se.error(r);
    }
  }
};
o(Cb, "PostMessageTransport");
var go = Cb;
var { WebSocket: qG } = k, Pb = 15e3, Ab = 5e3, Ob = class Ob2 {
  constructor({ url: t, onError: r, page: n }) {
    this.buffer = [];
    this.isReady = false;
    this.isClosed = false;
    this.pingTimeout = 0;
    this.socket = new qG(t), this.socket.onopen = () => {
      this.isReady = true, this.heartbeat(), this.flush();
    }, this.socket.onmessage = ({ data: i }) => {
      let s = typeof i == "string" && Ii(i) ? Ga(i) : i;
      gt$1(this.handler), this.handler(s), s.type === "ping" && (this.heartbeat(), this.send({ type: "pong" }));
    }, this.socket.onerror = (i) => {
      r && r(i);
    }, this.socket.onclose = (i) => {
      gt$1(this.handler), this.handler({
        type: Hy,
        args: [{ reason: i.reason, code: i.code }],
        from: n || "preview"
      }), this.isClosed = true, clearTimeout(this.pingTimeout);
    };
  }
  heartbeat() {
    clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
      this.socket.close(3008, "timeout");
    }, Pb + Ab);
  }
  setHandler(t) {
    this.handler = t;
  }
  send(t) {
    this.isClosed || (this.isReady ? this.sendNow(t) : this.sendLater(t));
  }
  sendLater(t) {
    this.buffer.push(t);
  }
  sendNow(t) {
    let r = za(t, {
      maxDepth: 15,
      ...k.CHANNEL_OPTIONS
    });
    this.socket.send(r);
  }
  flush() {
    let { buffer: t } = this;
    this.buffer = [], t.forEach((r) => this.send(r));
  }
};
o(Ob, "WebsocketTransport");
var vo = Ob;
var { CONFIG_TYPE: IG } = k, MG = Ar$1;
function NG({ page: e, extraTransports: t = [] }) {
  let r = [new go({ page: e }), ...t];
  if (IG === "DEVELOPMENT") {
    let i = window.location.protocol === "http:" ? "ws" : "wss", { hostname: s, port: a } = window.location, l = `${i}://${s}:${a}/storybook-server-channel`;
    r.push(new vo({ url: l, onError: /* @__PURE__ */ o(() => {
    }, "onError"), page: e }));
  }
  let n = new Ar$1({ transports: r });
  return po.__prepare(
    n,
    e === "manager" ? po.Environment.MANAGER : po.Environment.PREVIEW
  ), n;
}
o(NG, "createBrowserChannel");
var Fb = {};
st$1(Fb, {
  CalledExtractOnStoreError: () => ji,
  CalledPreviewMethodBeforeInitializationError: () => We,
  Category: () => VS,
  ElementA11yParameterError: () => Lb,
  EmptyIndexError: () => Di,
  ImplicitActionsDuringRendering: () => Ni,
  MdxFileWithNoCsfReferencesError: () => Fi,
  MissingRenderToCanvasError: () => ki,
  MissingStoryAfterHmrError: () => Mi,
  MissingStoryFromCsfFileError: () => Bi,
  MountMustBeDestructuredError: () => gn,
  NextJsSharpError: () => Mb,
  NextjsRouterMocksNotAvailable: () => Nb,
  NoRenderFunctionError: () => Ui,
  NoStoryMatchError: () => $i,
  NoStoryMountedError: () => Vi,
  StatusTypeIdMismatchError: () => Ib,
  StoryIndexFetchError: () => Li,
  StoryStoreAccessedBeforeInitializationError: () => Hi,
  UnknownArgTypesError: () => jb,
  UnsupportedViewportDimensionError: () => kb
});
function HS({
  code: e,
  category: t
}) {
  let r = String(e).padStart(4, "0");
  return `SB_${t}_${r}`;
}
o(HS, "parseErrorCode");
function US(e) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(e))
    return e;
  try {
    let t = new URL(e);
    return t.searchParams.set("ref", "error"), t.toString();
  } catch {
    return e;
  }
}
o(US, "appendErrorRef");
var Wa = class Wa2 extends Error {
  constructor(r) {
    super(Wa2.getFullMessage(r));
    this.data = {};
    this.fromStorybook = true;
    this.category = r.category, this.documentation = r.documentation ?? false, this.code = r.code;
  }
  get fullErrorCode() {
    return HS({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    let r = this.constructor.name;
    return `${this.fullErrorCode} (${r})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation: r,
    code: n,
    category: i,
    message: s
  }) {
    let a;
    return r === true ? a = `https://storybook.js.org/error/${HS({ code: n, category: i })}?ref=error` : typeof r == "string" ? a = US(r) : Array.isArray(r) && (a = `
${r.map((l) => `	- ${US(l)}`).join(`
`)}`), `${s}${a != null ? `

More info: ${a}
` : ""}`;
  }
};
o(Wa, "StorybookError");
var Pe = Wa;
var VS = /* @__PURE__ */ ((S) => (S.BLOCKS = "BLOCKS", S.DOCS_TOOLS = "DOCS-TOOLS", S.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", S.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", S.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", S.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", S.PREVIEW_API = "PREVIEW_API", S.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", S.PREVIEW_ROUTER = "PREVIEW_ROUTER", S.PREVIEW_THEMING = "PREVIEW_THEMING", S.RENDERER_HTML = "RENDERER_HTML", S.RENDERER_PREACT = "RENDERER_PREACT", S.RENDERER_REACT = "RENDERER_REACT", S.RENDERER_SERVER = "RENDERER_SERVER", S.RENDERER_SVELTE = "RENDERER_SVELTE", S.RENDERER_VUE = "RENDERER_VUE", S.RENDERER_VUE3 = "RENDERER_VUE3", S.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", S.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", S.ADDON_VITEST = "ADDON_VITEST", S.ADDON_A11Y = "ADDON_A11Y", S))(VS || {}), Db = class Db2 extends Pe {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 1,
      message: Q$1`
        Couldn't find story matching id '${r.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${r.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    });
    this.data = r;
  }
};
o(Db, "MissingStoryAfterHmrError");
var Mi = Db, $b = class $b2 extends Pe {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: Q$1`
        We detected that you use an implicit action arg while ${r.phase} of your story.  
        ${r.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${r.name}: fn()
          }`
    });
    this.data = r;
  }
};
o($b, "ImplicitActionsDuringRendering");
var Ni = $b, Bb = class Bb2 extends Pe {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 3,
      message: Q$1`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
};
o(Bb, "CalledExtractOnStoreError");
var ji = Bb, Hb = class Hb2 extends Pe {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 4,
      message: Q$1`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
};
o(Hb, "MissingRenderToCanvasError");
var ki = Hb, Ub = class Ub2 extends Pe {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 5,
      message: Q$1`
        Called \`Preview.${r.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${r.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    });
    this.data = r;
  }
};
o(Ub, "CalledPreviewMethodBeforeInitializationError");
var We = Ub, Vb = class Vb2 extends Pe {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 6,
      message: Q$1`
        Error fetching \`/index.json\`:
        
        ${r.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    });
    this.data = r;
  }
};
o(Vb, "StoryIndexFetchError");
var Li = Vb, zb = class zb2 extends Pe {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 7,
      message: Q$1`
        Tried to render docs entry ${r.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    });
    this.data = r;
  }
};
o(zb, "MdxFileWithNoCsfReferencesError");
var Fi = zb, Gb = class Gb2 extends Pe {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 8,
      message: Q$1`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
};
o(Gb, "EmptyIndexError");
var Di = Gb, Wb = class Wb2 extends Pe {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 9,
      message: Q$1`
        Couldn't find story matching '${r.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    });
    this.data = r;
  }
};
o(Wb, "NoStoryMatchError");
var $i = Wb, Yb = class Yb2 extends Pe {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 10,
      message: Q$1`
        Couldn't find story matching id '${r.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    });
    this.data = r;
  }
};
o(Yb, "MissingStoryFromCsfFileError");
var Bi = Yb, Kb = class Kb2 extends Pe {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 11,
      message: Q$1`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
};
o(Kb, "StoryStoreAccessedBeforeInitializationError");
var Hi = Kb, Xb = class Xb2 extends Pe {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 12,
      message: Q$1`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${r.playFunction}`
    });
    this.data = r;
  }
};
o(Xb, "MountMustBeDestructuredError");
var gn = Xb, Jb = class Jb2 extends Pe {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 14,
      message: Q$1`
        No render function available for storyId '${r.id}'
      `
    });
    this.data = r;
  }
};
o(Jb, "NoRenderFunctionError");
var Ui = Jb, Qb = class Qb2 extends Pe {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 15,
      message: Q$1`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
};
o(Qb, "NoStoryMountedError");
var Vi = Qb, Zb = class Zb2 extends Pe {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 16,
      message: `Status has typeId "${r.status.typeId}" but was added to store with typeId "${r.typeId}". Full status: ${JSON.stringify(
        r.status,
        null,
        2
      )}`
    });
    this.data = r;
  }
};
o(Zb, "StatusTypeIdMismatchError");
var Ib = Zb, eg = class eg2 extends Pe {
  constructor() {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: Q$1`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
};
o(eg, "NextJsSharpError");
var Mb = eg, tg = class tg2 extends Pe {
  constructor(r) {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 2,
      message: Q$1`
        Tried to access router mocks from "${r.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    });
    this.data = r;
  }
};
o(tg, "NextjsRouterMocksNotAvailable");
var Nb = tg, rg = class rg2 extends Pe {
  constructor(r) {
    super({
      category: "DOCS-TOOLS",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: Q$1`
        There was a failure when generating detailed ArgTypes in ${r.language} for:
        ${JSON.stringify(r.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    });
    this.data = r;
  }
};
o(rg, "UnknownArgTypesError");
var jb = rg, ng = class ng2 extends Pe {
  constructor(r) {
    super({
      category: "ADDON_VITEST",
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: Q$1`
        Encountered an unsupported value "${r.value}" when setting the viewport ${r.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    });
    this.data = r;
  }
};
o(ng, "UnsupportedViewportDimensionError");
var kb = ng, og = class og2 extends Pe {
  constructor() {
    super({
      category: "ADDON_A11Y",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
      message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
    });
  }
};
o(og, "ElementA11yParameterError");
var Lb = og;
var ig = {};
st$1(ig, {
  Addon_TypesEnum: () => zS
});
var zS = /* @__PURE__ */ ((l) => (l.TAB = "tab", l.PANEL = "panel", l.TOOL = "tool", l.TOOLEXTRA = "toolextra", l.PREVIEW = "preview", l.experimental_PAGE = "page", l.experimental_TEST_PROVIDER = "test-provider", l))(zS || {});
var lS = {};
st$1(lS, {
  ADDON_ID: () => Ya,
  CLEAR_ID: () => LG,
  CYCLIC_KEY: () => FG,
  EVENT_ID: () => sg,
  PANEL_ID: () => kG,
  PARAM_KEY: () => jG,
  action: () => Ir,
  actions: () => Twe,
  config: () => so,
  configureActions: () => Ewe
});
var jG = "actions", Ya = "storybook/actions", kG = `${Ya}/panel`, sg = `${Ya}/action-event`, LG = `${Ya}/action-clear`, FG = "$___storybook.isCyclic";
var Dy = {};
st$1(Dy, {
  DocsContext: () => Cr$1,
  HooksContext: () => qr$1,
  Preview: () => Qn,
  PreviewWeb: () => qa,
  PreviewWithSelection: () => Zn,
  ReporterAPI: () => dn$1,
  StoryStore: () => Xn,
  UrlStore: () => ro,
  WebView: () => oo,
  addons: () => He,
  applyHooks: () => Xa,
  combineArgs: () => hi,
  combineParameters: () => Tt$1,
  composeConfigs: () => _r$1,
  composeStepRunners: () => wy,
  composeStories: () => CU,
  composeStory: () => OR,
  createPlaywrightTest: () => PU,
  decorateStory: () => SR,
  defaultDecorateStory: () => vy,
  emitTransformCode: () => aS,
  filterArgTypes: () => Ta,
  getCsfFactoryAnnotations: () => Sy,
  inferControls: () => gi,
  makeDecorator: () => n_,
  mockChannel: () => Ka,
  normalizeArrays: () => de,
  normalizeProjectAnnotations: () => Wn,
  normalizeStory: () => Gn,
  pauseAnimations: () => Yn,
  prepareMeta: () => Ey,
  prepareStory: () => bi,
  sanitizeStoryContextUpdate: () => _R,
  setDefaultProjectAnnotations: () => SU,
  setProjectAnnotations: () => _U,
  simulateDOMContentLoaded: () => Ia,
  simulatePageLoad: () => sS,
  sortStoriesV7: () => NU,
  useArgs: () => t_,
  useCallback: () => Eo,
  useChannel: () => ZS,
  useEffect: () => kt$1,
  useGlobals: () => r_,
  useMemo: () => Qa,
  useParameter: () => e_,
  useReducer: () => QS,
  useRef: () => KS,
  useState: () => JS,
  useStoryContext: () => zi,
  userOrAutoTitle: () => qU,
  userOrAutoTitleFromSpecifier: () => MR,
  waitForAnimations: () => Kn
});
function Ka() {
  let e = {
    setHandler: /* @__PURE__ */ o(() => {
    }, "setHandler"),
    send: /* @__PURE__ */ o(() => {
    }, "send")
  };
  return new Ar$1({ transport: e });
}
o(Ka, "mockChannel");
var ug = class ug2 {
  constructor() {
    this.getChannel = /* @__PURE__ */ o(() => {
      if (!this.channel) {
        let t = Ka();
        return this.setChannel(t), t;
      }
      return this.channel;
    }, "getChannel");
    this.ready = /* @__PURE__ */ o(() => this.promise, "ready");
    this.hasChannel = /* @__PURE__ */ o(() => !!this.channel, "hasChannel");
    this.setChannel = /* @__PURE__ */ o((t) => {
      this.channel = t, this.resolve();
    }, "setChannel");
    this.promise = new Promise((t) => {
      this.resolve = () => t(this.getChannel());
    });
  }
};
o(ug, "AddonStore");
var lg = ug, ag = "__STORYBOOK_ADDONS_PREVIEW";
function DG() {
  return k[ag] || (k[ag] = new lg()), k[ag];
}
o(DG, "getAddonsStore");
var He = DG();
var fg = class fg2 {
  constructor() {
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = /* @__PURE__ */ o((t) => {
      t === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    }, "renderListener");
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = false, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((t) => {
      t.destroy && t.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    let t = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, t;
  }
  triggerEffects() {
    this.prevEffects.forEach((t) => {
      !this.currentEffects.includes(t) && t.destroy && t.destroy();
    }), this.currentEffects.forEach((t) => {
      this.prevEffects.includes(t) || (t.destroy = t.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), He.getChannel().on(uo, this.renderListener);
  }
  removeRenderListeners() {
    He.getChannel().removeListener(uo, this.renderListener);
  }
};
o(fg, "HooksContext");
var qr$1 = fg;
function GS(e) {
  let t = /* @__PURE__ */ o((...r) => {
    let { hooks: n } = typeof r[0] == "function" ? r[1] : r[0], i = n.currentPhase, s = n.currentHooks, a = n.nextHookIndex, l = n.currentDecoratorName;
    n.currentDecoratorName = e.name, n.prevMountedDecorators.has(e) ? (n.currentPhase = "UPDATE", n.currentHooks = n.hookListsMap.get(e) || []) : (n.currentPhase = "MOUNT", n.currentHooks = [], n.hookListsMap.set(e, n.currentHooks), n.prevMountedDecorators.add(e)), n.nextHookIndex = 0;
    let u = k.STORYBOOK_HOOKS_CONTEXT;
    k.STORYBOOK_HOOKS_CONTEXT = n;
    let c = e(...r);
    if (k.STORYBOOK_HOOKS_CONTEXT = u, n.currentPhase === "UPDATE" && n.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return n.currentPhase = i, n.currentHooks = s, n.nextHookIndex = a, n.currentDecoratorName = l, c;
  }, "hookified");
  return t.originalFn = e, t;
}
o(GS, "hookify");
var cg = 0, $G = 25, Xa = /* @__PURE__ */ o((e) => (t, r) => {
  let n = e(
    GS(t),
    r.map((i) => GS(i))
  );
  return (i) => {
    let { hooks: s } = i;
    s.prevMountedDecorators ??= /* @__PURE__ */ new Set(), s.mountedDecorators = /* @__PURE__ */ new Set([t, ...r]), s.currentContext = i, s.hasUpdates = false;
    let a = n(i);
    for (cg = 1; s.hasUpdates; )
      if (s.hasUpdates = false, s.currentEffects = [], a = n(i), cg += 1, cg > $G)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return s.addRenderListeners(), a;
  };
}, "applyHooks"), BG = /* @__PURE__ */ o((e, t) => e.length === t.length && e.every((r, n) => r === t[n]), "areDepsEqual"), dg = /* @__PURE__ */ o(
  () => new Error("Storybook preview hooks can only be called inside decorators and story functions."),
  "invalidHooksError"
);
function WS() {
  return k.STORYBOOK_HOOKS_CONTEXT || null;
}
o(WS, "getHooksContextOrNull");
function pg() {
  let e = WS();
  if (e == null)
    throw dg();
  return e;
}
o(pg, "getHooksContextOrThrow");
function HG(e, t, r) {
  let n = pg();
  if (n.currentPhase === "MOUNT") {
    r != null && !Array.isArray(r) && se.warn(
      `${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`
    );
    let i = { name: e, deps: r };
    return n.currentHooks.push(i), t(i), i;
  }
  if (n.currentPhase === "UPDATE") {
    let i = n.getNextHook();
    if (i == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return i.name !== e && se.warn(
      `Storybook has detected a change in the order of Hooks${n.currentDecoratorName ? ` called by ${n.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), r != null && i.deps == null && se.warn(
      `${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), r != null && i.deps != null && r.length !== i.deps.length && se.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${i.deps}
Incoming: ${r}`), (r == null || i.deps == null || !BG(r, i.deps)) && (t(i), i.deps = r), i;
  }
  throw dg();
}
o(HG, "useHook");
function Ja(e, t, r) {
  let { memoizedState: n } = HG(
    e,
    (i) => {
      i.memoizedState = t();
    },
    r
  );
  return n;
}
o(Ja, "useMemoLike");
function Qa(e, t) {
  return Ja("useMemo", e, t);
}
o(Qa, "useMemo");
function Eo(e, t) {
  return Ja("useCallback", () => e, t);
}
o(Eo, "useCallback");
function YS(e, t) {
  return Ja(e, () => ({ current: t }), []);
}
o(YS, "useRefLike");
function KS(e) {
  return YS("useRef", e);
}
o(KS, "useRef");
function UG() {
  let e = WS();
  if (e != null && e.currentPhase !== "NONE")
    e.hasUpdates = true;
  else
    try {
      He.getChannel().emit(Ri);
    } catch {
      se.warn("State updates of Storybook preview hooks work only in browser");
    }
}
o(UG, "triggerUpdate");
function XS(e, t) {
  let r = YS(
    e,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof t == "function" ? t() : t
  ), n = /* @__PURE__ */ o((i) => {
    r.current = typeof i == "function" ? i(r.current) : i, UG();
  }, "setState");
  return [r.current, n];
}
o(XS, "useStateLike");
function JS(e) {
  return XS("useState", e);
}
o(JS, "useState");
function QS(e, t, r) {
  let n = r != null ? () => r(t) : t, [i, s] = XS("useReducer", n);
  return [i, /* @__PURE__ */ o((l) => s((u) => e(u, l)), "dispatch")];
}
o(QS, "useReducer");
function kt$1(e, t) {
  let r = pg(), n = Ja("useEffect", () => ({ create: e }), t);
  r.currentEffects.includes(n) || r.currentEffects.push(n);
}
o(kt$1, "useEffect");
function ZS(e, t = []) {
  let r = He.getChannel();
  return kt$1(() => (Object.entries(e).forEach(([n, i]) => r.on(n, i)), () => {
    Object.entries(e).forEach(
      ([n, i]) => r.removeListener(n, i)
    );
  }), [...Object.keys(e), ...t]), Eo(r.emit.bind(r), [r]);
}
o(ZS, "useChannel");
function zi() {
  let { currentContext: e } = pg();
  if (e == null)
    throw dg();
  return e;
}
o(zi, "useStoryContext");
function e_(e, t) {
  let { parameters: r } = zi();
  if (e)
    return r[e] ?? t;
}
o(e_, "useParameter");
function t_() {
  let e = He.getChannel(), { id: t, args: r } = zi(), n = Eo(
    (s) => e.emit(Pi, { storyId: t, updatedArgs: s }),
    [e, t]
  ), i = Eo(
    (s) => e.emit(Si, { storyId: t, argNames: s }),
    [e, t]
  );
  return [r, n, i];
}
o(t_, "useArgs");
function r_() {
  let e = He.getChannel(), { globals: t } = zi(), r = Eo(
    (n) => e.emit(Ci, { globals: n }),
    [e]
  );
  return [t, r];
}
o(r_, "useGlobals");
var n_ = /* @__PURE__ */ o(({
  name: e,
  parameterName: t,
  wrapper: r,
  skipIfNoParametersOrOptions: n = false
}) => {
  let i = /* @__PURE__ */ o((s) => (a, l) => {
    let u = l.parameters && l.parameters[t];
    return u && u.disable || n && !s && !u ? a(l) : r(a, l, {
      options: s,
      parameters: u
    });
  }, "decorator");
  return (...s) => typeof s[0] == "function" ? i()(...s) : (...a) => {
    if (a.length > 1)
      return s.length > 1 ? i(s)(...a) : i(...s)(...a);
    throw new Error(
      `Passing stories directly into ${e}() is not allowed,
        instead use addDecorator(${e}) and pass options with the '${t}' parameter`
    );
  };
}, "makeDecorator");
function o_(e) {
  return e.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (t, r, n, i) => `${r} ${n}${i}`).replace(
    /([a-z])([A-Z])/g,
    (t, r, n) => `${r} ${n}`
  ).replace(/([a-z])([0-9])/gi, (t, r, n) => `${r} ${n}`).replace(/([0-9])([a-z])/gi, (t, r, n) => `${r} ${n}`).replace(/(\s|^)(\w)/g, (t, r, n) => `${r}${n.toUpperCase()}`).replace(/ +/g, " ").trim();
}
o(o_, "toStartCaseStr");
var hg = Ne(i_(), 1);
var s_ = /* @__PURE__ */ o((e) => e.map((t) => typeof t < "u").filter(Boolean).length, "count"), VG = /* @__PURE__ */ o((e, t) => {
  let { exists: r, eq: n, neq: i, truthy: s } = e;
  if (s_([r, n, i, s]) > 1)
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists: r, eq: n, neq: i })}`);
  if (typeof n < "u")
    return (0, hg.isEqual)(t, n);
  if (typeof i < "u")
    return !(0, hg.isEqual)(t, i);
  if (typeof r < "u") {
    let l = typeof t < "u";
    return r ? l : !l;
  }
  return (typeof s > "u" ? true : s) ? !!t : !t;
}, "testValue"), yg = /* @__PURE__ */ o((e, t, r) => {
  if (!e.if)
    return true;
  let { arg: n, global: i } = e.if;
  if (s_([n, i]) !== 1)
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg: n, global: i })}`);
  let s = n ? t[n] : r[i];
  return VG(e.if, s);
}, "includeConditionalArg");
var bg = {};
st$1(bg, {
  argsEnhancers: () => zG
});
var a_ = /* @__PURE__ */ o((e, t) => typeof t[e] > "u" && !(e in t), "isInInitialArgs"), l_ = /* @__PURE__ */ o((e) => {
  let {
    initialArgs: t,
    argTypes: r,
    id: n,
    parameters: { actions: i }
  } = e;
  if (!i || i.disable || !i.argTypesRegex || !r)
    return {};
  let s = new RegExp(i.argTypesRegex);
  return Object.entries(r).filter(
    ([l]) => !!s.test(l)
  ).reduce((l, [u, c]) => (a_(u, t) && (l[u] = Ir(u, { implicit: true, id: n })), l), {});
}, "inferActionsFromArgTypesRegex"), u_ = /* @__PURE__ */ o((e) => {
  let {
    initialArgs: t,
    argTypes: r,
    parameters: { actions: n }
  } = e;
  return n?.disable || !r ? {} : Object.entries(r).filter(([s, a]) => !!a.action).reduce((s, [a, l]) => (a_(a, t) && (s[a] = Ir(typeof l.action == "string" ? l.action : a)), s), {});
}, "addActionsFromArgTypes");
var zG = [
  u_,
  l_
];
var zT = {};
st$1(zT, {
  loaders: () => Jve
});
var VT = {};
st$1(VT, {
  buildQueries: () => Oge,
  clearAllMocks: () => cw,
  configure: () => qge,
  createEvent: () => Ige,
  expect: () => Yve,
  findAllByAltText: () => Nge,
  findAllByDisplayValue: () => jge,
  findAllByLabelText: () => kge,
  findAllByPlaceholderText: () => Lge,
  findAllByRole: () => Fge,
  findAllByTestId: () => Dge,
  findAllByText: () => $ge,
  findAllByTitle: () => Bge,
  findByAltText: () => Hge,
  findByDisplayValue: () => Uge,
  findByLabelText: () => Vge,
  findByPlaceholderText: () => zge,
  findByRole: () => Gge,
  findByTestId: () => Wge,
  findByText: () => Yge,
  findByTitle: () => Kge,
  fireEvent: () => Mge,
  fn: () => uw,
  getAllByAltText: () => Xge,
  getAllByDisplayValue: () => Jge,
  getAllByLabelText: () => Qge,
  getAllByPlaceholderText: () => Zge,
  getAllByRole: () => eve,
  getAllByTestId: () => tve,
  getAllByText: () => rve,
  getAllByTitle: () => nve,
  getByAltText: () => ove,
  getByDisplayValue: () => ive,
  getByLabelText: () => sve,
  getByPlaceholderText: () => ave,
  getByRole: () => lve,
  getByTestId: () => uve,
  getByText: () => cve,
  getByTitle: () => dve,
  getConfig: () => pve,
  getDefaultNormalizer: () => fve,
  getElementError: () => mve,
  getNodeText: () => hve,
  getQueriesForElement: () => yve,
  getRoles: () => bve,
  getSuggestedQuery: () => gve,
  isInaccessible: () => vve,
  isMockFunction: () => hr$1,
  logDOM: () => Eve,
  logRoles: () => xve,
  mocked: () => lie,
  mocks: () => Go,
  onMockCall: () => lw,
  prettyDOM: () => wve,
  prettyFormat: () => Gve,
  queries: () => Tve,
  queryAllByAltText: () => Rve,
  queryAllByAttribute: () => Sve,
  queryAllByDisplayValue: () => _ve,
  queryAllByLabelText: () => Cve,
  queryAllByPlaceholderText: () => Pve,
  queryAllByRole: () => Ave,
  queryAllByTestId: () => Ove,
  queryAllByText: () => qve,
  queryAllByTitle: () => Ive,
  queryByAltText: () => Mve,
  queryByAttribute: () => Nve,
  queryByDisplayValue: () => jve,
  queryByLabelText: () => kve,
  queryByPlaceholderText: () => Lve,
  queryByRole: () => Fve,
  queryByTestId: () => Dve,
  queryByText: () => $ve,
  queryByTitle: () => Bve,
  queryHelpers: () => Hve,
  resetAllMocks: () => dw,
  restoreAllMocks: () => pw,
  sb: () => Kve,
  screen: () => Uve,
  spyOn: () => aie,
  uninstrumentedUserEvent: () => UT,
  userEvent: () => Wve,
  waitFor: () => Vve,
  waitForElementToBeRemoved: () => zve,
  within: () => HT
});
var GG = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
}, WG = Object.entries(GG);
function gg(e) {
  return String(e);
}
o(gg, "a");
gg.open = "";
gg.close = "";
function c_(e = false) {
  let t = typeof process < "u" ? process : void 0, r = t?.env || {}, n = t?.argv || [];
  return !("NO_COLOR" in r || n.includes("--no-color")) && ("FORCE_COLOR" in r || n.includes("--color") || t?.platform === "win32" || e && r.TERM !== "dumb" || "CI" in r) || typeof window < "u" && !!window.chrome;
}
o(c_, "C");
function d_(e = false) {
  let t = c_(e), r = /* @__PURE__ */ o((a, l, u, c) => {
    let d = "", p = 0;
    do
      d += a.substring(p, c) + u, p = c + l.length, c = a.indexOf(l, p);
    while (~c);
    return d + a.substring(p);
  }, "i"), n = /* @__PURE__ */ o((a, l, u = a) => {
    let c = /* @__PURE__ */ o((d) => {
      let p = String(d), f = p.indexOf(l, a.length);
      return ~f ? a + r(p, l, u, f) + l : a + p + l;
    }, "o");
    return c.open = a, c.close = l, c;
  }, "g"), i = {
    isColorSupported: t
  }, s = /* @__PURE__ */ o((a) => `\x1B[${a}m`, "d");
  for (let [a, l] of WG)
    i[a] = t ? n(
      s(l[0]),
      s(l[1]),
      l[2]
    ) : gg;
  return i;
}
o(d_, "p");
var Ee = d_();
function R_(e, t) {
  return t.forEach(function(r) {
    r && typeof r != "string" && !Array.isArray(r) && Object.keys(r).forEach(function(n) {
      if (n !== "default" && !(n in e)) {
        var i = Object.getOwnPropertyDescriptor(r, n);
        Object.defineProperty(e, n, i.get ? i : {
          enumerable: true,
          get: /* @__PURE__ */ o(function() {
            return r[n];
          }, "get")
        });
      }
    });
  }), Object.freeze(e);
}
o(R_, "_mergeNamespaces");
function YG(e, t) {
  let r = Object.keys(e), n = t === null ? r : r.sort(t);
  if (Object.getOwnPropertySymbols)
    for (let i of Object.getOwnPropertySymbols(e))
      Object.getOwnPropertyDescriptor(e, i).enumerable && n.push(i);
  return n;
}
o(YG, "getKeysOfEnumerableProperties");
function Wi(e, t, r, n, i, s, a = ": ") {
  let l = "", u = 0, c = e.next();
  if (!c.done) {
    l += t.spacingOuter;
    let d = r + t.indent;
    for (; !c.done; ) {
      if (l += d, u++ === t.maxWidth) {
        l += "";
        break;
      }
      let p = s(c.value[0], t, d, n, i), f = s(c.value[1], t, d, n, i);
      l += p + a + f, c = e.next(), c.done ? t.min || (l += ",") : l += `,${t.spacingInner}`;
    }
    l += t.spacingOuter + r;
  }
  return l;
}
o(Wi, "printIteratorEntries");
function Tg(e, t, r, n, i, s) {
  let a = "", l = 0, u = e.next();
  if (!u.done) {
    a += t.spacingOuter;
    let c = r + t.indent;
    for (; !u.done; ) {
      if (a += c, l++ === t.maxWidth) {
        a += "";
        break;
      }
      a += s(u.value, t, c, n, i), u = e.next(), u.done ? t.min || (a += ",") : a += `,${t.spacingInner}`;
    }
    a += t.spacingOuter + r;
  }
  return a;
}
o(Tg, "printIteratorValues");
function tl(e, t, r, n, i, s) {
  let a = "";
  e = e instanceof ArrayBuffer ? new DataView(e) : e;
  let l = /* @__PURE__ */ o((c) => c instanceof DataView, "isDataView"), u = l(e) ? e.byteLength : e.length;
  if (u > 0) {
    a += t.spacingOuter;
    let c = r + t.indent;
    for (let d = 0; d < u; d++) {
      if (a += c, d === t.maxWidth) {
        a += "";
        break;
      }
      (l(e) || d in e) && (a += s(l(e) ? e.getInt8(d) : e[d], t, c, n, i)), d < u - 1 ? a += `,${t.spacingInner}` : t.min || (a += ",");
    }
    a += t.spacingOuter + r;
  }
  return a;
}
o(tl, "printListItems");
function Rg(e, t, r, n, i, s) {
  let a = "", l = YG(e, t.compareKeys);
  if (l.length > 0) {
    a += t.spacingOuter;
    let u = r + t.indent;
    for (let c = 0; c < l.length; c++) {
      let d = l[c], p = s(d, t, u, n, i), f = s(e[d], t, u, n, i);
      a += `${u + p}: ${f}`, c < l.length - 1 ? a += `,${t.spacingInner}` : t.min || (a += ",");
    }
    a += t.spacingOuter + r;
  }
  return a;
}
o(Rg, "printObjectProperties");
var KG = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621, Za = " ", XG = /* @__PURE__ */ o((e, t, r, n, i, s) => {
  let a = e.toString();
  if (a === "ArrayContaining" || a === "ArrayNotContaining")
    return ++n > t.maxDepth ? `[${a}]` : `${a + Za}[${tl(e.sample, t, r, n, i, s)}]`;
  if (a === "ObjectContaining" || a === "ObjectNotContaining")
    return ++n > t.maxDepth ? `[${a}]` : `${a + Za}{${Rg(e.sample, t, r, n, i, s)}}`;
  if (a === "StringMatching" || a === "StringNotMatching" || a === "StringContaining" || a === "StringNotContaining")
    return a + Za + s(e.sample, t, r, n, i);
  if (typeof e.toAsymmetricMatcher != "function")
    throw new TypeError(`Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`);
  return e.toAsymmetricMatcher();
}, "serialize$5"), JG = /* @__PURE__ */ o((e) => e && e.$$typeof === KG, "test$5"), QG = {
  serialize: XG,
  test: JG
}, ZG = " ", S_ = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]), e4 = /^(?:HTML\w*Collection|NodeList)$/;
function t4(e) {
  return S_.has(e) || e4.test(e);
}
o(t4, "testName");
var r4 = /* @__PURE__ */ o((e) => e && e.constructor && !!e.constructor.name && t4(e.constructor.name), "test$4");
function n4(e) {
  return e.constructor.name === "NamedNodeMap";
}
o(n4, "isNamedNodeMap");
var o4 = /* @__PURE__ */ o((e, t, r, n, i, s) => {
  let a = e.constructor.name;
  return ++n > t.maxDepth ? `[${a}]` : (t.min ? "" : a + ZG) + (S_.has(a) ? `{${Rg(n4(e) ? [...e].reduce(
    (l, u) => (l[u.name] = u.value, l),
    {}
  ) : { ...e }, t, r, n, i, s)}}` : `[${tl([...e], t, r, n, i, s)}]`);
}, "serialize$4"), i4 = {
  serialize: o4,
  test: r4
};
function __(e) {
  return e.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
o(__, "escapeHTML");
function Sg(e, t, r, n, i, s, a) {
  let l = n + r.indent, u = r.colors;
  return e.map((c) => {
    let d = t[c], p = a(d, r, l, i, s);
    return typeof d != "string" && (p.includes(`
`) && (p = r.spacingOuter + l + p + r.spacingOuter + n), p = `{${p}}`), `${r.spacingInner + n + u.prop.open + c + u.prop.close}=${u.value.open}${p}${u.value.close}`;
  }).join("");
}
o(Sg, "printProps");
function _g(e, t, r, n, i, s) {
  return e.map((a) => t.spacingOuter + r + (typeof a == "string" ? C_(a, t) : s(a, t, r, n, i))).join("");
}
o(_g, "printChildren");
function C_(e, t) {
  let r = t.colors.content;
  return r.open + __(e) + r.close;
}
o(C_, "printText");
function s4(e, t) {
  let r = t.colors.comment;
  return `${r.open}<!--${__(e)}-->${r.close}`;
}
o(s4, "printComment");
function Cg(e, t, r, n, i) {
  let s = n.colors.tag;
  return `${s.open}<${e}${t && s.close + t + n.spacingOuter + i + s.open}${r ? `>${s.close}${r}${n.spacingOuter}${i}${s.open}</${e}` : `${t && !n.min ? "" : " "}/`}>${s.close}`;
}
o(Cg, "printElement");
function Pg(e, t) {
  let r = t.colors.tag;
  return `${r.open}<${e}${r.close} ${r.open} />${r.close}`;
}
o(Pg, "printElementAsLeaf");
var a4 = 1, P_ = 3, A_ = 8, O_ = 11, l4 = /^(?:(?:HTML|SVG)\w*)?Element$/;
function u4(e) {
  try {
    return typeof e.hasAttribute == "function" && e.hasAttribute("is");
  } catch {
    return false;
  }
}
o(u4, "testHasAttribute");
function c4(e) {
  let t = e.constructor.name, { nodeType: r, tagName: n } = e, i = typeof n == "string" && n.includes("-") || u4(e);
  return r === a4 && (l4.test(t) || i) || r === P_ && t === "Text" || r === A_ && t === "Comment" || r === O_ && t === "DocumentFragment";
}
o(c4, "testNode");
var d4 = /* @__PURE__ */ o((e) => {
  var t;
  return (e == null || (t = e.constructor) === null || t === void 0 ? void 0 : t.name) && c4(e);
}, "test$3");
function p4(e) {
  return e.nodeType === P_;
}
o(p4, "nodeIsText");
function f4(e) {
  return e.nodeType === A_;
}
o(f4, "nodeIsComment");
function vg(e) {
  return e.nodeType === O_;
}
o(vg, "nodeIsFragment");
var m4 = /* @__PURE__ */ o((e, t, r, n, i, s) => {
  if (p4(e))
    return C_(e.data, t);
  if (f4(e))
    return s4(e.data, t);
  let a = vg(e) ? "DocumentFragment" : e.tagName.toLowerCase();
  return ++n > t.maxDepth ? Pg(a, t) : Cg(a, Sg(vg(e) ? [] : Array.from(e.attributes, (l) => l.name).sort(), vg(e) ? {} : [...e.attributes].reduce((l, u) => (l[u.name] = u.value, l), {}), t, r + t.indent, n, i, s), _g(Array.prototype.slice.call(e.childNodes || e.children), t, r + t.indent, n, i, s), t, r);
}, "serialize$3"), h4 = {
  serialize: m4,
  test: d4
}, y4 = "@@__IMMUTABLE_ITERABLE__@@", b4 = "@@__IMMUTABLE_LIST__@@", g4 = "@@__IMMUTABLE_KEYED__@@", v4 = "@@__IMMUTABLE_MAP__@@", p_ = "@@__IMMUTABLE_ORDERED__@@", E4 = "@@__IMMUTABLE_RECORD__@@", x4 = "@@__IMMUTABLE_SEQ__@@", w4 = "@@__IMMUTABLE_SET__@@", T4 = "@@__IMMUTABLE_STACK__@@", xo = /* @__PURE__ */ o((e) => `Immutable.${e}`, "getImmutableName"), nl = /* @__PURE__ */ o((e) => `[${e}]`, "printAsLeaf"), Gi = " ", f_ = "";
function R4(e, t, r, n, i, s, a) {
  return ++n > t.maxDepth ? nl(xo(a)) : `${xo(a) + Gi}{${Wi(e.entries(), t, r, n, i, s)}}`;
}
o(R4, "printImmutableEntries");
function S4(e) {
  let t = 0;
  return { next() {
    if (t < e._keys.length) {
      let r = e._keys[t++];
      return {
        done: false,
        value: [r, e.get(r)]
      };
    }
    return {
      done: true,
      value: void 0
    };
  } };
}
o(S4, "getRecordEntries");
function _4(e, t, r, n, i, s) {
  let a = xo(e._name || "Record");
  return ++n > t.maxDepth ? nl(a) : `${a + Gi}{${Wi(S4(e), t, r, n, i, s)}}`;
}
o(_4, "printImmutableRecord");
function C4(e, t, r, n, i, s) {
  let a = xo("Seq");
  return ++n > t.maxDepth ? nl(a) : e[g4] ? `${a + Gi}{${e._iter || e._object ? Wi(e.entries(), t, r, n, i, s) : f_}}` : `${a + Gi}[${e._iter || e._array || e._collection || e._iterable ? Tg(e.values(), t, r, n, i, s) : f_}]`;
}
o(C4, "printImmutableSeq");
function Eg(e, t, r, n, i, s, a) {
  return ++n > t.maxDepth ? nl(xo(a)) : `${xo(a) + Gi}[${Tg(e.values(), t, r, n, i, s)}]`;
}
o(Eg, "printImmutableValues");
var P4 = /* @__PURE__ */ o((e, t, r, n, i, s) => e[v4] ? R4(e, t, r, n, i, s, e[p_] ? "OrderedMap" : "Map") : e[b4] ? Eg(e, t, r, n, i, s, "List") : e[w4] ? Eg(e, t, r, n, i, s, e[p_] ? "OrderedSet" : "Set") : e[T4] ? Eg(e, t, r, n, i, s, "Stack") : e[x4] ? C4(e, t, r, n, i, s) : _4(e, t, r, n, i, s), "serialize$2"), A4 = /* @__PURE__ */ o((e) => e && (e[y4] === true || e[E4] === true), "test$2"), O4 = {
  serialize: P4,
  test: A4
};
function q_(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
o(q_, "getDefaultExportFromCjs");
var xg = { exports: {} }, he = {};
var m_;
function q4() {
  if (m_) return he;
  m_ = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.consumer"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.view_transition"), m = Symbol.for("react.client.reference");
  function h(b) {
    if (typeof b == "object" && b !== null) {
      var v = b.$$typeof;
      switch (v) {
        case e:
          switch (b = b.type, b) {
            case r:
            case i:
            case n:
            case u:
            case c:
            case f:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case a:
                case l:
                case p:
                case d:
                  return b;
                case s:
                  return b;
                default:
                  return v;
              }
          }
        case t:
          return v;
      }
    }
  }
  return o(h, "typeOf"), he.ContextConsumer = s, he.ContextProvider = a, he.Element = e, he.ForwardRef = l, he.Fragment = r, he.Lazy = p, he.Memo = d, he.Portal = t, he.Profiler = i, he.StrictMode = n, he.Suspense = u, he.SuspenseList = c, he.isContextConsumer = function(b) {
    return h(b) === s;
  }, he.isContextProvider = function(b) {
    return h(b) === a;
  }, he.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === e;
  }, he.isForwardRef = function(b) {
    return h(b) === l;
  }, he.isFragment = function(b) {
    return h(b) === r;
  }, he.isLazy = function(b) {
    return h(b) === p;
  }, he.isMemo = function(b) {
    return h(b) === d;
  }, he.isPortal = function(b) {
    return h(b) === t;
  }, he.isProfiler = function(b) {
    return h(b) === i;
  }, he.isStrictMode = function(b) {
    return h(b) === n;
  }, he.isSuspense = function(b) {
    return h(b) === u;
  }, he.isSuspenseList = function(b) {
    return h(b) === c;
  }, he.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === r || b === i || b === n || b === u || b === c || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === d || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || b.$$typeof === m || b.getModuleId !== void 0);
  }, he.typeOf = h, he;
}
o(q4, "requireReactIs_production");
var h_;
function I4() {
  return h_ || (h_ = 1, xg.exports = q4()), xg.exports;
}
o(I4, "requireReactIs$1");
var I_ = I4(), M4 = /* @__PURE__ */ q_(I_), N4 = /* @__PURE__ */ R_({
  __proto__: null,
  default: M4
}, [I_]), wg = { exports: {} }, fe = {};
var y_;
function j4() {
  if (y_) return fe;
  y_ = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.server_context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), h;
  h = Symbol.for("react.module.reference");
  function b(v) {
    if (typeof v == "object" && v !== null) {
      var g = v.$$typeof;
      switch (g) {
        case e:
          switch (v = v.type, v) {
            case r:
            case i:
            case n:
            case c:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case l:
                case a:
                case u:
                case f:
                case p:
                case s:
                  return v;
                default:
                  return g;
              }
          }
        case t:
          return g;
      }
    }
  }
  return o(b, "v"), fe.ContextConsumer = a, fe.ContextProvider = s, fe.Element = e, fe.ForwardRef = u, fe.Fragment = r, fe.Lazy = f, fe.Memo = p, fe.Portal = t, fe.Profiler = i, fe.StrictMode = n, fe.Suspense = c, fe.SuspenseList = d, fe.isAsyncMode = function() {
    return false;
  }, fe.isConcurrentMode = function() {
    return false;
  }, fe.isContextConsumer = function(v) {
    return b(v) === a;
  }, fe.isContextProvider = function(v) {
    return b(v) === s;
  }, fe.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, fe.isForwardRef = function(v) {
    return b(v) === u;
  }, fe.isFragment = function(v) {
    return b(v) === r;
  }, fe.isLazy = function(v) {
    return b(v) === f;
  }, fe.isMemo = function(v) {
    return b(v) === p;
  }, fe.isPortal = function(v) {
    return b(v) === t;
  }, fe.isProfiler = function(v) {
    return b(v) === i;
  }, fe.isStrictMode = function(v) {
    return b(v) === n;
  }, fe.isSuspense = function(v) {
    return b(v) === c;
  }, fe.isSuspenseList = function(v) {
    return b(v) === d;
  }, fe.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === i || v === n || v === c || v === d || v === m || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === p || v.$$typeof === s || v.$$typeof === a || v.$$typeof === u || v.$$typeof === h || v.getModuleId !== void 0);
  }, fe.typeOf = b, fe;
}
o(j4, "requireReactIs_production_min");
var b_;
function k4() {
  return b_ || (b_ = 1, wg.exports = j4()), wg.exports;
}
o(k4, "requireReactIs");
var M_ = k4(), L4 = /* @__PURE__ */ q_(M_), F4 = /* @__PURE__ */ R_({
  __proto__: null,
  default: L4
}, [M_]), D4 = [
  "isAsyncMode",
  "isConcurrentMode",
  "isContextConsumer",
  "isContextProvider",
  "isElement",
  "isForwardRef",
  "isFragment",
  "isLazy",
  "isMemo",
  "isPortal",
  "isProfiler",
  "isStrictMode",
  "isSuspense",
  "isSuspenseList",
  "isValidElementType"
], vn = Object.fromEntries(D4.map((e) => [e, (t) => F4[e](t) || N4[e](t)]));
function N_(e, t = []) {
  if (Array.isArray(e))
    for (let r of e)
      N_(r, t);
  else e != null && e !== false && e !== "" && t.push(e);
  return t;
}
o(N_, "getChildren");
function g_(e) {
  let t = e.type;
  if (typeof t == "string")
    return t;
  if (typeof t == "function")
    return t.displayName || t.name || "Unknown";
  if (vn.isFragment(e))
    return "React.Fragment";
  if (vn.isSuspense(e))
    return "React.Suspense";
  if (typeof t == "object" && t !== null) {
    if (vn.isContextProvider(e))
      return "Context.Provider";
    if (vn.isContextConsumer(e))
      return "Context.Consumer";
    if (vn.isForwardRef(e)) {
      if (t.displayName)
        return t.displayName;
      let r = t.render.displayName || t.render.name || "";
      return r === "" ? "ForwardRef" : `ForwardRef(${r})`;
    }
    if (vn.isMemo(e)) {
      let r = t.displayName || t.type.displayName || t.type.name || "";
      return r === "" ? "Memo" : `Memo(${r})`;
    }
  }
  return "UNDEFINED";
}
o(g_, "getType");
function $4(e) {
  let { props: t } = e;
  return Object.keys(t).filter((r) => r !== "children" && t[r] !== void 0).sort();
}
o($4, "getPropKeys$1");
var B4 = /* @__PURE__ */ o((e, t, r, n, i, s) => ++n > t.maxDepth ? Pg(g_(e), t) : Cg(g_(e), Sg($4(e), e.props, t, r + t.indent, n, i, s), _g(
  N_(e.props.children),
  t,
  r + t.indent,
  n,
  i,
  s
), t, r), "serialize$1"), H4 = /* @__PURE__ */ o((e) => e != null && vn.isElement(e), "test$1"), U4 = {
  serialize: B4,
  test: H4
}, V4 = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function z4(e) {
  let { props: t } = e;
  return t ? Object.keys(t).filter((r) => t[r] !== void 0).sort() : [];
}
o(z4, "getPropKeys");
var G4 = /* @__PURE__ */ o((e, t, r, n, i, s) => ++n > t.maxDepth ? Pg(e.type, t) : Cg(e.type, e.props ? Sg(
  z4(e),
  e.props,
  t,
  r + t.indent,
  n,
  i,
  s
) : "", e.children ? _g(e.children, t, r + t.indent, n, i, s) : "", t, r), "serialize"), W4 = /* @__PURE__ */ o((e) => e && e.$$typeof === V4, "test"), Y4 = {
  serialize: G4,
  test: W4
}, j_ = Object.prototype.toString, K4 = Date.prototype.toISOString, X4 = Error.prototype.toString, v_ = RegExp.prototype.toString;
function el(e) {
  return typeof e.constructor == "function" && e.constructor.name || "Object";
}
o(el, "getConstructorName");
function J4(e) {
  return typeof window < "u" && e === window;
}
o(J4, "isWindow");
var Q4 = /^Symbol\((.*)\)(.*)$/, Z4 = /\n/g, Og = class Og2 extends Error {
  constructor(t, r) {
    super(t), this.stack = r, this.name = this.constructor.name;
  }
};
o(Og, "PrettyFormatPluginError");
var rl = Og;
function e6(e) {
  return e === "[object Array]" || e === "[object ArrayBuffer]" || e === "[object DataView]" || e === "[object Float32Array]" || e === "[object Float64Array]" || e === "[object Int8Array]" || e === "[object Int16Array]" || e === "[object Int32Array]" || e === "[object Uint8Array]" || e === "[object Uint8ClampedArray]" || e === "[object Uint16Array]" || e === "[object Uint32Array]";
}
o(e6, "isToStringedArrayType");
function t6(e) {
  return Object.is(e, -0) ? "-0" : String(e);
}
o(t6, "printNumber");
function r6(e) {
  return `${e}n`;
}
o(r6, "printBigInt");
function E_(e, t) {
  return t ? `[Function ${e.name || "anonymous"}]` : "[Function]";
}
o(E_, "printFunction");
function x_(e) {
  return String(e).replace(Q4, "Symbol($1)");
}
o(x_, "printSymbol");
function w_(e) {
  return `[${X4.call(e)}]`;
}
o(w_, "printError");
function k_(e, t, r, n) {
  if (e === true || e === false)
    return `${e}`;
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  let i = typeof e;
  if (i === "number")
    return t6(e);
  if (i === "bigint")
    return r6(e);
  if (i === "string")
    return n ? `"${e.replaceAll(/"|\\/g, "\\$&")}"` : `"${e}"`;
  if (i === "function")
    return E_(e, t);
  if (i === "symbol")
    return x_(e);
  let s = j_.call(e);
  return s === "[object WeakMap]" ? "WeakMap {}" : s === "[object WeakSet]" ? "WeakSet {}" : s === "[object Function]" || s === "[object GeneratorFunction]" ? E_(e, t) : s === "[object Symbol]" ? x_(e) : s === "[object Date]" ? Number.isNaN(+e) ? "Date { NaN }" : K4.call(e) : s === "[object Error]" ? w_(e) : s === "[object RegExp]" ? r ? v_.call(e).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : v_.call(e) : e instanceof Error ? w_(e) : null;
}
o(k_, "printBasicValue");
function L_(e, t, r, n, i, s) {
  if (i.includes(e))
    return "[Circular]";
  i = [...i], i.push(e);
  let a = ++n > t.maxDepth, l = t.min;
  if (t.callToJSON && !a && e.toJSON && typeof e.toJSON == "function" && !s)
    return Mr$1(e.toJSON(), t, r, n, i, true);
  let u = j_.call(e);
  return u === "[object Arguments]" ? a ? "[Arguments]" : `${l ? "" : "Arguments "}[${tl(e, t, r, n, i, Mr$1)}]` : e6(u) ? a ? `[${e.constructor.name}]` : `${l || !t.printBasicPrototype && e.constructor.name === "Array" ? "" : `${e.constructor.name} `}[${tl(e, t, r, n, i, Mr$1)}]` : u === "[object Map]" ? a ? "[Map]" : `Map {${Wi(e.entries(), t, r, n, i, Mr$1, " => ")}}` : u === "[object Set]" ? a ? "[Set]" : `Set {${Tg(
    e.values(),
    t,
    r,
    n,
    i,
    Mr$1
  )}}` : a || J4(e) ? `[${el(e)}]` : `${l || !t.printBasicPrototype && el(e) === "Object" ? "" : `${el(e)} `}{${Rg(
    e,
    t,
    r,
    n,
    i,
    Mr$1
  )}}`;
}
o(L_, "printComplexValue");
var n6 = {
  test: /* @__PURE__ */ o((e) => e && e instanceof Error, "test"),
  serialize(e, t, r, n, i, s) {
    if (i.includes(e))
      return "[Circular]";
    i = [...i, e];
    let a = ++n > t.maxDepth, { message: l, cause: u, ...c } = e, d = {
      message: l,
      ...typeof u < "u" ? { cause: u } : {},
      ...e instanceof AggregateError ? { errors: e.errors } : {},
      ...c
    }, p = e.name !== "Error" ? e.name : el(e);
    return a ? `[${p}]` : `${p} {${Wi(Object.entries(d).values(), t, r, n, i, s)}}`;
  }
};
function o6(e) {
  return e.serialize != null;
}
o(o6, "isNewPlugin");
function F_(e, t, r, n, i, s) {
  let a;
  try {
    a = o6(e) ? e.serialize(t, r, n, i, s, Mr$1) : e.print(t, (l) => Mr$1(l, r, n, i, s), (l) => {
      let u = n + r.indent;
      return u + l.replaceAll(Z4, `
${u}`);
    }, {
      edgeSpacing: r.spacingOuter,
      min: r.min,
      spacing: r.spacingInner
    }, r.colors);
  } catch (l) {
    throw new rl(l.message, l.stack);
  }
  if (typeof a != "string")
    throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof a}".`);
  return a;
}
o(F_, "printPlugin");
function D_(e, t) {
  for (let r of e)
    try {
      if (r.test(t))
        return r;
    } catch (n) {
      throw new rl(n.message, n.stack);
    }
  return null;
}
o(D_, "findPlugin");
function Mr$1(e, t, r, n, i, s) {
  let a = D_(t.plugins, e);
  if (a !== null)
    return F_(a, e, t, r, n, i);
  let l = k_(e, t.printFunctionName, t.escapeRegex, t.escapeString);
  return l !== null ? l : L_(e, t, r, n, i, s);
}
o(Mr$1, "printer");
var Ag = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
}, $_ = Object.keys(Ag), Lt = {
  callToJSON: true,
  compareKeys: void 0,
  escapeRegex: false,
  escapeString: true,
  highlight: false,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: false,
  plugins: [],
  printBasicPrototype: true,
  printFunctionName: true,
  theme: Ag
};
function i6(e) {
  for (let t of Object.keys(e))
    if (!Object.prototype.hasOwnProperty.call(Lt, t))
      throw new Error(`pretty-format: Unknown option "${t}".`);
  if (e.min && e.indent !== void 0 && e.indent !== 0)
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
o(i6, "validateOptions");
function s6() {
  return $_.reduce((e, t) => {
    let r = Ag[t], n = r && Ee[r];
    if (n && typeof n.close == "string" && typeof n.open == "string")
      e[t] = n;
    else
      throw new Error(`pretty-format: Option "theme" has a key "${t}" whose value "${r}" is undefined in ansi-styles.`);
    return e;
  }, /* @__PURE__ */ Object.create(null));
}
o(s6, "getColorsHighlight");
function a6() {
  return $_.reduce((e, t) => (e[t] = {
    close: "",
    open: ""
  }, e), /* @__PURE__ */ Object.create(null));
}
o(a6, "getColorsEmpty");
function B_(e) {
  return e?.printFunctionName ?? Lt.printFunctionName;
}
o(B_, "getPrintFunctionName");
function H_(e) {
  return e?.escapeRegex ?? Lt.escapeRegex;
}
o(H_, "getEscapeRegex");
function U_(e) {
  return e?.escapeString ?? Lt.escapeString;
}
o(U_, "getEscapeString");
function T_(e) {
  return {
    callToJSON: e?.callToJSON ?? Lt.callToJSON,
    colors: e?.highlight ? s6() : a6(),
    compareKeys: typeof e?.compareKeys == "function" || e?.compareKeys === null ? e.compareKeys : Lt.compareKeys,
    escapeRegex: H_(e),
    escapeString: U_(e),
    indent: e?.min ? "" : l6(e?.indent ?? Lt.indent),
    maxDepth: e?.maxDepth ?? Lt.maxDepth,
    maxWidth: e?.maxWidth ?? Lt.maxWidth,
    min: e?.min ?? Lt.min,
    plugins: e?.plugins ?? Lt.plugins,
    printBasicPrototype: e?.printBasicPrototype ?? true,
    printFunctionName: B_(e),
    spacingInner: e?.min ? " " : `
`,
    spacingOuter: e?.min ? "" : `
`
  };
}
o(T_, "getConfig");
function l6(e) {
  return Array.from({ length: e + 1 }).join(" ");
}
o(l6, "createIndent");
function St$1(e, t) {
  if (t && (i6(t), t.plugins)) {
    let n = D_(t.plugins, e);
    if (n !== null)
      return F_(n, e, T_(t), "", 0, []);
  }
  let r = k_(e, B_(t), H_(t), U_(t));
  return r !== null ? r : L_(e, T_(t), "", 0, []);
}
o(St$1, "format");
var Yi = {
  AsymmetricMatcher: QG,
  DOMCollection: i4,
  DOMElement: h4,
  Immutable: O4,
  ReactElement: U4,
  ReactTestComponent: Y4,
  Error: n6
};
var V_ = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, u6 = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, pr = "";
function c6(e, t) {
  let r = V_[u6[t]] || V_[t] || "";
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
o(c6, "colorise");
function z_({
  showHidden: e = false,
  depth: t = 2,
  colors: r = false,
  customInspect: n = true,
  showProxy: i = false,
  maxArrayLength: s = 1 / 0,
  breakLength: a = 1 / 0,
  seen: l = [],
  // eslint-disable-next-line no-shadow
  truncate: u = 1 / 0,
  stylize: c = String
} = {}, d) {
  let p = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!i,
    maxArrayLength: Number(s),
    breakLength: Number(a),
    truncate: Number(u),
    seen: l,
    inspect: d,
    stylize: c
  };
  return p.colors && (p.stylize = c6), p;
}
o(z_, "normaliseOptions");
function d6(e) {
  return e >= "\uD800" && e <= "\uDBFF";
}
o(d6, "isHighSurrogate");
function et(e, t, r = pr) {
  e = String(e);
  let n = r.length, i = e.length;
  if (n > t && i > n)
    return r;
  if (i > t && i > n) {
    let s = t - n;
    return s > 0 && d6(e[s - 1]) && (s = s - 1), `${e.slice(0, s)}${r}`;
  }
  return e;
}
o(et, "truncate");
function Fe$1(e, t, r, n = ", ") {
  r = r || t.inspect;
  let i = e.length;
  if (i === 0)
    return "";
  let s = t.truncate, a = "", l = "", u = "";
  for (let c = 0; c < i; c += 1) {
    let d = c + 1 === e.length, p = c + 2 === e.length;
    u = `${pr}(${e.length - c})`;
    let f = e[c];
    t.truncate = s - a.length - (d ? 0 : n.length);
    let m = l || r(f, t) + (d ? "" : n), h = a.length + m.length, b = h + u.length;
    if (d && h > s && a.length + u.length <= s || !d && !p && b > s || (l = d ? "" : r(e[c + 1], t) + (p ? "" : n), !d && p && b > s && h + l.length > s))
      break;
    if (a += m, !d && !p && h + l.length >= s) {
      u = `${pr}(${e.length - c - 1})`;
      break;
    }
    u = "";
  }
  return `${a}${u}`;
}
o(Fe$1, "inspectList");
function p6(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? e : JSON.stringify(e).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
o(p6, "quoteComplexKey");
function fr([e, t], r) {
  return r.truncate -= 2, typeof e == "string" ? e = p6(e) : typeof e != "number" && (e = `[${r.inspect(e, r)}]`), r.truncate -= e.length, t = r.inspect(t, r), `${e}: ${t}`;
}
o(fr, "inspectProperty");
function qg(e, t) {
  let r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length)
    return "[]";
  t.truncate -= 4;
  let n = Fe$1(e, t);
  t.truncate -= n.length;
  let i = "";
  return r.length && (i = Fe$1(r.map((s) => [s, e[s]]), t, fr)), `[ ${n}${i ? `, ${i}` : ""} ]`;
}
o(qg, "inspectArray");
var f6 = /* @__PURE__ */ o((e) => typeof Buffer == "function" && e instanceof Buffer ? "Buffer" : e[Symbol.toStringTag] ? e[Symbol.toStringTag] : e.constructor.name, "getArrayName");
function Ft(e, t) {
  let r = f6(e);
  t.truncate -= r.length + 4;
  let n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length)
    return `${r}[]`;
  let i = "";
  for (let a = 0; a < e.length; a++) {
    let l = `${t.stylize(et(e[a], t.truncate), "number")}${a === e.length - 1 ? "" : ", "}`;
    if (t.truncate -= l.length, e[a] !== e.length && t.truncate <= 3) {
      i += `${pr}(${e.length - e[a] + 1})`;
      break;
    }
    i += l;
  }
  let s = "";
  return n.length && (s = Fe$1(n.map((a) => [a, e[a]]), t, fr)), `${r}[ ${i}${s ? `, ${s}` : ""} ]`;
}
o(Ft, "inspectTypedArray");
function Ig(e, t) {
  let r = e.toJSON();
  if (r === null)
    return "Invalid Date";
  let n = r.split("T"), i = n[0];
  return t.stylize(`${i}T${et(n[1], t.truncate - i.length - 1)}`, "date");
}
o(Ig, "inspectDate");
function ol(e, t) {
  let r = e[Symbol.toStringTag] || "Function", n = e.name;
  return n ? t.stylize(`[${r} ${et(n, t.truncate - 11)}]`, "special") : t.stylize(`[${r}]`, "special");
}
o(ol, "inspectFunction");
function m6([e, t], r) {
  return r.truncate -= 4, e = r.inspect(e, r), r.truncate -= e.length, t = r.inspect(t, r), `${e} => ${t}`;
}
o(m6, "inspectMapEntry");
function h6(e) {
  let t = [];
  return e.forEach((r, n) => {
    t.push([n, r]);
  }), t;
}
o(h6, "mapToEntries");
function Mg(e, t) {
  return e.size === 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${Fe$1(h6(e), t, m6)} }`);
}
o(Mg, "inspectMap");
var y6 = Number.isNaN || ((e) => e !== e);
function il(e, t) {
  return y6(e) ? t.stylize("NaN", "number") : e === 1 / 0 ? t.stylize("Infinity", "number") : e === -1 / 0 ? t.stylize("-Infinity", "number") : e === 0 ? t.stylize(1 / e === 1 / 0 ? "+0" : "-0", "number") : t.stylize(et(String(e), t.truncate), "number");
}
o(il, "inspectNumber");
function sl(e, t) {
  let r = et(e.toString(), t.truncate - 1);
  return r !== pr && (r += "n"), t.stylize(r, "bigint");
}
o(sl, "inspectBigInt");
function Ng(e, t) {
  let r = e.toString().split("/")[2], n = t.truncate - (2 + r.length), i = e.source;
  return t.stylize(`/${et(i, n)}/${r}`, "regexp");
}
o(Ng, "inspectRegExp");
function b6(e) {
  let t = [];
  return e.forEach((r) => {
    t.push(r);
  }), t;
}
o(b6, "arrayFromSet");
function jg(e, t) {
  return e.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${Fe$1(b6(e), t)} }`);
}
o(jg, "inspectSet");
var G_ = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), g6 = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, v6 = 16, E6 = 4;
function x6(e) {
  return g6[e] || `\\u${`0000${e.charCodeAt(0).toString(v6)}`.slice(-E6)}`;
}
o(x6, "escape");
function al(e, t) {
  return G_.test(e) && (e = e.replace(G_, x6)), t.stylize(`'${et(e, t.truncate - 2)}'`, "string");
}
o(al, "inspectString");
function ll(e) {
  return "description" in Symbol.prototype ? e.description ? `Symbol(${e.description})` : "Symbol()" : e.toString();
}
o(ll, "inspectSymbol");
var W_ = /* @__PURE__ */ o(() => "Promise{}", "getPromiseValue");
try {
  let { getPromiseDetails: e, kPending: t, kRejected: r } = process.binding("util");
  Array.isArray(e(Promise.resolve())) && (W_ = /* @__PURE__ */ o((n, i) => {
    let [s, a] = e(n);
    return s === t ? "Promise{<pending>}" : `Promise${s === r ? "!" : ""}{${i.inspect(a, i)}}`;
  }, "getPromiseValue"));
} catch {
}
var Y_ = W_;
function En(e, t) {
  let r = Object.getOwnPropertyNames(e), n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  let i = Fe$1(r.map((l) => [l, e[l]]), t, fr), s = Fe$1(n.map((l) => [l, e[l]]), t, fr);
  t.seen.pop();
  let a = "";
  return i && s && (a = ", "), `{ ${i}${a}${s} }`;
}
o(En, "inspectObject");
var kg = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : false;
function Lg(e, t) {
  let r = "";
  return kg && kg in e && (r = e[kg]), r = r || e.constructor.name, (!r || r === "_class") && (r = "<Anonymous Class>"), t.truncate -= r.length, `${r}${En(e, t)}`;
}
o(Lg, "inspectClass");
function Fg(e, t) {
  return e.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${Fe$1(e, t)} ]`);
}
o(Fg, "inspectArguments");
var w6 = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function Dg(e, t) {
  let r = Object.getOwnPropertyNames(e).filter((a) => w6.indexOf(a) === -1), n = e.name;
  t.truncate -= n.length;
  let i = "";
  if (typeof e.message == "string" ? i = et(e.message, t.truncate) : r.unshift("message"), i = i ? `: ${i}` : "", t.truncate -= i.length + 5, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  let s = Fe$1(r.map((a) => [a, e[a]]), t, fr);
  return `${n}${i}${s ? ` { ${s} }` : ""}`;
}
o(Dg, "inspectObject");
function T6([e, t], r) {
  return r.truncate -= 3, t ? `${r.stylize(String(e), "yellow")}=${r.stylize(`"${t}"`, "string")}` : `${r.stylize(String(e), "yellow")}`;
}
o(T6, "inspectAttribute");
function ul(e, t) {
  return Fe$1(e, t, R6, `
`);
}
o(ul, "inspectNodeCollection");
function R6(e, t) {
  switch (e.nodeType) {
    case 1:
      return cl(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
o(R6, "inspectNode");
function cl(e, t) {
  let r = e.getAttributeNames(), n = e.tagName.toLowerCase(), i = t.stylize(`<${n}`, "special"), s = t.stylize(">", "special"), a = t.stylize(
    `</${n}>`,
    "special"
  );
  t.truncate -= n.length * 2 + 5;
  let l = "";
  r.length > 0 && (l += " ", l += Fe$1(r.map((d) => [d, e.getAttribute(d)]), t, T6, " ")), t.truncate -= l.length;
  let u = t.truncate, c = ul(e.children, t);
  return c && c.length > u && (c = `${pr}(${e.children.length})`), `${i}${l}${s}${c}${a}`;
}
o(cl, "inspectHTML");
var S6 = typeof Symbol == "function" && typeof Symbol.for == "function", $g = S6 ? Symbol.for("chai/inspect") : "@@chai/inspect", Bg = Symbol.for("nodejs.util.inspect.custom"), K_ = /* @__PURE__ */ new WeakMap(), X_ = {}, J_ = {
  undefined: /* @__PURE__ */ o((e, t) => t.stylize("undefined", "undefined"), "undefined"),
  null: /* @__PURE__ */ o((e, t) => t.stylize("null", "null"), "null"),
  boolean: /* @__PURE__ */ o((e, t) => t.stylize(String(e), "boolean"), "boolean"),
  Boolean: /* @__PURE__ */ o((e, t) => t.stylize(String(e), "boolean"), "Boolean"),
  number: il,
  Number: il,
  bigint: sl,
  BigInt: sl,
  string: al,
  String: al,
  function: ol,
  Function: ol,
  symbol: ll,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: ll,
  Array: qg,
  Date: Ig,
  Map: Mg,
  Set: jg,
  RegExp: Ng,
  Promise: Y_,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: /* @__PURE__ */ o((e, t) => t.stylize("WeakSet{}", "special"), "WeakSet"),
  WeakMap: /* @__PURE__ */ o((e, t) => t.stylize("WeakMap{}", "special"), "WeakMap"),
  Arguments: Fg,
  Int8Array: Ft,
  Uint8Array: Ft,
  Uint8ClampedArray: Ft,
  Int16Array: Ft,
  Uint16Array: Ft,
  Int32Array: Ft,
  Uint32Array: Ft,
  Float32Array: Ft,
  Float64Array: Ft,
  Generator: /* @__PURE__ */ o(() => "", "Generator"),
  DataView: /* @__PURE__ */ o(() => "", "DataView"),
  ArrayBuffer: /* @__PURE__ */ o(() => "", "ArrayBuffer"),
  Error: Dg,
  HTMLCollection: ul,
  NodeList: ul
}, _6 = /* @__PURE__ */ o((e, t, r) => $g in e && typeof e[$g] == "function" ? e[$g](t) : Bg in e && typeof e[Bg] == "function" ? e[Bg](
  t.depth,
  t
) : "inspect" in e && typeof e.inspect == "function" ? e.inspect(t.depth, t) : "constructor" in e && K_.has(e.constructor) ? K_.get(e.constructor)(
  e,
  t
) : X_[r] ? X_[r](e, t) : "", "inspectCustom"), C6 = Object.prototype.toString;
function dl(e, t = {}) {
  let r = z_(t, dl), { customInspect: n } = r, i = e === null ? "null" : typeof e;
  if (i === "object" && (i = C6.call(e).slice(8, -1)), i in J_)
    return J_[i](e, r);
  if (n && e) {
    let a = _6(e, r, i);
    if (a)
      return typeof a == "string" ? a : dl(a, r);
  }
  let s = e ? Object.getPrototypeOf(e) : false;
  return s === Object.prototype || s === null ? En(e, r) : e && typeof HTMLElement == "function" && e instanceof HTMLElement ? cl(e, r) : "constructor" in e ? e.constructor !== Object ? Lg(e, r) : En(e, r) : e === Object(e) ? En(e, r) : r.stylize(String(e), i);
}
o(dl, "inspect");
var { AsymmetricMatcher: A6, DOMCollection: O6, DOMElement: q6, Immutable: I6, ReactElement: M6, ReactTestComponent: N6 } = Yi, Q_ = [
  N6,
  M6,
  q6,
  O6,
  I6,
  A6
];
function Ye(e, t = 10, { maxLength: r, ...n } = {}) {
  let i = r ?? 1e4, s;
  try {
    s = St$1(e, {
      maxDepth: t,
      escapeString: false,
      plugins: Q_,
      ...n
    });
  } catch {
    s = St$1(e, {
      callToJSON: false,
      maxDepth: t,
      escapeString: false,
      plugins: Q_,
      ...n
    });
  }
  return s.length >= i && t > 1 ? Ye(e, Math.floor(Math.min(t, Number.MAX_SAFE_INTEGER) / 2), {
    maxLength: r,
    ...n
  }) : s;
}
o(Ye, "stringify");
var j6 = /%[sdjifoOc%]/g;
function Hg(...e) {
  if (typeof e[0] != "string") {
    let s = [];
    for (let a = 0; a < e.length; a++)
      s.push(wo(e[a], {
        depth: 0,
        colors: false
      }));
    return s.join(" ");
  }
  let t = e.length, r = 1, n = e[0], i = String(n).replace(j6, (s) => {
    if (s === "%%")
      return "%";
    if (r >= t)
      return s;
    switch (s) {
      case "%s": {
        let a = e[r++];
        return typeof a == "bigint" ? `${a.toString()}n` : typeof a == "number" && a === 0 && 1 / a < 0 ? "-0" : typeof a == "object" && a !== null ? typeof a.toString == "function" && a.toString !== Object.prototype.toString ? a.toString() : wo(a, {
          depth: 0,
          colors: false
        }) : String(a);
      }
      case "%d": {
        let a = e[r++];
        return typeof a == "bigint" ? `${a.toString()}n` : Number(a).toString();
      }
      case "%i": {
        let a = e[r++];
        return typeof a == "bigint" ? `${a.toString()}n` : Number.parseInt(String(a)).toString();
      }
      case "%f":
        return Number.parseFloat(String(e[r++])).toString();
      case "%o":
        return wo(e[r++], {
          showHidden: true,
          showProxy: true
        });
      case "%O":
        return wo(e[r++]);
      case "%c":
        return r++, "";
      case "%j":
        try {
          return JSON.stringify(e[r++]);
        } catch (a) {
          let l = a.message;
          if (l.includes("circular structure") || l.includes("cyclic structures") || l.includes("cyclic object"))
            return "[Circular]";
          throw a;
        }
      default:
        return s;
    }
  });
  for (let s = e[r]; r < t; s = e[++r])
    s === null || typeof s != "object" ? i += ` ${s}` : i += ` ${wo(s)}`;
  return i;
}
o(Hg, "format");
function wo(e, t = {}) {
  return t.truncate === 0 && (t.truncate = Number.POSITIVE_INFINITY), dl(e, t);
}
o(wo, "inspect");
function Z_(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
o(Z_, "getDefaultExportFromCjs");
function Dt$1(e, t, r) {
  let n = typeof e;
  if (!r.includes(n))
    throw new TypeError(`${t} value must be ${r.join(" or ")}, received "${n}"`);
}
o(Dt$1, "assertTypes");
function To(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
o(To, "isObject");
function k6(e) {
  return e === Object.prototype || e === Function.prototype || e === RegExp.prototype;
}
o(k6, "isFinalObj");
function xn(e) {
  return Object.prototype.toString.apply(e).slice(8, -1);
}
o(xn, "getType");
function L6(e, t) {
  let r = typeof t == "function" ? t : (n) => t.add(n);
  Object.getOwnPropertyNames(e).forEach(r), Object.getOwnPropertySymbols(e).forEach(r);
}
o(L6, "collectOwnProperties");
function fl(e) {
  let t = /* @__PURE__ */ new Set();
  return k6(e) ? [] : (L6(e, t), Array.from(t));
}
o(fl, "getOwnProperties");
var eC = { forceWritable: false };
function ml(e, t = eC) {
  return pl(e, /* @__PURE__ */ new WeakMap(), t);
}
o(ml, "deepClone");
function pl(e, t, r = eC) {
  let n, i;
  if (t.has(e))
    return t.get(e);
  if (Array.isArray(e)) {
    for (i = Array.from({ length: n = e.length }), t.set(e, i); n--; )
      i[n] = pl(e[n], t, r);
    return i;
  }
  if (Object.prototype.toString.call(e) === "[object Object]") {
    i = Object.create(Object.getPrototypeOf(e)), t.set(e, i);
    let s = fl(e);
    for (let a of s) {
      let l = Object.getOwnPropertyDescriptor(e, a);
      if (!l)
        continue;
      let u = pl(e[a], t, r);
      r.forceWritable ? Object.defineProperty(i, a, {
        enumerable: l.enumerable,
        configurable: true,
        writable: true,
        value: u
      }) : "get" in l ? Object.defineProperty(i, a, {
        ...l,
        get() {
          return u;
        }
      }) : Object.defineProperty(i, a, {
        ...l,
        value: u
      });
    }
    return i;
  }
  return e;
}
o(pl, "clone");
function Ug() {
}
o(Ug, "noop");
var tt$1 = -1, Ke$1 = 1, Ie$1 = 0, Qg = class Qg2 {
  0;
  1;
  constructor(t, r) {
    this[0] = t, this[1] = r;
  }
};
o(Qg, "Diff");
var Te = Qg;
function F6(e, t) {
  if (!e || !t || e.charAt(0) !== t.charAt(0))
    return 0;
  let r = 0, n = Math.min(e.length, t.length), i = n, s = 0;
  for (; r < i; )
    e.substring(s, i) === t.substring(s, i) ? (r = i, s = r) : n = i, i = Math.floor((n - r) / 2 + r);
  return i;
}
o(F6, "diff_commonPrefix");
function yC(e, t) {
  if (!e || !t || e.charAt(e.length - 1) !== t.charAt(t.length - 1))
    return 0;
  let r = 0, n = Math.min(e.length, t.length), i = n, s = 0;
  for (; r < i; )
    e.substring(e.length - i, e.length - s) === t.substring(t.length - i, t.length - s) ? (r = i, s = r) : n = i, i = Math.floor((n - r) / 2 + r);
  return i;
}
o(yC, "diff_commonSuffix");
function tC(e, t) {
  let r = e.length, n = t.length;
  if (r === 0 || n === 0)
    return 0;
  r > n ? e = e.substring(r - n) : r < n && (t = t.substring(0, r));
  let i = Math.min(r, n);
  if (e === t)
    return i;
  let s = 0, a = 1;
  for (; ; ) {
    let l = e.substring(i - a), u = t.indexOf(l);
    if (u === -1)
      return s;
    a += u, (u === 0 || e.substring(i - a) === t.substring(0, a)) && (s = a, a++);
  }
}
o(tC, "diff_commonOverlap_");
function D6(e) {
  let t = false, r = [], n = 0, i = null, s = 0, a = 0, l = 0, u = 0, c = 0;
  for (; s < e.length; )
    e[s][0] === Ie$1 ? (r[n++] = s, a = u, l = c, u = 0, c = 0, i = e[s][1]) : (e[s][0] === Ke$1 ? u += e[s][1].length : c += e[s][1].length, i && i.length <= Math.max(a, l) && i.length <= Math.max(u, c) && (e.splice(r[n - 1], 0, new Te(tt$1, i)), e[r[n - 1] + 1][0] = Ke$1, n--, n--, s = n > 0 ? r[n - 1] : -1, a = 0, l = 0, u = 0, c = 0, i = null, t = true)), s++;
  for (t && bC(e), H6(e), s = 1; s < e.length; ) {
    if (e[s - 1][0] === tt$1 && e[s][0] === Ke$1) {
      let d = e[s - 1][1], p = e[s][1], f = tC(d, p), m = tC(p, d);
      f >= m ? (f >= d.length / 2 || f >= p.length / 2) && (e.splice(s, 0, new Te(Ie$1, p.substring(0, f))), e[s - 1][1] = d.substring(0, d.length - f), e[s + 1][1] = p.substring(f), s++) : (m >= d.length / 2 || m >= p.length / 2) && (e.splice(s, 0, new Te(Ie$1, d.substring(0, m))), e[s - 1][0] = Ke$1, e[s - 1][1] = p.substring(0, p.length - m), e[s + 1][0] = tt$1, e[s + 1][1] = d.substring(m), s++), s++;
    }
    s++;
  }
}
o(D6, "diff_cleanupSemantic");
var rC = /[^a-z0-9]/i, nC = /\s/, oC = /[\r\n]/, $6 = /\n\r?\n$/, B6 = /^\r?\n\r?\n/;
function H6(e) {
  let t = 1;
  for (; t < e.length - 1; ) {
    if (e[t - 1][0] === Ie$1 && e[t + 1][0] === Ie$1) {
      let r = e[t - 1][1], n = e[t][1], i = e[t + 1][1], s = yC(r, n);
      if (s) {
        let d = n.substring(n.length - s);
        r = r.substring(0, r.length - s), n = d + n.substring(0, n.length - s), i = d + i;
      }
      let a = r, l = n, u = i, c = hl(r, n) + hl(n, i);
      for (; n.charAt(0) === i.charAt(0); ) {
        r += n.charAt(0), n = n.substring(1) + i.charAt(0), i = i.substring(1);
        let d = hl(r, n) + hl(n, i);
        d >= c && (c = d, a = r, l = n, u = i);
      }
      e[t - 1][1] !== a && (a ? e[t - 1][1] = a : (e.splice(t - 1, 1), t--), e[t][1] = l, u ? e[t + 1][1] = u : (e.splice(t + 1, 1), t--));
    }
    t++;
  }
}
o(H6, "diff_cleanupSemanticLossless");
function bC(e) {
  e.push(new Te(Ie$1, ""));
  let t = 0, r = 0, n = 0, i = "", s = "", a;
  for (; t < e.length; )
    switch (e[t][0]) {
      case Ke$1:
        n++, s += e[t][1], t++;
        break;
      case tt$1:
        r++, i += e[t][1], t++;
        break;
      case Ie$1:
        r + n > 1 ? (r !== 0 && n !== 0 && (a = F6(s, i), a !== 0 && (t - r - n > 0 && e[t - r - n - 1][0] === Ie$1 ? e[t - r - n - 1][1] += s.substring(0, a) : (e.splice(0, 0, new Te(Ie$1, s.substring(0, a))), t++), s = s.substring(a), i = i.substring(a)), a = yC(s, i), a !== 0 && (e[t][1] = s.substring(s.length - a) + e[t][1], s = s.substring(0, s.length - a), i = i.substring(0, i.length - a))), t -= r + n, e.splice(t, r + n), i.length && (e.splice(t, 0, new Te(tt$1, i)), t++), s.length && (e.splice(t, 0, new Te(Ke$1, s)), t++), t++) : t !== 0 && e[t - 1][0] === Ie$1 ? (e[t - 1][1] += e[t][1], e.splice(t, 1)) : t++, n = 0, r = 0, i = "", s = "";
        break;
    }
  e[e.length - 1][1] === "" && e.pop();
  let l = false;
  for (t = 1; t < e.length - 1; )
    e[t - 1][0] === Ie$1 && e[t + 1][0] === Ie$1 && (e[t][1].substring(e[t][1].length - e[t - 1][1].length) === e[t - 1][1] ? (e[t][1] = e[t - 1][1] + e[t][1].substring(0, e[t][1].length - e[t - 1][1].length), e[t + 1][1] = e[t - 1][1] + e[t + 1][1], e.splice(t - 1, 1), l = true) : e[t][1].substring(0, e[t + 1][1].length) === e[t + 1][1] && (e[t - 1][1] += e[t + 1][1], e[t][1] = e[t][1].substring(e[t + 1][1].length) + e[t + 1][1], e.splice(t + 1, 1), l = true)), t++;
  l && bC(e);
}
o(bC, "diff_cleanupMerge");
function hl(e, t) {
  if (!e || !t)
    return 6;
  let r = e.charAt(e.length - 1), n = t.charAt(0), i = r.match(rC), s = n.match(rC), a = i && r.match(nC), l = s && n.match(nC), u = a && r.match(oC), c = l && n.match(oC), d = u && e.match($6), p = c && t.match(B6);
  return d || p ? 5 : u || c ? 4 : i && !a && l ? 3 : a || l ? 2 : i || s ? 1 : 0;
}
o(hl, "diff_cleanupSemanticScore_");
var gC = "Compared values have no visual difference.", U6 = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.", yl = {}, iC;
function V6() {
  if (iC) return yl;
  iC = 1, Object.defineProperty(yl, "__esModule", {
    value: true
  }), yl.default = f;
  let e = "diff-sequences", t = 0, r = /* @__PURE__ */ o((m, h, b, v, g) => {
    let w = 0;
    for (; m < h && b < v && g(m, b); )
      m += 1, b += 1, w += 1;
    return w;
  }, "countCommonItemsF"), n = /* @__PURE__ */ o((m, h, b, v, g) => {
    let w = 0;
    for (; m <= h && b <= v && g(h, v); )
      h -= 1, v -= 1, w += 1;
    return w;
  }, "countCommonItemsR"), i = /* @__PURE__ */ o((m, h, b, v, g, w, E) => {
    let R = 0, S = -m, P = w[R], _ = P;
    w[R] += r(
      P + 1,
      h,
      v + P - S + 1,
      b,
      g
    );
    let C = m < E ? m : E;
    for (R += 1, S += 2; R <= C; R += 1, S += 2) {
      if (R !== m && _ < w[R])
        P = w[R];
      else if (P = _ + 1, h <= P)
        return R - 1;
      _ = w[R], w[R] = P + r(P + 1, h, v + P - S + 1, b, g);
    }
    return E;
  }, "extendPathsF"), s = /* @__PURE__ */ o((m, h, b, v, g, w, E) => {
    let R = 0, S = m, P = w[R], _ = P;
    w[R] -= n(
      h,
      P - 1,
      b,
      v + P - S - 1,
      g
    );
    let C = m < E ? m : E;
    for (R += 1, S -= 2; R <= C; R += 1, S -= 2) {
      if (R !== m && w[R] < _)
        P = w[R];
      else if (P = _ - 1, P < h)
        return R - 1;
      _ = w[R], w[R] = P - n(
        h,
        P - 1,
        b,
        v + P - S - 1,
        g
      );
    }
    return E;
  }, "extendPathsR"), a = /* @__PURE__ */ o((m, h, b, v, g, w, E, R, S, P, _) => {
    let C = v - h, O = b - h, q = g - v - O, D = -q - (m - 1), H = -q + (m - 1), M = t, U = m < R ? m : R;
    for (let N = 0, W = -m; N <= U; N += 1, W += 2) {
      let Y = N === 0 || N !== m && M < E[N], ae = Y ? E[N] : M, pe = Y ? ae : ae + 1, Oe = C + pe - W, F = r(
        pe + 1,
        b,
        Oe + 1,
        g,
        w
      ), j = pe + F;
      if (M = E[N], E[N] = j, D <= W && W <= H) {
        let K = (m - 1 - (W + q)) / 2;
        if (K <= P && S[K] - 1 <= j) {
          let G = C + ae - (Y ? W + 1 : W - 1), Z = n(
            h,
            ae,
            v,
            G,
            w
          ), ve = ae - Z, qe = G - Z, Qe = ve + 1, vi = qe + 1;
          _.nChangePreceding = m - 1, m - 1 === Qe + vi - h - v ? (_.aEndPreceding = h, _.bEndPreceding = v) : (_.aEndPreceding = Qe, _.bEndPreceding = vi), _.nCommonPreceding = Z, Z !== 0 && (_.aCommonPreceding = Qe, _.bCommonPreceding = vi), _.nCommonFollowing = F, F !== 0 && (_.aCommonFollowing = pe + 1, _.bCommonFollowing = Oe + 1);
          let bt = j + 1, we = Oe + F + 1;
          return _.nChangeFollowing = m - 1, m - 1 === b + g - bt - we ? (_.aStartFollowing = b, _.bStartFollowing = g) : (_.aStartFollowing = bt, _.bStartFollowing = we), true;
        }
      }
    }
    return false;
  }, "extendOverlappablePathsF"), l = /* @__PURE__ */ o((m, h, b, v, g, w, E, R, S, P, _) => {
    let C = g - b, O = b - h, q = g - v - O, D = q - m, H = q + m, M = t, U = m < P ? m : P;
    for (let N = 0, W = m; N <= U; N += 1, W -= 2) {
      let Y = N === 0 || N !== m && S[N] < M, ae = Y ? S[N] : M, pe = Y ? ae : ae - 1, Oe = C + pe - W, F = n(
        h,
        pe - 1,
        v,
        Oe - 1,
        w
      ), j = pe - F;
      if (M = S[N], S[N] = j, D <= W && W <= H) {
        let K = (m + (W - q)) / 2;
        if (K <= R && j - 1 <= E[K]) {
          let G = Oe - F;
          if (_.nChangePreceding = m, m === j + G - h - v ? (_.aEndPreceding = h, _.bEndPreceding = v) : (_.aEndPreceding = j, _.bEndPreceding = G), _.nCommonPreceding = F, F !== 0 && (_.aCommonPreceding = j, _.bCommonPreceding = G), _.nChangeFollowing = m - 1, m === 1)
            _.nCommonFollowing = 0, _.aStartFollowing = b, _.bStartFollowing = g;
          else {
            let Z = C + ae - (Y ? W - 1 : W + 1), ve = r(
              ae,
              b,
              Z,
              g,
              w
            );
            _.nCommonFollowing = ve, ve !== 0 && (_.aCommonFollowing = ae, _.bCommonFollowing = Z);
            let qe = ae + ve, Qe = Z + ve;
            m - 1 === b + g - qe - Qe ? (_.aStartFollowing = b, _.bStartFollowing = g) : (_.aStartFollowing = qe, _.bStartFollowing = Qe);
          }
          return true;
        }
      }
    }
    return false;
  }, "extendOverlappablePathsR"), u = /* @__PURE__ */ o((m, h, b, v, g, w, E, R, S) => {
    let P = v - h, _ = g - b, C = b - h, O = g - v, L = O - C, q = C, D = C;
    if (E[0] = h - 1, R[0] = b, L % 2 === 0) {
      let H = (m || L) / 2, M = (C + O) / 2;
      for (let U = 1; U <= M; U += 1)
        if (q = i(U, b, g, P, w, E, q), U < H)
          D = s(U, h, v, _, w, R, D);
        else if (
          // If a reverse path overlaps a forward path in the same diagonal,
          // return a division of the index intervals at the middle change.
          l(
            U,
            h,
            b,
            v,
            g,
            w,
            E,
            q,
            R,
            D,
            S
          )
        )
          return;
    } else {
      let H = ((m || L) + 1) / 2, M = (C + O + 1) / 2, U = 1;
      for (q = i(U, b, g, P, w, E, q), U += 1; U <= M; U += 1)
        if (D = s(
          U - 1,
          h,
          v,
          _,
          w,
          R,
          D
        ), U < H)
          q = i(U, b, g, P, w, E, q);
        else if (
          // If a forward path overlaps a reverse path in the same diagonal,
          // return a division of the index intervals at the middle change.
          a(
            U,
            h,
            b,
            v,
            g,
            w,
            E,
            q,
            R,
            D,
            S
          )
        )
          return;
    }
    throw new Error(
      `${e}: no overlap aStart=${h} aEnd=${b} bStart=${v} bEnd=${g}`
    );
  }, "divide"), c = /* @__PURE__ */ o((m, h, b, v, g, w, E, R, S, P) => {
    if (g - v < b - h) {
      if (w = !w, w && E.length === 1) {
        let { foundSubsequence: j, isCommon: K } = E[0];
        E[1] = {
          foundSubsequence: /* @__PURE__ */ o((G, Z, ve) => {
            j(G, ve, Z);
          }, "foundSubsequence"),
          isCommon: /* @__PURE__ */ o((G, Z) => K(Z, G), "isCommon")
        };
      }
      let Oe = h, F = b;
      h = v, b = g, v = Oe, g = F;
    }
    let { foundSubsequence: _, isCommon: C } = E[w ? 1 : 0];
    u(
      m,
      h,
      b,
      v,
      g,
      C,
      R,
      S,
      P
    );
    let {
      nChangePreceding: O,
      aEndPreceding: L,
      bEndPreceding: q,
      nCommonPreceding: D,
      aCommonPreceding: H,
      bCommonPreceding: M,
      nCommonFollowing: U,
      aCommonFollowing: N,
      bCommonFollowing: W,
      nChangeFollowing: Y,
      aStartFollowing: ae,
      bStartFollowing: pe
    } = P;
    h < L && v < q && c(
      O,
      h,
      L,
      v,
      q,
      w,
      E,
      R,
      S,
      P
    ), D !== 0 && _(D, H, M), U !== 0 && _(U, N, W), ae < b && pe < g && c(
      Y,
      ae,
      b,
      pe,
      g,
      w,
      E,
      R,
      S,
      P
    );
  }, "findSubsequences"), d = /* @__PURE__ */ o((m, h) => {
    if (typeof h != "number")
      throw new TypeError(`${e}: ${m} typeof ${typeof h} is not a number`);
    if (!Number.isSafeInteger(h))
      throw new RangeError(`${e}: ${m} value ${h} is not a safe integer`);
    if (h < 0)
      throw new RangeError(`${e}: ${m} value ${h} is a negative integer`);
  }, "validateLength"), p = /* @__PURE__ */ o((m, h) => {
    let b = typeof h;
    if (b !== "function")
      throw new TypeError(`${e}: ${m} typeof ${b} is not a function`);
  }, "validateCallback");
  function f(m, h, b, v) {
    d("aLength", m), d("bLength", h), p("isCommon", b), p("foundSubsequence", v);
    let g = r(0, m, 0, h, b);
    if (g !== 0 && v(g, 0, 0), m !== g || h !== g) {
      let w = g, E = g, R = n(
        w,
        m - 1,
        E,
        h - 1,
        b
      ), S = m - R, P = h - R, _ = g + R;
      m !== _ && h !== _ && c(
        0,
        w,
        S,
        E,
        P,
        false,
        [
          {
            foundSubsequence: v,
            isCommon: b
          }
        ],
        [t],
        [t],
        {
          aCommonFollowing: t,
          aCommonPreceding: t,
          aEndPreceding: t,
          aStartFollowing: t,
          bCommonFollowing: t,
          bCommonPreceding: t,
          bEndPreceding: t,
          bStartFollowing: t,
          nChangeFollowing: t,
          nChangePreceding: t,
          nCommonFollowing: t,
          nCommonPreceding: t
        }
      ), R !== 0 && v(R, S, P);
    }
  }
  return o(f, "diffSequence"), yl;
}
o(V6, "requireBuild");
var z6 = V6(), vC = /* @__PURE__ */ Z_(z6);
function G6(e, t) {
  return e.replace(/\s+$/, (r) => t(r));
}
o(G6, "formatTrailingSpaces");
function Xg(e, t, r, n, i, s) {
  return e.length !== 0 ? r(`${n} ${G6(e, i)}`) : n !== " " ? r(n) : t && s.length !== 0 ? r(`${n} ${s}`) : "";
}
o(Xg, "printDiffLine");
function EC(e, t, { aColor: r, aIndicator: n, changeLineTrailingSpaceColor: i, emptyFirstOrLastLinePlaceholder: s }) {
  return Xg(e, t, r, n, i, s);
}
o(EC, "printDeleteLine");
function xC(e, t, { bColor: r, bIndicator: n, changeLineTrailingSpaceColor: i, emptyFirstOrLastLinePlaceholder: s }) {
  return Xg(e, t, r, n, i, s);
}
o(xC, "printInsertLine");
function wC(e, t, { commonColor: r, commonIndicator: n, commonLineTrailingSpaceColor: i, emptyFirstOrLastLinePlaceholder: s }) {
  return Xg(e, t, r, n, i, s);
}
o(wC, "printCommonLine");
function sC(e, t, r, n, { patchColor: i }) {
  return i(`@@ -${e + 1},${t - e} +${r + 1},${n - r} @@`);
}
o(sC, "createPatchMark");
function W6(e, t) {
  let r = e.length, n = t.contextLines, i = n + n, s = r, a = false, l = 0, u = 0;
  for (; u !== r; ) {
    let R = u;
    for (; u !== r && e[u][0] === Ie$1; )
      u += 1;
    if (R !== u)
      if (R === 0)
        u > n && (s -= u - n, a = true);
      else if (u === r) {
        let S = u - R;
        S > n && (s -= S - n, a = true);
      } else {
        let S = u - R;
        S > i && (s -= S - i, l += 1);
      }
    for (; u !== r && e[u][0] !== Ie$1; )
      u += 1;
  }
  let c = l !== 0 || a;
  l !== 0 ? s += l + 1 : a && (s += 1);
  let d = s - 1, p = [], f = 0;
  c && p.push("");
  let m = 0, h = 0, b = 0, v = 0, g = /* @__PURE__ */ o((R) => {
    let S = p.length;
    p.push(wC(R, S === 0 || S === d, t)), b += 1, v += 1;
  }, "pushCommonLine"), w = /* @__PURE__ */ o((R) => {
    let S = p.length;
    p.push(EC(R, S === 0 || S === d, t)), b += 1;
  }, "pushDeleteLine"), E = /* @__PURE__ */ o((R) => {
    let S = p.length;
    p.push(xC(R, S === 0 || S === d, t)), v += 1;
  }, "pushInsertLine");
  for (u = 0; u !== r; ) {
    let R = u;
    for (; u !== r && e[u][0] === Ie$1; )
      u += 1;
    if (R !== u)
      if (R === 0) {
        u > n && (R = u - n, m = R, h = R, b = m, v = h);
        for (let S = R; S !== u; S += 1)
          g(e[S][1]);
      } else if (u === r) {
        let S = u - R > n ? R + n : u;
        for (let P = R; P !== S; P += 1)
          g(e[P][1]);
      } else {
        let S = u - R;
        if (S > i) {
          let P = R + n;
          for (let C = R; C !== P; C += 1)
            g(e[C][1]);
          p[f] = sC(m, b, h, v, t), f = p.length, p.push("");
          let _ = S - i;
          m = b + _, h = v + _, b = m, v = h;
          for (let C = u - n; C !== u; C += 1)
            g(e[C][1]);
        } else
          for (let P = R; P !== u; P += 1)
            g(e[P][1]);
      }
    for (; u !== r && e[u][0] === tt$1; )
      w(e[u][1]), u += 1;
    for (; u !== r && e[u][0] === Ke$1; )
      E(e[u][1]), u += 1;
  }
  return c && (p[f] = sC(m, b, h, v, t)), p.join(`
`);
}
o(W6, "joinAlignedDiffsNoExpand");
function Y6(e, t) {
  return e.map((r, n, i) => {
    let s = r[1], a = n === 0 || n === i.length - 1;
    switch (r[0]) {
      case tt$1:
        return EC(s, a, t);
      case Ke$1:
        return xC(s, a, t);
      default:
        return wC(s, a, t);
    }
  }).join(`
`);
}
o(Y6, "joinAlignedDiffsExpand");
var Vg = /* @__PURE__ */ o((e) => e, "noColor"), TC = 5, K6 = 0;
function X6() {
  return {
    aAnnotation: "Expected",
    aColor: Ee.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: Ee.red,
    bIndicator: "+",
    changeColor: Ee.inverse,
    changeLineTrailingSpaceColor: Vg,
    commonColor: Ee.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: Vg,
    compareKeys: void 0,
    contextLines: TC,
    emptyFirstOrLastLinePlaceholder: "",
    expand: false,
    includeChangeCounts: false,
    omitAnnotationLines: false,
    patchColor: Ee.yellow,
    printBasicPrototype: false,
    truncateThreshold: K6,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: Vg
  };
}
o(X6, "getDefaultOptions");
function J6(e) {
  return e && typeof e == "function" ? e : void 0;
}
o(J6, "getCompareKeys");
function Q6(e) {
  return typeof e == "number" && Number.isSafeInteger(e) && e >= 0 ? e : TC;
}
o(Q6, "getContextLines");
function wn(e = {}) {
  return {
    ...X6(),
    ...e,
    compareKeys: J6(e.compareKeys),
    contextLines: Q6(e.contextLines)
  };
}
o(wn, "normalizeDiffOptions");
function Ro(e) {
  return e.length === 1 && e[0].length === 0;
}
o(Ro, "isEmptyString");
function Z6(e) {
  let t = 0, r = 0;
  return e.forEach((n) => {
    switch (n[0]) {
      case tt$1:
        t += 1;
        break;
      case Ke$1:
        r += 1;
        break;
    }
  }), {
    a: t,
    b: r
  };
}
o(Z6, "countChanges");
function eW({ aAnnotation: e, aColor: t, aIndicator: r, bAnnotation: n, bColor: i, bIndicator: s, includeChangeCounts: a, omitAnnotationLines: l }, u) {
  if (l)
    return "";
  let c = "", d = "";
  if (a) {
    let m = String(u.a), h = String(u.b), b = n.length - e.length, v = " ".repeat(Math.max(0, b)), g = " ".repeat(Math.max(0, -b)), w = h.length - m.length, E = " ".repeat(Math.max(0, w)), R = " ".repeat(Math.max(0, -w));
    c = `${v}  ${r} ${E}${m}`, d = `${g}  ${s} ${R}${h}`;
  }
  let p = `${r} ${e}${c}`, f = `${s} ${n}${d}`;
  return `${t(p)}
${i(f)}

`;
}
o(eW, "printAnnotation");
function Jg(e, t, r) {
  return eW(r, Z6(e)) + (r.expand ? Y6(e, r) : W6(e, r)) + (t ? r.truncateAnnotationColor(`
${r.truncateAnnotation}`) : "");
}
o(Jg, "printDiffLines");
function gl(e, t, r) {
  let n = wn(r), [i, s] = RC(Ro(e) ? [] : e, Ro(t) ? [] : t, n);
  return Jg(i, s, n);
}
o(gl, "diffLinesUnified");
function tW(e, t, r, n, i) {
  if (Ro(e) && Ro(r) && (e = [], r = []), Ro(t) && Ro(n) && (t = [], n = []), e.length !== r.length || t.length !== n.length)
    return gl(e, t, i);
  let [s, a] = RC(r, n, i), l = 0, u = 0;
  return s.forEach((c) => {
    switch (c[0]) {
      case tt$1:
        c[1] = e[l], l += 1;
        break;
      case Ke$1:
        c[1] = t[u], u += 1;
        break;
      default:
        c[1] = t[u], l += 1, u += 1;
    }
  }), Jg(s, a, wn(i));
}
o(tW, "diffLinesUnified2");
function RC(e, t, r) {
  let n = r?.truncateThreshold ?? false, i = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0), s = n ? Math.min(e.length, i) : e.length, a = n ? Math.min(t.length, i) : t.length, l = s !== e.length || a !== t.length, u = /* @__PURE__ */ o((m, h) => e[m] === t[h], "isCommon"), c = [], d = 0, p = 0;
  for (vC(s, a, u, /* @__PURE__ */ o((m, h, b) => {
    for (; d !== h; d += 1)
      c.push(new Te(tt$1, e[d]));
    for (; p !== b; p += 1)
      c.push(new Te(Ke$1, t[p]));
    for (; m !== 0; m -= 1, d += 1, p += 1)
      c.push(new Te(Ie$1, t[p]));
  }, "foundSubsequence")); d !== s; d += 1)
    c.push(new Te(tt$1, e[d]));
  for (; p !== a; p += 1)
    c.push(new Te(Ke$1, t[p]));
  return [c, l];
}
o(RC, "diffLinesRaw");
function aC(e) {
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  if (Array.isArray(e))
    return "array";
  if (typeof e == "boolean")
    return "boolean";
  if (typeof e == "function")
    return "function";
  if (typeof e == "number")
    return "number";
  if (typeof e == "string")
    return "string";
  if (typeof e == "bigint")
    return "bigint";
  if (typeof e == "object") {
    if (e != null) {
      if (e.constructor === RegExp)
        return "regexp";
      if (e.constructor === Map)
        return "map";
      if (e.constructor === Set)
        return "set";
      if (e.constructor === Date)
        return "date";
    }
    return "object";
  } else if (typeof e == "symbol")
    return "symbol";
  throw new Error(`value of unknown type: ${e}`);
}
o(aC, "getType");
function lC(e) {
  return e.includes(`\r
`) ? `\r
` : `
`;
}
o(lC, "getNewLineSymbol");
function rW(e, t, r) {
  let n = r?.truncateThreshold ?? false, i = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0), s = e.length, a = t.length;
  if (n) {
    let m = e.includes(`
`), h = t.includes(`
`), b = lC(e), v = lC(t), g = m ? `${e.split(b, i).join(b)}
` : e, w = h ? `${t.split(v, i).join(v)}
` : t;
    s = g.length, a = w.length;
  }
  let l = s !== e.length || a !== t.length, u = /* @__PURE__ */ o((m, h) => e[m] === t[h], "isCommon"), c = 0, d = 0, p = [];
  return vC(s, a, u, /* @__PURE__ */ o((m, h, b) => {
    c !== h && p.push(new Te(tt$1, e.slice(c, h))), d !== b && p.push(new Te(Ke$1, t.slice(d, b))), c = h + m, d = b + m, p.push(new Te(Ie$1, t.slice(
      b,
      d
    )));
  }, "foundSubsequence")), c !== s && p.push(new Te(tt$1, e.slice(c))), d !== a && p.push(new Te(Ke$1, t.slice(d))), [p, l];
}
o(rW, "diffStrings");
function nW(e, t, r) {
  return t.reduce((n, i) => n + (i[0] === Ie$1 ? i[1] : i[0] === e && i[1].length !== 0 ? r(i[1]) : ""), "");
}
o(nW, "concatenateRelevantDiffs");
var Zg = class Zg2 {
  op;
  line;
  lines;
  changeColor;
  constructor(t, r) {
    this.op = t, this.line = [], this.lines = [], this.changeColor = r;
  }
  pushSubstring(t) {
    this.pushDiff(new Te(this.op, t));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new Te(this.op, nW(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Te(this.op, this.line[0][1])), this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  // Minor input to buffer.
  pushDiff(t) {
    this.line.push(t);
  }
  // Main input to buffer.
  align(t) {
    let r = t[1];
    if (r.includes(`
`)) {
      let n = r.split(`
`), i = n.length - 1;
      n.forEach((s, a) => {
        a < i ? (this.pushSubstring(s), this.pushLine()) : s.length !== 0 && this.pushSubstring(s);
      });
    } else
      this.pushDiff(t);
  }
  // Output from buffer.
  moveLinesTo(t) {
    this.isLineEmpty() || this.pushLine(), t.push(...this.lines), this.lines.length = 0;
  }
};
o(Zg, "ChangeBuffer");
var bl = Zg, ev = class ev2 {
  deleteBuffer;
  insertBuffer;
  lines;
  constructor(t, r) {
    this.deleteBuffer = t, this.insertBuffer = r, this.lines = [];
  }
  pushDiffCommonLine(t) {
    this.lines.push(t);
  }
  pushDiffChangeLines(t) {
    let r = t[1].length === 0;
    (!r || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(t), (!r || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(
      t
    );
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(t) {
    let r = t[0], n = t[1];
    if (n.includes(`
`)) {
      let i = n.split(`
`), s = i.length - 1;
      i.forEach((a, l) => {
        if (l === 0) {
          let u = new Te(r, a);
          this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(u)) : (this.pushDiffChangeLines(u), this.flushChangeLines());
        } else l < s ? this.pushDiffCommonLine(new Te(r, a)) : a.length !== 0 && this.pushDiffChangeLines(new Te(r, a));
      });
    } else
      this.pushDiffChangeLines(t);
  }
  // Output from buffer.
  getLines() {
    return this.flushChangeLines(), this.lines;
  }
};
o(ev, "CommonBuffer");
var Gg = ev;
function oW(e, t) {
  let r = new bl(tt$1, t), n = new bl(Ke$1, t), i = new Gg(r, n);
  return e.forEach((s) => {
    switch (s[0]) {
      case tt$1:
        r.align(s);
        break;
      case Ke$1:
        n.align(s);
        break;
      default:
        i.align(s);
    }
  }), i.getLines();
}
o(oW, "getAlignedDiffs");
function iW(e, t) {
  if (t) {
    let r = e.length - 1;
    return e.some((n, i) => n[0] === Ie$1 && (i !== r || n[1] !== `
`));
  }
  return e.some((r) => r[0] === Ie$1);
}
o(iW, "hasCommonDiff");
function sW(e, t, r) {
  if (e !== t && e.length !== 0 && t.length !== 0) {
    let n = e.includes(`
`) || t.includes(`
`), [i, s] = SC(n ? `${e}
` : e, n ? `${t}
` : t, true, r);
    if (iW(i, n)) {
      let a = wn(r), l = oW(i, a.changeColor);
      return Jg(l, s, a);
    }
  }
  return gl(e.split(`
`), t.split(`
`), r);
}
o(sW, "diffStringsUnified");
function SC(e, t, r, n) {
  let [i, s] = rW(e, t, n);
  return r && D6(i), [i, s];
}
o(SC, "diffStringsRaw");
function Wg(e, t) {
  let { commonColor: r } = wn(t);
  return r(e);
}
o(Wg, "getCommonMessage");
var { AsymmetricMatcher: aW, DOMCollection: lW, DOMElement: uW, Immutable: cW, ReactElement: dW, ReactTestComponent: pW } = Yi, _C = [
  pW,
  dW,
  uW,
  lW,
  cW,
  aW,
  Yi.Error
], Yg = {
  maxDepth: 20,
  plugins: _C
}, CC = {
  callToJSON: false,
  maxDepth: 8,
  plugins: _C
};
function Tn(e, t, r) {
  if (Object.is(e, t))
    return "";
  let n = aC(e), i = n, s = false;
  if (n === "object" && typeof e.asymmetricMatch == "function") {
    if (e.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof e.getExpectedType != "function")
      return;
    i = e.getExpectedType(), s = i === "string";
  }
  if (i !== aC(t)) {
    let v = function(E) {
      return E.length <= b ? E : `${E.slice(0, b)}...`;
    };
    o(v, "truncate");
    let { aAnnotation: a, aColor: l, aIndicator: u, bAnnotation: c, bColor: d, bIndicator: p } = wn(r), f = Kg(CC, r), m = St$1(e, f), h = St$1(
      t,
      f
    ), b = 1e5;
    m = v(m), h = v(h);
    let g = `${l(`${u} ${a}:`)} 
${m}`, w = `${d(`${p} ${c}:`)} 
${h}`;
    return `${g}

${w}`;
  }
  if (!s)
    switch (n) {
      case "string":
        return gl(e.split(`
`), t.split(`
`), r);
      case "boolean":
      case "number":
        return fW(e, t, r);
      case "map":
        return zg(uC(e), uC(t), r);
      case "set":
        return zg(cC(e), cC(t), r);
      default:
        return zg(e, t, r);
    }
}
o(Tn, "diff");
function fW(e, t, r) {
  let n = St$1(e, Yg), i = St$1(t, Yg);
  return n === i ? "" : gl(n.split(`
`), i.split(`
`), r);
}
o(fW, "comparePrimitive");
function uC(e) {
  return new Map(Array.from(e.entries()).sort());
}
o(uC, "sortMap");
function cC(e) {
  return new Set(Array.from(e.values()).sort());
}
o(cC, "sortSet");
function zg(e, t, r) {
  let n, i = false;
  try {
    let a = Kg(Yg, r);
    n = dC(e, t, a, r);
  } catch {
    i = true;
  }
  let s = Wg(gC, r);
  if (n === void 0 || n === s) {
    let a = Kg(CC, r);
    n = dC(e, t, a, r), n !== s && !i && (n = `${Wg(U6, r)}

${n}`);
  }
  return n;
}
o(zg, "compareObjects");
function Kg(e, t) {
  let { compareKeys: r, printBasicPrototype: n, maxDepth: i } = wn(t);
  return {
    ...e,
    compareKeys: r,
    printBasicPrototype: n,
    maxDepth: i ?? e.maxDepth
  };
}
o(Kg, "getFormatOptions");
function dC(e, t, r, n) {
  let i = {
    ...r,
    indent: 0
  }, s = St$1(e, i), a = St$1(t, i);
  if (s === a)
    return Wg(gC, n);
  {
    let l = St$1(e, r), u = St$1(t, r);
    return tW(l.split(`
`), u.split(`
`), s.split(`
`), a.split(`
`), n);
  }
}
o(dC, "getObjectsDifference");
var pC = 2e4;
function fC(e) {
  return xn(e) === "Object" && typeof e.asymmetricMatch == "function";
}
o(fC, "isAsymmetricMatcher");
function mC(e, t) {
  let r = xn(e), n = xn(t);
  return r === n && (r === "Object" || r === "Array");
}
o(mC, "isReplaceable");
function vl(e, t, r) {
  let { aAnnotation: n, bAnnotation: i } = wn(r);
  if (typeof t == "string" && typeof e == "string" && t.length > 0 && e.length > 0 && t.length <= pC && e.length <= pC && t !== e) {
    if (t.includes(`
`) || e.includes(`
`))
      return sW(t, e, r);
    let [d] = SC(t, e, true), p = d.some((b) => b[0] === Ie$1), f = mW(n, i), m = f(n) + bW(hC(d, tt$1, p)), h = f(i) + yW(hC(d, Ke$1, p));
    return `${m}
${h}`;
  }
  let s = ml(t, { forceWritable: true }), a = ml(e, { forceWritable: true }), { replacedExpected: l, replacedActual: u } = PC(a, s);
  return Tn(l, u, r);
}
o(vl, "printDiffOrStringify");
function PC(e, t, r = /* @__PURE__ */ new WeakSet(), n = /* @__PURE__ */ new WeakSet()) {
  return e instanceof Error && t instanceof Error && typeof e.cause < "u" && typeof t.cause > "u" ? (delete e.cause, {
    replacedActual: e,
    replacedExpected: t
  }) : mC(e, t) ? r.has(e) || n.has(t) ? {
    replacedActual: e,
    replacedExpected: t
  } : (r.add(e), n.add(t), fl(t).forEach((i) => {
    let s = t[i], a = e[i];
    if (fC(s))
      s.asymmetricMatch(a) && (e[i] = s);
    else if (fC(a))
      a.asymmetricMatch(s) && (t[i] = a);
    else if (mC(a, s)) {
      let l = PC(a, s, r, n);
      e[i] = l.replacedActual, t[i] = l.replacedExpected;
    }
  }), {
    replacedActual: e,
    replacedExpected: t
  }) : {
    replacedActual: e,
    replacedExpected: t
  };
}
o(PC, "replaceAsymmetricMatcher");
function mW(...e) {
  let t = e.reduce((r, n) => n.length > r ? n.length : r, 0);
  return (r) => `${r}: ${" ".repeat(t - r.length)}`;
}
o(mW, "getLabelPrinter");
var hW = "";
function AC(e) {
  return e.replace(/\s+$/gm, (t) => hW.repeat(t.length));
}
o(AC, "replaceTrailingSpaces");
function yW(e) {
  return Ee.red(AC(Ye(e)));
}
o(yW, "printReceived");
function bW(e) {
  return Ee.green(AC(Ye(e)));
}
o(bW, "printExpected");
function hC(e, t, r) {
  return e.reduce((n, i) => n + (i[0] === Ie$1 ? i[1] : i[0] === t ? r ? Ee.inverse(i[1]) : i[1] : ""), "");
}
o(hC, "getCommonAndChangedSubstrings");
var gW = "@@__IMMUTABLE_RECORD__@@", vW = "@@__IMMUTABLE_ITERABLE__@@";
function EW(e) {
  return e && (e[vW] || e[gW]);
}
o(EW, "isImmutable");
var xW = Object.getPrototypeOf({});
function OC(e) {
  return e instanceof Error ? `<unserializable>: ${e.message}` : typeof e == "string" ? `<unserializable>: ${e}` : "<unserializable>";
}
o(OC, "getUnserializableMessage");
function Nr$1(e, t = /* @__PURE__ */ new WeakMap()) {
  if (!e || typeof e == "string")
    return e;
  if (e instanceof Error && "toJSON" in e && typeof e.toJSON == "function") {
    let r = e.toJSON();
    return r && r !== e && typeof r == "object" && (typeof e.message == "string" && El(() => r.message ?? (r.message = e.message)), typeof e.stack == "string" && El(() => r.stack ?? (r.stack = e.stack)), typeof e.name == "string" && El(() => r.name ?? (r.name = e.name)), e.cause != null && El(() => r.cause ?? (r.cause = Nr$1(e.cause, t)))), Nr$1(r, t);
  }
  if (typeof e == "function")
    return `Function<${e.name || "anonymous"}>`;
  if (typeof e == "symbol")
    return e.toString();
  if (typeof e != "object")
    return e;
  if (typeof Buffer < "u" && e instanceof Buffer)
    return `<Buffer(${e.length}) ...>`;
  if (typeof Uint8Array < "u" && e instanceof Uint8Array)
    return `<Uint8Array(${e.length}) ...>`;
  if (EW(e))
    return Nr$1(e.toJSON(), t);
  if (e instanceof Promise || e.constructor && e.constructor.prototype === "AsyncFunction")
    return "Promise";
  if (typeof Element < "u" && e instanceof Element)
    return e.tagName;
  if (typeof e.asymmetricMatch == "function")
    return `${e.toString()} ${Hg(e.sample)}`;
  if (typeof e.toJSON == "function")
    return Nr$1(e.toJSON(), t);
  if (t.has(e))
    return t.get(e);
  if (Array.isArray(e)) {
    let r = new Array(e.length);
    return t.set(e, r), e.forEach((n, i) => {
      try {
        r[i] = Nr$1(n, t);
      } catch (s) {
        r[i] = OC(s);
      }
    }), r;
  } else {
    let r = /* @__PURE__ */ Object.create(null);
    t.set(e, r);
    let n = e;
    for (; n && n !== xW; )
      Object.getOwnPropertyNames(n).forEach((i) => {
        if (!(i in r))
          try {
            r[i] = Nr$1(e[i], t);
          } catch (s) {
            delete r[i], r[i] = OC(s);
          }
      }), n = Object.getPrototypeOf(n);
    return r;
  }
}
o(Nr$1, "serializeValue");
function El(e) {
  try {
    return e();
  } catch {
  }
}
o(El, "safe");
function wW(e) {
  return e.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
o(wW, "normalizeErrorMessage");
function Ki(e, t, r = /* @__PURE__ */ new WeakSet()) {
  if (!e || typeof e != "object")
    return { message: String(e) };
  let n = e;
  (n.showDiff || n.showDiff === void 0 && n.expected !== void 0 && n.actual !== void 0) && (n.diff = vl(n.actual, n.expected, {
    ...t,
    ...n.diffOptions
  })), "expected" in n && typeof n.expected != "string" && (n.expected = Ye(n.expected, 10)), "actual" in n && typeof n.actual != "string" && (n.actual = Ye(n.actual, 10));
  try {
    typeof n.message == "string" && (n.message = wW(n.message));
  } catch {
  }
  try {
    !r.has(n) && typeof n.cause == "object" && (r.add(n), n.cause = Ki(n.cause, t, r));
  } catch {
  }
  try {
    return Nr$1(n);
  } catch (i) {
    return Nr$1(new Error(`Failed to fully serialize error: ${i?.message}
Inner error message: ${n?.message}`));
  }
}
o(Ki, "processError");
var tr = {
  CALL: "storybook/instrumenter/call",
  SYNC: "storybook/instrumenter/sync",
  START: "storybook/instrumenter/start",
  BACK: "storybook/instrumenter/back",
  GOTO: "storybook/instrumenter/goto",
  NEXT: "storybook/instrumenter/next",
  END: "storybook/instrumenter/end"
};
var xl = globalThis.__STORYBOOK_ADDONS_PREVIEW;
var TW = new Error(
  "This function ran after the play function completed. Did you forget to `await` it?"
), qC = /* @__PURE__ */ o((e) => Object.prototype.toString.call(e) === "[object Object]", "isObject"), RW = /* @__PURE__ */ o((e) => Object.prototype.toString.call(e) === "[object Module]", "isModule"), SW = /* @__PURE__ */ o((e) => {
  if (!qC(e) && !RW(e))
    return false;
  if (e.constructor === void 0)
    return true;
  let t = e.constructor.prototype;
  return !!qC(t);
}, "isInstrumentable"), _W = /* @__PURE__ */ o((e) => {
  try {
    return new e.constructor();
  } catch {
    return {};
  }
}, "construct"), tv = /* @__PURE__ */ o(() => ({
  renderPhase: "preparing",
  isDebugging: false,
  isPlaying: false,
  isLocked: false,
  cursor: 0,
  calls: [],
  shadowCalls: [],
  callRefsByResult: /* @__PURE__ */ new Map(),
  chainedCallIds: /* @__PURE__ */ new Set(),
  ancestors: [],
  playUntil: void 0,
  resolvers: {},
  syncTimeout: void 0
}), "getInitialState"), IC = /* @__PURE__ */ o((e, t = false) => {
  let r = (t ? e.shadowCalls : e.calls).filter((i) => i.retain);
  if (!r.length)
    return;
  let n = new Map(
    Array.from(e.callRefsByResult.entries()).filter(([, i]) => i.retain)
  );
  return { cursor: r.length, calls: r, callRefsByResult: n };
}, "getRetainedState"), nv = class nv2 {
  constructor() {
    this.detached = false;
    this.initialized = false;
    this.state = {};
    this.loadParentWindowState = /* @__PURE__ */ o(() => {
      try {
        this.state = k.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
      } catch {
        this.detached = true;
      }
    }, "loadParentWindowState");
    this.updateParentWindowState = /* @__PURE__ */ o(() => {
      try {
        k.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
      } catch {
        this.detached = true;
      }
    }, "updateParentWindowState");
    this.loadParentWindowState();
    let t = /* @__PURE__ */ o(({
      storyId: u,
      renderPhase: c,
      isPlaying: d = true,
      isDebugging: p = false
    }) => {
      let f = this.getState(u);
      this.setState(u, {
        ...tv(),
        ...IC(f, p),
        renderPhase: c || f.renderPhase,
        shadowCalls: p ? f.shadowCalls : [],
        chainedCallIds: p ? f.chainedCallIds : /* @__PURE__ */ new Set(),
        playUntil: p ? f.playUntil : void 0,
        isPlaying: d,
        isDebugging: p
      }), this.sync(u);
    }, "resetState"), r = /* @__PURE__ */ o((u) => ({ storyId: c, playUntil: d }) => {
      this.getState(c).isDebugging || this.setState(c, ({ calls: f }) => ({
        calls: [],
        shadowCalls: f.map((m) => ({ ...m, status: "waiting" })),
        isDebugging: true
      }));
      let p = this.getLog(c);
      this.setState(c, ({ shadowCalls: f }) => {
        if (d || !p.length)
          return { playUntil: d };
        let m = f.findIndex((h) => h.id === p[0].callId);
        return {
          playUntil: f.slice(0, m).filter((h) => h.interceptable && !h.ancestors?.length).slice(-1)[0]?.id
        };
      }), u.emit(lo, { storyId: c, isDebugging: true });
    }, "start"), n = /* @__PURE__ */ o((u) => ({ storyId: c }) => {
      let d = this.getLog(c).filter((f) => !f.ancestors?.length), p = d.reduceRight((f, m, h) => f >= 0 || m.status === "waiting" ? f : h, -1);
      r(u)({ storyId: c, playUntil: d[p - 1]?.callId });
    }, "back"), i = /* @__PURE__ */ o((u) => ({ storyId: c, callId: d }) => {
      let { calls: p, shadowCalls: f, resolvers: m } = this.getState(c), h = p.find(({ id: v }) => v === d), b = f.find(({ id: v }) => v === d);
      if (!h && b && Object.values(m).length > 0) {
        let v = this.getLog(c).find((g) => g.status === "waiting")?.callId;
        b.id !== v && this.setState(c, { playUntil: b.id }), Object.values(m).forEach((g) => g());
      } else
        r(u)({ storyId: c, playUntil: d });
    }, "goto"), s = /* @__PURE__ */ o((u) => ({ storyId: c }) => {
      let { resolvers: d } = this.getState(c);
      if (Object.values(d).length > 0)
        Object.values(d).forEach((p) => p());
      else {
        let p = this.getLog(c).find((f) => f.status === "waiting")?.callId;
        p ? r(u)({ storyId: c, playUntil: p }) : a({ storyId: c });
      }
    }, "next"), a = /* @__PURE__ */ o(({ storyId: u }) => {
      this.setState(u, { playUntil: void 0, isDebugging: false }), Object.values(this.getState(u).resolvers).forEach((c) => c());
    }, "end"), l = /* @__PURE__ */ o(({
      storyId: u,
      newPhase: c
    }) => {
      let { isDebugging: d } = this.getState(u);
      if (c === "preparing" && d)
        return t({ storyId: u, renderPhase: c });
      if (c === "playing")
        return t({ storyId: u, renderPhase: c, isDebugging: d });
      c === "played" ? this.setState(u, {
        renderPhase: c,
        isLocked: false,
        isPlaying: false,
        isDebugging: false
      }) : c === "errored" ? this.setState(u, {
        renderPhase: c,
        isLocked: false,
        isPlaying: false
      }) : c === "aborted" ? this.setState(u, {
        renderPhase: c,
        isLocked: true,
        isPlaying: false
      }) : this.setState(u, {
        renderPhase: c
      }), this.sync(u);
    }, "renderPhaseChanged");
    xl && xl.ready().then(() => {
      this.channel = xl.getChannel(), this.channel.on(lo, t), this.channel.on(jt, l), this.channel.on(_i, () => {
        this.initialized ? this.cleanup() : this.initialized = true;
      }), this.channel.on(tr.START, r(this.channel)), this.channel.on(tr.BACK, n(this.channel)), this.channel.on(tr.GOTO, i(this.channel)), this.channel.on(tr.NEXT, s(this.channel)), this.channel.on(tr.END, a);
    });
  }
  getState(t) {
    return this.state[t] || tv();
  }
  setState(t, r) {
    if (t) {
      let n = this.getState(t), i = typeof r == "function" ? r(n) : r;
      this.state = { ...this.state, [t]: { ...n, ...i } }, this.updateParentWindowState();
    }
  }
  cleanup() {
    this.state = Object.entries(this.state).reduce(
      (n, [i, s]) => {
        let a = IC(s);
        return a && (n[i] = Object.assign(tv(), a)), n;
      },
      {}
    );
    let r = { controlStates: {
      detached: this.detached,
      start: false,
      back: false,
      goto: false,
      next: false,
      end: false
    }, logItems: [] };
    this.channel?.emit(tr.SYNC, r), this.updateParentWindowState();
  }
  getLog(t) {
    let { calls: r, shadowCalls: n } = this.getState(t), i = [...n];
    r.forEach((a, l) => {
      i[l] = a;
    });
    let s = /* @__PURE__ */ new Set();
    return i.reduceRight((a, l) => (l.args.forEach((u) => {
      u?.__callId__ && s.add(u.__callId__);
    }), l.path.forEach((u) => {
      u.__callId__ && s.add(u.__callId__);
    }), (l.interceptable || l.exception) && !s.has(l.id) && (a.unshift({ callId: l.id, status: l.status, ancestors: l.ancestors }), s.add(l.id)), a), []);
  }
  // Traverses the object structure to recursively patch all function properties.
  // Returns the original object, or a new object with the same constructor,
  // depending on whether it should mutate.
  instrument(t, r, n = 0) {
    if (!SW(t))
      return t;
    let { mutate: i = false, path: s = [] } = r, a = r.getKeys ? r.getKeys(t, n) : Object.keys(t);
    return n += 1, a.reduce(
      (l, u) => {
        let c = CW(t, u);
        if (typeof c?.get == "function") {
          if (c.configurable) {
            let p = /* @__PURE__ */ o(() => c?.get?.bind(t)?.(), "getter");
            Object.defineProperty(l, u, {
              get: /* @__PURE__ */ o(() => this.instrument(p(), { ...r, path: s.concat(u) }, n), "get")
            });
          }
          return l;
        }
        let d = t[u];
        return typeof d != "function" ? (l[u] = this.instrument(d, { ...r, path: s.concat(u) }, n), l) : "__originalFn__" in d && typeof d.__originalFn__ == "function" ? (l[u] = d, l) : (l[u] = (...p) => this.track(u, d, t, p, r), l[u].__originalFn__ = d, Object.defineProperty(
          l[u],
          "name",
          { value: u, writable: false }
        ), Object.keys(d).length > 0 && Object.assign(
          l[u],
          this.instrument({ ...d }, { ...r, path: s.concat(u) }, n)
        ), l);
      },
      i ? t : _W(t)
    );
  }
  // Monkey patch an object method to record calls.
  // Returns a function that invokes the original function, records the invocation ("call") and
  // returns the original result.
  track(t, r, n, i, s) {
    let a = i?.[0]?.__storyId__ || k.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor: l, ancestors: u } = this.getState(
      a
    );
    this.setState(a, { cursor: l + 1 });
    let c = `${u.slice(-1)[0] || a} [${l}] ${t}`, { path: d = [], intercept: p = false, retain: f = false } = s, m = typeof p == "function" ? p(
      t,
      d
    ) : p, h = { id: c, cursor: l, storyId: a, ancestors: u, path: d, method: t, args: i, interceptable: m, retain: f }, v = (m && !u.length ? this.intercept : this.invoke).call(this, r, n, h, s);
    return this.instrument(v, { ...s, mutate: true, path: [{ __callId__: h.id }] });
  }
  intercept(t, r, n, i) {
    let { chainedCallIds: s, isDebugging: a, playUntil: l } = this.getState(n.storyId), u = s.has(n.id);
    return !a || u || l ? (l === n.id && this.setState(n.storyId, { playUntil: void 0 }), this.invoke(t, r, n, i)) : new Promise((c) => {
      this.setState(n.storyId, ({ resolvers: d }) => ({
        isLocked: false,
        resolvers: { ...d, [n.id]: c }
      }));
    }).then(() => (this.setState(n.storyId, (c) => {
      let { [n.id]: d, ...p } = c.resolvers;
      return { isLocked: true, resolvers: p };
    }), this.invoke(t, r, n, i)));
  }
  invoke(t, r, n, i) {
    let { callRefsByResult: s, renderPhase: a } = this.getState(n.storyId), l = 25, u = /* @__PURE__ */ o((p, f, m) => {
      if (m.includes(p))
        return "[Circular]";
      if (m = [...m, p], f > l)
        return "...";
      if (s.has(p))
        return s.get(p);
      if (p instanceof Array)
        return p.map((h) => u(h, ++f, m));
      if (p instanceof Date)
        return { __date__: { value: p.toISOString() } };
      if (p instanceof Error) {
        let { name: h, message: b, stack: v } = p;
        return { __error__: { name: h, message: b, stack: v } };
      }
      if (p instanceof RegExp) {
        let { flags: h, source: b } = p;
        return { __regexp__: { flags: h, source: b } };
      }
      if (p instanceof k.window?.HTMLElement) {
        let { prefix: h, localName: b, id: v, classList: g, innerText: w } = p, E = Array.from(g);
        return { __element__: { prefix: h, localName: b, id: v, classNames: E, innerText: w } };
      }
      return typeof p == "function" ? {
        __function__: { name: "getMockName" in p ? p.getMockName() : p.name }
      } : typeof p == "symbol" ? { __symbol__: { description: p.description } } : typeof p == "object" && p?.constructor?.name && p?.constructor?.name !== "Object" ? { __class__: { name: p.constructor.name } } : Object.prototype.toString.call(p) === "[object Object]" ? Object.fromEntries(
        Object.entries(p).map(([h, b]) => [h, u(b, ++f, m)])
      ) : p;
    }, "serializeValues"), c = {
      ...n,
      args: n.args.map((p) => u(p, 0, []))
    };
    n.path.forEach((p) => {
      p?.__callId__ && this.setState(n.storyId, ({ chainedCallIds: f }) => ({
        chainedCallIds: new Set(Array.from(f).concat(p.__callId__))
      }));
    });
    let d = /* @__PURE__ */ o((p) => {
      if (p instanceof Error) {
        let { name: f, message: m, stack: h, callId: b = n.id } = p, {
          showDiff: v = void 0,
          diff: g = void 0,
          actual: w = void 0,
          expected: E = void 0
        } = p.name === "AssertionError" ? Ki(p) : p, R = { name: f, message: m, stack: h, callId: b, showDiff: v, diff: g, actual: w, expected: E };
        if (this.update({ ...c, status: "error", exception: R }), this.setState(n.storyId, (S) => ({
          callRefsByResult: new Map([
            ...Array.from(S.callRefsByResult.entries()),
            [p, { __callId__: n.id, retain: n.retain }]
          ])
        })), n.ancestors?.length)
          throw Object.prototype.hasOwnProperty.call(p, "callId") || Object.defineProperty(p, "callId", { value: n.id }), p;
      }
      throw p;
    }, "handleException");
    try {
      if (a === "played" && !n.retain)
        throw TW;
      let f = (i.getArgs ? i.getArgs(n, this.getState(n.storyId)) : n.args).map((h) => typeof h != "function" || PW(h) || Object.keys(h).length ? h : (...b) => {
        let { cursor: v, ancestors: g } = this.getState(n.storyId);
        this.setState(n.storyId, { cursor: 0, ancestors: [...g, n.id] });
        let w = /* @__PURE__ */ o(() => this.setState(n.storyId, { cursor: v, ancestors: g }), "restore"), E = false;
        try {
          let R = h(...b);
          return R instanceof Promise ? (E = true, R.finally(w)) : R;
        } finally {
          E || w();
        }
      }), m = t.apply(r, f);
      return m && ["object", "function", "symbol"].includes(typeof m) && this.setState(n.storyId, (h) => ({
        callRefsByResult: new Map([
          ...Array.from(h.callRefsByResult.entries()),
          [m, { __callId__: n.id, retain: n.retain }]
        ])
      })), this.update({
        ...c,
        status: m instanceof Promise ? "active" : "done"
      }), m instanceof Promise ? m.then((h) => (this.update({ ...c, status: "done" }), h), d) : m;
    } catch (p) {
      return d(p);
    }
  }
  // Sends the call info to the manager and synchronizes the log.
  update(t) {
    this.channel?.emit(tr.CALL, t), this.setState(t.storyId, ({ calls: r }) => {
      let n = r.concat(t).reduce((i, s) => Object.assign(i, { [s.id]: s }), {});
      return {
        // Calls are sorted to ensure parent calls always come before calls in their callback.
        calls: Object.values(n).sort(
          (i, s) => i.id.localeCompare(s.id, void 0, { numeric: true })
        )
      };
    }), this.sync(t.storyId);
  }
  // Builds a log of interceptable calls and control states and sends it to the manager.
  // Uses a 0ms debounce because this might get called many times in one tick.
  sync(t) {
    let r = /* @__PURE__ */ o(() => {
      let { isLocked: n, isPlaying: i } = this.getState(t), s = this.getLog(t), a = s.filter(({ ancestors: p }) => !p.length).find((p) => p.status === "waiting")?.callId, l = s.some((p) => p.status === "active");
      if (this.detached || n || l || s.length === 0) {
        let f = { controlStates: {
          detached: this.detached,
          start: false,
          back: false,
          goto: false,
          next: false,
          end: false
        }, logItems: s };
        this.channel?.emit(tr.SYNC, f);
        return;
      }
      let u = s.some(
        (p) => p.status === "done" || p.status === "error"
      ), d = { controlStates: {
        detached: this.detached,
        start: u,
        back: u,
        goto: true,
        next: i,
        end: i
      }, logItems: s, pausedAt: a };
      this.channel?.emit(tr.SYNC, d);
    }, "synchronize");
    this.setState(t, ({ syncTimeout: n }) => (clearTimeout(n), { syncTimeout: setTimeout(r, 0) }));
  }
};
o(nv, "Instrumenter");
var rv = nv;
function rr(e, t = {}) {
  try {
    let r = false, n = false;
    return k.window?.location?.search?.includes("instrument=true") ? r = true : k.window?.location?.search?.includes("instrument=false") && (n = true), k.window?.parent === k.window && !r || n ? e : (k.window && !k.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (k.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new rv()), (k.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(e, t));
  } catch (r) {
    return be.warn(r), e;
  }
}
o(rr, "instrument");
function CW(e, t) {
  let r = e;
  for (; r != null; ) {
    let n = Object.getOwnPropertyDescriptor(r, t);
    if (n)
      return n;
    r = Object.getPrototypeOf(r);
  }
}
o(CW, "getPropertyDescriptor");
function PW(e) {
  if (typeof e != "function")
    return false;
  let t = Object.getOwnPropertyDescriptor(e, "prototype");
  return t ? !t.writable : false;
}
o(PW, "isClass");
var HC = Object.defineProperty, AW = Object.getOwnPropertyNames, I$1 = /* @__PURE__ */ o(
  (e, t) => HC(e, "name", { value: t, configurable: true }),
  "__name"
), OW = /* @__PURE__ */ o((e, t) => /* @__PURE__ */ o(function() {
  return t || (0, e[AW(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, "__require"), "__commonJS"), Ev = /* @__PURE__ */ o((e, t) => {
  for (var r in t)
    HC(e, r, { get: t[r], enumerable: true });
}, "__export"), qW = OW({
  "(disabled):util"() {
  }
}), _t = {};
Ev(_t, {
  addChainableMethod: /* @__PURE__ */ o(() => Iv, "addChainableMethod"),
  addLengthGuard: /* @__PURE__ */ o(() => es, "addLengthGuard"),
  addMethod: /* @__PURE__ */ o(() => Av, "addMethod"),
  addProperty: /* @__PURE__ */ o(() => Pv, "addProperty"),
  checkError: /* @__PURE__ */ o(() => vt$1, "checkError"),
  compareByInspect: /* @__PURE__ */ o(() => Sl, "compareByInspect"),
  eql: /* @__PURE__ */ o(() => hP, "eql"),
  expectTypes: /* @__PURE__ */ o(() => KC, "expectTypes"),
  flag: /* @__PURE__ */ o(() => ee, "flag"),
  getActual: /* @__PURE__ */ o(() => Ol, "getActual"),
  getMessage: /* @__PURE__ */ o(() => Tv, "getMessage"),
  getName: /* @__PURE__ */ o(() => Il, "getName"),
  getOperator: /* @__PURE__ */ o(() => kv, "getOperator"),
  getOwnEnumerableProperties: /* @__PURE__ */ o(() => jv, "getOwnEnumerableProperties"),
  getOwnEnumerablePropertySymbols: /* @__PURE__ */ o(() => Nv, "getOwnEnumerablePropertySymbols"),
  getPathInfo: /* @__PURE__ */ o(() => Cv, "getPathInfo"),
  hasProperty: /* @__PURE__ */ o(() => ql, "hasProperty"),
  inspect: /* @__PURE__ */ o(() => le$1, "inspect"),
  isNaN: /* @__PURE__ */ o(() => _l, "isNaN"),
  isNumeric: /* @__PURE__ */ o(() => Ue$1, "isNumeric"),
  isProxyEnabled: /* @__PURE__ */ o(() => Zi, "isProxyEnabled"),
  isRegExp: /* @__PURE__ */ o(() => Cl, "isRegExp"),
  objDisplay: /* @__PURE__ */ o(() => Rn, "objDisplay"),
  overwriteChainableMethod: /* @__PURE__ */ o(() => Mv, "overwriteChainableMethod"),
  overwriteMethod: /* @__PURE__ */ o(() => qv, "overwriteMethod"),
  overwriteProperty: /* @__PURE__ */ o(() => Ov, "overwriteProperty"),
  proxify: /* @__PURE__ */ o(() => Po, "proxify"),
  test: /* @__PURE__ */ o(() => xv, "test"),
  transferFlags: /* @__PURE__ */ o(() => $t, "transferFlags"),
  type: /* @__PURE__ */ o(() => ye$1, "type")
});
var vt$1 = {};
Ev(vt$1, {
  compatibleConstructor: /* @__PURE__ */ o(() => zC, "compatibleConstructor"),
  compatibleInstance: /* @__PURE__ */ o(() => VC, "compatibleInstance"),
  compatibleMessage: /* @__PURE__ */ o(() => GC, "compatibleMessage"),
  getConstructorName: /* @__PURE__ */ o(() => WC, "getConstructorName"),
  getMessage: /* @__PURE__ */ o(() => YC, "getMessage")
});
function Al(e) {
  return e instanceof Error || Object.prototype.toString.call(e) === "[object Error]";
}
o(Al, "isErrorInstance");
I$1(Al, "isErrorInstance");
function UC(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
o(UC, "isRegExp");
I$1(UC, "isRegExp");
function VC(e, t) {
  return Al(t) && e === t;
}
o(VC, "compatibleInstance");
I$1(VC, "compatibleInstance");
function zC(e, t) {
  return Al(t) ? e.constructor === t.constructor || e instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? e.constructor === t || e instanceof t : false;
}
o(zC, "compatibleConstructor");
I$1(zC, "compatibleConstructor");
function GC(e, t) {
  let r = typeof e == "string" ? e : e.message;
  return UC(t) ? t.test(r) : typeof t == "string" ? r.indexOf(t) !== -1 : false;
}
o(GC, "compatibleMessage");
I$1(GC, "compatibleMessage");
function WC(e) {
  let t = e;
  return Al(e) ? t = e.constructor.name : typeof e == "function" && (t = e.name, t === "" && (t = new e().name || t)), t;
}
o(WC, "getConstructorName");
I$1(WC, "getConstructorName");
function YC(e) {
  let t = "";
  return e && e.message ? t = e.message : typeof e == "string" && (t = e), t;
}
o(YC, "getMessage");
I$1(YC, "getMessage");
function ee(e, t, r) {
  var n = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    n[t] = r;
  else
    return n[t];
}
o(ee, "flag");
I$1(ee, "flag");
function xv(e, t) {
  var r = ee(e, "negate"), n = t[0];
  return r ? !n : n;
}
o(xv, "test");
I$1(xv, "test");
function ye$1(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  let t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
o(ye$1, "type");
I$1(ye$1, "type");
var IW = "captureStackTrace" in Error, kr$1, ue$1 = (kr$1 = class extends Error {
  message;
  get name() {
    return "AssertionError";
  }
  get ok() {
    return false;
  }
  constructor(t = "Unspecified AssertionError", r, n) {
    super(t), this.message = t, IW && Error.captureStackTrace(this, n || kr$1);
    for (let i in r)
      i in this || (this[i] = r[i]);
  }
  toJSON(t) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: false,
      stack: t !== false ? this.stack : void 0
    };
  }
}, o(kr$1, "_AssertionError"), I$1(kr$1, "AssertionError"), kr$1);
function KC(e, t) {
  var r = ee(e, "message"), n = ee(e, "ssfi");
  r = r ? r + ": " : "", e = ee(e, "object"), t = t.map(function(a) {
    return a.toLowerCase();
  }), t.sort();
  var i = t.map(function(a, l) {
    var u = ~["a", "e", "i", "o", "u"].indexOf(a.charAt(0)) ? "an" : "a", c = t.length > 1 && l === t.length - 1 ? "or " : "";
    return c + u + " " + a;
  }).join(", "), s = ye$1(e).toLowerCase();
  if (!t.some(function(a) {
    return s === a;
  }))
    throw new ue$1(
      r + "object tested must be " + i + ", but " + s + " given",
      void 0,
      n
    );
}
o(KC, "expectTypes");
I$1(KC, "expectTypes");
function Ol(e, t) {
  return t.length > 4 ? t[4] : e._obj;
}
o(Ol, "getActual");
I$1(Ol, "getActual");
var MC = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, MW = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, _o = "";
function XC(e, t) {
  let r = MC[MW[t]] || MC[t] || "";
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
o(XC, "colorise");
I$1(XC, "colorise");
function JC({
  showHidden: e = false,
  depth: t = 2,
  colors: r = false,
  customInspect: n = true,
  showProxy: i = false,
  maxArrayLength: s = 1 / 0,
  breakLength: a = 1 / 0,
  seen: l = [],
  // eslint-disable-next-line no-shadow
  truncate: u = 1 / 0,
  stylize: c = String
} = {}, d) {
  let p = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!i,
    maxArrayLength: Number(s),
    breakLength: Number(a),
    truncate: Number(u),
    seen: l,
    inspect: d,
    stylize: c
  };
  return p.colors && (p.stylize = XC), p;
}
o(JC, "normaliseOptions");
I$1(JC, "normaliseOptions");
function QC(e) {
  return e >= "\uD800" && e <= "\uDBFF";
}
o(QC, "isHighSurrogate");
I$1(QC, "isHighSurrogate");
function mr(e, t, r = _o) {
  e = String(e);
  let n = r.length, i = e.length;
  if (n > t && i > n)
    return r;
  if (i > t && i > n) {
    let s = t - n;
    return s > 0 && QC(e[s - 1]) && (s = s - 1), `${e.slice(0, s)}${r}`;
  }
  return e;
}
o(mr, "truncate");
I$1(mr, "truncate");
function Ct(e, t, r, n = ", ") {
  r = r || t.inspect;
  let i = e.length;
  if (i === 0)
    return "";
  let s = t.truncate, a = "", l = "", u = "";
  for (let c = 0; c < i; c += 1) {
    let d = c + 1 === e.length, p = c + 2 === e.length;
    u = `${_o}(${e.length - c})`;
    let f = e[c];
    t.truncate = s - a.length - (d ? 0 : n.length);
    let m = l || r(f, t) + (d ? "" : n), h = a.length + m.length, b = h + u.length;
    if (d && h > s && a.length + u.length <= s || !d && !p && b > s || (l = d ? "" : r(e[c + 1], t) + (p ? "" : n), !d && p && b > s && h + l.length > s))
      break;
    if (a += m, !d && !p && h + l.length >= s) {
      u = `${_o}(${e.length - c - 1})`;
      break;
    }
    u = "";
  }
  return `${a}${u}`;
}
o(Ct, "inspectList");
I$1(Ct, "inspectList");
function ZC(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? e : JSON.stringify(e).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
o(ZC, "quoteComplexKey");
I$1(ZC, "quoteComplexKey");
function Co([e, t], r) {
  return r.truncate -= 2, typeof e == "string" ? e = ZC(e) : typeof e != "number" && (e = `[${r.inspect(e, r)}]`), r.truncate -= e.length, t = r.inspect(t, r), `${e}: ${t}`;
}
o(Co, "inspectProperty");
I$1(Co, "inspectProperty");
function eP(e, t) {
  let r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length)
    return "[]";
  t.truncate -= 4;
  let n = Ct(e, t);
  t.truncate -= n.length;
  let i = "";
  return r.length && (i = Ct(r.map((s) => [s, e[s]]), t, Co)), `[ ${n}${i ? `, ${i}` : ""} ]`;
}
o(eP, "inspectArray");
I$1(eP, "inspectArray");
var NW = /* @__PURE__ */ I$1((e) => typeof Buffer == "function" && e instanceof Buffer ? "Buffer" : e[Symbol.toStringTag] ? e[Symbol.toStringTag] : e.constructor.name, "getArrayName");
function nr(e, t) {
  let r = NW(e);
  t.truncate -= r.length + 4;
  let n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length)
    return `${r}[]`;
  let i = "";
  for (let a = 0; a < e.length; a++) {
    let l = `${t.stylize(mr(e[a], t.truncate), "number")}${a === e.length - 1 ? "" : ", "}`;
    if (t.truncate -= l.length, e[a] !== e.length && t.truncate <= 3) {
      i += `${_o}(${e.length - e[a] + 1})`;
      break;
    }
    i += l;
  }
  let s = "";
  return n.length && (s = Ct(n.map((a) => [a, e[a]]), t, Co)), `${r}[ ${i}${s ? `, ${s}` : ""} ]`;
}
o(nr, "inspectTypedArray");
I$1(nr, "inspectTypedArray");
function tP(e, t) {
  let r = e.toJSON();
  if (r === null)
    return "Invalid Date";
  let n = r.split("T"), i = n[0];
  return t.stylize(`${i}T${mr(n[1], t.truncate - i.length - 1)}`, "date");
}
o(tP, "inspectDate");
I$1(tP, "inspectDate");
function sv(e, t) {
  let r = e[Symbol.toStringTag] || "Function", n = e.name;
  return n ? t.stylize(`[${r} ${mr(n, t.truncate - 11)}]`, "special") : t.stylize(`[${r}]`, "special");
}
o(sv, "inspectFunction");
I$1(sv, "inspectFunction");
function rP([e, t], r) {
  return r.truncate -= 4, e = r.inspect(e, r), r.truncate -= e.length, t = r.inspect(t, r), `${e} => ${t}`;
}
o(rP, "inspectMapEntry");
I$1(rP, "inspectMapEntry");
function nP(e) {
  let t = [];
  return e.forEach((r, n) => {
    t.push([n, r]);
  }), t;
}
o(nP, "mapToEntries");
I$1(nP, "mapToEntries");
function oP(e, t) {
  return e.size - 1 <= 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${Ct(nP(e), t, rP)} }`);
}
o(oP, "inspectMap");
I$1(oP, "inspectMap");
var jW = Number.isNaN || ((e) => e !== e);
function av(e, t) {
  return jW(e) ? t.stylize("NaN", "number") : e === 1 / 0 ? t.stylize("Infinity", "number") : e === -1 / 0 ? t.stylize("-Infinity", "number") : e === 0 ? t.stylize(1 / e === 1 / 0 ? "+0" : "-0", "number") : t.stylize(mr(String(e), t.truncate), "number");
}
o(av, "inspectNumber");
I$1(av, "inspectNumber");
function lv(e, t) {
  let r = mr(e.toString(), t.truncate - 1);
  return r !== _o && (r += "n"), t.stylize(r, "bigint");
}
o(lv, "inspectBigInt");
I$1(lv, "inspectBigInt");
function iP(e, t) {
  let r = e.toString().split("/")[2], n = t.truncate - (2 + r.length), i = e.source;
  return t.stylize(`/${mr(i, n)}/${r}`, "regexp");
}
o(iP, "inspectRegExp");
I$1(iP, "inspectRegExp");
function sP(e) {
  let t = [];
  return e.forEach((r) => {
    t.push(r);
  }), t;
}
o(sP, "arrayFromSet");
I$1(sP, "arrayFromSet");
function aP(e, t) {
  return e.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${Ct(sP(e), t)} }`);
}
o(aP, "inspectSet");
I$1(aP, "inspectSet");
var NC = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), kW = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, LW = 16, FW = 4;
function lP(e) {
  return kW[e] || `\\u${`0000${e.charCodeAt(0).toString(LW)}`.slice(-FW)}`;
}
o(lP, "escape");
I$1(lP, "escape");
function uv(e, t) {
  return NC.test(e) && (e = e.replace(NC, lP)), t.stylize(`'${mr(e, t.truncate - 2)}'`, "string");
}
o(uv, "inspectString");
I$1(uv, "inspectString");
function cv(e) {
  return "description" in Symbol.prototype ? e.description ? `Symbol(${e.description})` : "Symbol()" : e.toString();
}
o(cv, "inspectSymbol");
I$1(cv, "inspectSymbol");
var uP = /* @__PURE__ */ I$1(() => "Promise{}", "getPromiseValue");
try {
  let { getPromiseDetails: e, kPending: t, kRejected: r } = process.binding("util");
  Array.isArray(e(Promise.resolve())) && (uP = /* @__PURE__ */ I$1((n, i) => {
    let [s, a] = e(n);
    return s === t ? "Promise{<pending>}" : `Promise${s === r ? "!" : ""}{${i.inspect(a, i)}}`;
  }, "getPromiseValue"));
} catch {
}
var DW = uP;
function Ji(e, t) {
  let r = Object.getOwnPropertyNames(e), n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  let i = Ct(r.map((l) => [l, e[l]]), t, Co), s = Ct(n.map((l) => [l, e[l]]), t, Co);
  t.seen.pop();
  let a = "";
  return i && s && (a = ", "), `{ ${i}${a}${s} }`;
}
o(Ji, "inspectObject");
I$1(Ji, "inspectObject");
var ov = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : false;
function cP(e, t) {
  let r = "";
  return ov && ov in e && (r = e[ov]), r = r || e.constructor.name, (!r || r === "_class") && (r = "<Anonymous Class>"), t.truncate -= r.length, `${r}${Ji(e, t)}`;
}
o(cP, "inspectClass");
I$1(cP, "inspectClass");
function dP(e, t) {
  return e.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${Ct(e, t)} ]`);
}
o(dP, "inspectArguments");
I$1(dP, "inspectArguments");
var $W = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function pP(e, t) {
  let r = Object.getOwnPropertyNames(e).filter((a) => $W.indexOf(a) === -1), n = e.name;
  t.truncate -= n.length;
  let i = "";
  if (typeof e.message == "string" ? i = mr(e.message, t.truncate) : r.unshift("message"), i = i ? `: ${i}` : "", t.truncate -= i.length + 5, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  let s = Ct(r.map((a) => [a, e[a]]), t, Co);
  return `${n}${i}${s ? ` { ${s} }` : ""}`;
}
o(pP, "inspectObject2");
I$1(pP, "inspectObject");
function fP([e, t], r) {
  return r.truncate -= 3, t ? `${r.stylize(String(e), "yellow")}=${r.stylize(`"${t}"`, "string")}` : `${r.stylize(String(e), "yellow")}`;
}
o(fP, "inspectAttribute");
I$1(fP, "inspectAttribute");
function wl(e, t) {
  return Ct(e, t, wv, `
`);
}
o(wl, "inspectHTMLCollection");
I$1(wl, "inspectHTMLCollection");
function wv(e, t) {
  let r = e.getAttributeNames(), n = e.tagName.toLowerCase(), i = t.stylize(`<${n}`, "special"), s = t.stylize(">", "special"), a = t.stylize(
    `</${n}>`,
    "special"
  );
  t.truncate -= n.length * 2 + 5;
  let l = "";
  r.length > 0 && (l += " ", l += Ct(r.map((d) => [d, e.getAttribute(d)]), t, fP, " ")), t.truncate -= l.length;
  let u = t.truncate, c = wl(e.children, t);
  return c && c.length > u && (c = `${_o}(${e.children.length})`), `${i}${l}${s}${c}${a}`;
}
o(wv, "inspectHTML");
I$1(wv, "inspectHTML");
var BW = typeof Symbol == "function" && typeof Symbol.for == "function", iv = BW ? Symbol.for("chai/inspect") : "@@chai/inspect", So = false;
try {
  let e = qW();
  So = e.inspect ? e.inspect.custom : false;
} catch {
  So = false;
}
var jC = /* @__PURE__ */ new WeakMap(), kC = {}, LC = {
  undefined: /* @__PURE__ */ o((e, t) => t.stylize("undefined", "undefined"), "undefined"),
  null: /* @__PURE__ */ o((e, t) => t.stylize("null", "null"), "null"),
  boolean: /* @__PURE__ */ o((e, t) => t.stylize(String(e), "boolean"), "boolean"),
  Boolean: /* @__PURE__ */ o((e, t) => t.stylize(String(e), "boolean"), "Boolean"),
  number: av,
  Number: av,
  bigint: lv,
  BigInt: lv,
  string: uv,
  String: uv,
  function: sv,
  Function: sv,
  symbol: cv,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: cv,
  Array: eP,
  Date: tP,
  Map: oP,
  Set: aP,
  RegExp: iP,
  Promise: DW,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: /* @__PURE__ */ o((e, t) => t.stylize("WeakSet{}", "special"), "WeakSet"),
  WeakMap: /* @__PURE__ */ o((e, t) => t.stylize("WeakMap{}", "special"), "WeakMap"),
  Arguments: dP,
  Int8Array: nr,
  Uint8Array: nr,
  Uint8ClampedArray: nr,
  Int16Array: nr,
  Uint16Array: nr,
  Int32Array: nr,
  Uint32Array: nr,
  Float32Array: nr,
  Float64Array: nr,
  Generator: /* @__PURE__ */ o(() => "", "Generator"),
  DataView: /* @__PURE__ */ o(() => "", "DataView"),
  ArrayBuffer: /* @__PURE__ */ o(() => "", "ArrayBuffer"),
  Error: pP,
  HTMLCollection: wl,
  NodeList: wl
}, HW = /* @__PURE__ */ I$1((e, t, r) => iv in e && typeof e[iv] == "function" ? e[iv](t) : So && So in e && typeof e[So] == "function" ? e[So](
  t.depth,
  t
) : "inspect" in e && typeof e.inspect == "function" ? e.inspect(t.depth, t) : "constructor" in e && jC.has(e.constructor) ? jC.get(
  e.constructor
)(e, t) : kC[r] ? kC[r](e, t) : "", "inspectCustom"), UW = Object.prototype.toString;
function Tl(e, t = {}) {
  let r = JC(t, Tl), { customInspect: n } = r, i = e === null ? "null" : typeof e;
  if (i === "object" && (i = UW.call(e).slice(8, -1)), i in LC)
    return LC[i](e, r);
  if (n && e) {
    let a = HW(e, r, i);
    if (a)
      return typeof a == "string" ? a : Tl(a, r);
  }
  let s = e ? Object.getPrototypeOf(e) : false;
  return s === Object.prototype || s === null ? Ji(e, r) : e && typeof HTMLElement == "function" && e instanceof HTMLElement ? wv(e, r) : "constructor" in e ? e.constructor !== Object ? cP(e, r) : Ji(e, r) : e === Object(e) ? Ji(e, r) : r.stylize(String(e), i);
}
o(Tl, "inspect");
I$1(Tl, "inspect");
var at$1 = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: false,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: true,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: true,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function le$1(e, t, r, n) {
  var i = {
    colors: n,
    depth: typeof r > "u" ? 2 : r,
    showHidden: t,
    truncate: at$1.truncateThreshold ? at$1.truncateThreshold : 1 / 0
  };
  return Tl(e, i);
}
o(le$1, "inspect2");
I$1(le$1, "inspect");
function Rn(e) {
  var t = le$1(e), r = Object.prototype.toString.call(e);
  if (at$1.truncateThreshold && t.length >= at$1.truncateThreshold) {
    if (r === "[object Function]")
      return !e.name || e.name === "" ? "[Function]" : "[Function: " + e.name + "]";
    if (r === "[object Array]")
      return "[ Array(" + e.length + ") ]";
    if (r === "[object Object]") {
      var n = Object.keys(e), i = n.length > 2 ? n.splice(0, 2).join(", ") + ", ..." : n.join(", ");
      return "{ Object (" + i + ") }";
    } else
      return t;
  } else
    return t;
}
o(Rn, "objDisplay");
I$1(Rn, "objDisplay");
function Tv(e, t) {
  var r = ee(e, "negate"), n = ee(e, "object"), i = t[3], s = Ol(e, t), a = r ? t[2] : t[1], l = ee(e, "message");
  return typeof a == "function" && (a = a()), a = a || "", a = a.replace(/#\{this\}/g, function() {
    return Rn(n);
  }).replace(/#\{act\}/g, function() {
    return Rn(s);
  }).replace(/#\{exp\}/g, function() {
    return Rn(i);
  }), l ? l + ": " + a : a;
}
o(Tv, "getMessage2");
I$1(Tv, "getMessage");
function $t(e, t, r) {
  var n = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null)), r = arguments.length === 3 ? r : true;
  for (var i in n)
    (r || i !== "object" && i !== "ssfi" && i !== "lockSsfi" && i != "message") && (t.__flags[i] = n[i]);
}
o($t, "transferFlags");
I$1($t, "transferFlags");
function dv(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  let t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
o(dv, "type2");
I$1(dv, "type");
function Rv() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
o(Rv, "FakeMap");
I$1(Rv, "FakeMap");
Rv.prototype = {
  get: /* @__PURE__ */ I$1(/* @__PURE__ */ o(function(t) {
    return t[this._key];
  }, "get"), "get"),
  set: /* @__PURE__ */ I$1(/* @__PURE__ */ o(function(t, r) {
    Object.isExtensible(t) && Object.defineProperty(t, this._key, {
      value: r,
      configurable: true
    });
  }, "set"), "set")
};
var mP = typeof WeakMap == "function" ? WeakMap : Rv;
function pv(e, t, r) {
  if (!r || Sn(e) || Sn(t))
    return null;
  var n = r.get(e);
  if (n) {
    var i = n.get(t);
    if (typeof i == "boolean")
      return i;
  }
  return null;
}
o(pv, "memoizeCompare");
I$1(pv, "memoizeCompare");
function Xi(e, t, r, n) {
  if (!(!r || Sn(e) || Sn(t))) {
    var i = r.get(e);
    i ? i.set(t, n) : (i = new mP(), i.set(t, n), r.set(e, i));
  }
}
o(Xi, "memoizeSet");
I$1(Xi, "memoizeSet");
var hP = Qi;
function Qi(e, t, r) {
  if (r && r.comparator)
    return fv(e, t, r);
  var n = Sv(e, t);
  return n !== null ? n : fv(e, t, r);
}
o(Qi, "deepEqual");
I$1(Qi, "deepEqual");
function Sv(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && // eslint-disable-line no-self-compare
  t !== t ? true : Sn(e) || Sn(t) ? false : null;
}
o(Sv, "simpleEqual");
I$1(Sv, "simpleEqual");
function fv(e, t, r) {
  r = r || {}, r.memoize = r.memoize === false ? false : r.memoize || new mP();
  var n = r && r.comparator, i = pv(e, t, r.memoize);
  if (i !== null)
    return i;
  var s = pv(t, e, r.memoize);
  if (s !== null)
    return s;
  if (n) {
    var a = n(e, t);
    if (a === false || a === true)
      return Xi(e, t, r.memoize, a), a;
    var l = Sv(e, t);
    if (l !== null)
      return l;
  }
  var u = dv(e);
  if (u !== dv(t))
    return Xi(e, t, r.memoize, false), false;
  Xi(e, t, r.memoize, true);
  var c = yP(e, t, u, r);
  return Xi(e, t, r.memoize, c), c;
}
o(fv, "extensiveDeepEqual");
I$1(fv, "extensiveDeepEqual");
function yP(e, t, r, n) {
  switch (r) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return Qi(e.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return e === t;
    case "Error":
      return _v(e, t, ["name", "message", "code"], n);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return jr$1(e, t, n);
    case "RegExp":
      return bP(e, t);
    case "Generator":
      return gP(e, t, n);
    case "DataView":
      return jr$1(new Uint8Array(e.buffer), new Uint8Array(t.buffer), n);
    case "ArrayBuffer":
      return jr$1(new Uint8Array(e), new Uint8Array(t), n);
    case "Set":
      return mv(e, t, n);
    case "Map":
      return mv(e, t, n);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return e.equals(t);
    case "Temporal.Duration":
      return e.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return e.toString() === t.toString();
    default:
      return EP(e, t, n);
  }
}
o(yP, "extensiveDeepEqualByType");
I$1(yP, "extensiveDeepEqualByType");
function bP(e, t) {
  return e.toString() === t.toString();
}
o(bP, "regexpEqual");
I$1(bP, "regexpEqual");
function mv(e, t, r) {
  try {
    if (e.size !== t.size)
      return false;
    if (e.size === 0)
      return true;
  } catch {
    return false;
  }
  var n = [], i = [];
  return e.forEach(/* @__PURE__ */ I$1(/* @__PURE__ */ o(function(a, l) {
    n.push([a, l]);
  }, "gatherEntries"), "gatherEntries")), t.forEach(/* @__PURE__ */ I$1(/* @__PURE__ */ o(function(a, l) {
    i.push([a, l]);
  }, "gatherEntries"), "gatherEntries")), jr$1(n.sort(), i.sort(), r);
}
o(mv, "entriesEqual");
I$1(mv, "entriesEqual");
function jr$1(e, t, r) {
  var n = e.length;
  if (n !== t.length)
    return false;
  if (n === 0)
    return true;
  for (var i = -1; ++i < n; )
    if (Qi(e[i], t[i], r) === false)
      return false;
  return true;
}
o(jr$1, "iterableEqual");
I$1(jr$1, "iterableEqual");
function gP(e, t, r) {
  return jr$1(Rl(e), Rl(t), r);
}
o(gP, "generatorEqual");
I$1(gP, "generatorEqual");
function vP(e) {
  return typeof Symbol < "u" && typeof e == "object" && typeof Symbol.iterator < "u" && typeof e[Symbol.iterator] == "function";
}
o(vP, "hasIteratorFunction");
I$1(vP, "hasIteratorFunction");
function hv(e) {
  if (vP(e))
    try {
      return Rl(e[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
o(hv, "getIteratorEntries");
I$1(hv, "getIteratorEntries");
function Rl(e) {
  for (var t = e.next(), r = [t.value]; t.done === false; )
    t = e.next(), r.push(t.value);
  return r;
}
o(Rl, "getGeneratorEntries");
I$1(Rl, "getGeneratorEntries");
function yv(e) {
  var t = [];
  for (var r in e)
    t.push(r);
  return t;
}
o(yv, "getEnumerableKeys");
I$1(yv, "getEnumerableKeys");
function bv(e) {
  for (var t = [], r = Object.getOwnPropertySymbols(e), n = 0; n < r.length; n += 1) {
    var i = r[n];
    Object.getOwnPropertyDescriptor(e, i).enumerable && t.push(i);
  }
  return t;
}
o(bv, "getEnumerableSymbols");
I$1(bv, "getEnumerableSymbols");
function _v(e, t, r, n) {
  var i = r.length;
  if (i === 0)
    return true;
  for (var s = 0; s < i; s += 1)
    if (Qi(e[r[s]], t[r[s]], n) === false)
      return false;
  return true;
}
o(_v, "keysEqual");
I$1(_v, "keysEqual");
function EP(e, t, r) {
  var n = yv(e), i = yv(t), s = bv(e), a = bv(t);
  if (n = n.concat(s), i = i.concat(a), n.length && n.length === i.length)
    return jr$1(gv(n).sort(), gv(i).sort()) === false ? false : _v(e, t, n, r);
  var l = hv(e), u = hv(t);
  return l.length && l.length === u.length ? (l.sort(), u.sort(), jr$1(l, u, r)) : n.length === 0 && l.length === 0 && i.length === 0 && u.length === 0;
}
o(EP, "objectEqual");
I$1(EP, "objectEqual");
function Sn(e) {
  return e === null || typeof e != "object";
}
o(Sn, "isPrimitive");
I$1(Sn, "isPrimitive");
function gv(e) {
  return e.map(/* @__PURE__ */ I$1(/* @__PURE__ */ o(function(r) {
    return typeof r == "symbol" ? r.toString() : r;
  }, "mapSymbol"), "mapSymbol"));
}
o(gv, "mapSymbols");
I$1(gv, "mapSymbols");
function ql(e, t) {
  return typeof e > "u" || e === null ? false : t in Object(e);
}
o(ql, "hasProperty");
I$1(ql, "hasProperty");
function xP(e) {
  return e.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((n) => {
    if (n === "constructor" || n === "__proto__" || n === "prototype")
      return {};
    let s = /^\[(\d+)\]$/.exec(n), a = null;
    return s ? a = { i: parseFloat(s[1]) } : a = { p: n.replace(/\\([.[\]])/g, "$1") }, a;
  });
}
o(xP, "parsePath");
I$1(xP, "parsePath");
function vv(e, t, r) {
  let n = e, i = null;
  r = typeof r > "u" ? t.length : r;
  for (let s = 0; s < r; s++) {
    let a = t[s];
    n && (typeof a.p > "u" ? n = n[a.i] : n = n[a.p], s === r - 1 && (i = n));
  }
  return i;
}
o(vv, "internalGetPathValue");
I$1(vv, "internalGetPathValue");
function Cv(e, t) {
  let r = xP(t), n = r[r.length - 1], i = {
    parent: r.length > 1 ? vv(e, r, r.length - 1) : e,
    name: n.p || n.i,
    value: vv(e, r)
  };
  return i.exists = ql(i.parent, i.name), i;
}
o(Cv, "getPathInfo");
I$1(Cv, "getPathInfo");
function T$1(e, t, r, n) {
  return ee(this, "ssfi", r || T$1), ee(this, "lockSsfi", n), ee(this, "object", e), ee(this, "message", t), ee(this, "eql", at$1.deepEqual || hP), Po(this);
}
o(T$1, "Assertion");
I$1(T$1, "Assertion");
Object.defineProperty(T$1, "includeStack", {
  get: /* @__PURE__ */ o(function() {
    return console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), at$1.includeStack;
  }, "get"),
  set: /* @__PURE__ */ o(function(e) {
    console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), at$1.includeStack = e;
  }, "set")
});
Object.defineProperty(T$1, "showDiff", {
  get: /* @__PURE__ */ o(function() {
    return console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), at$1.showDiff;
  }, "get"),
  set: /* @__PURE__ */ o(function(e) {
    console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), at$1.showDiff = e;
  }, "set")
});
T$1.addProperty = function(e, t) {
  Pv(this.prototype, e, t);
};
T$1.addMethod = function(e, t) {
  Av(this.prototype, e, t);
};
T$1.addChainableMethod = function(e, t, r) {
  Iv(this.prototype, e, t, r);
};
T$1.overwriteProperty = function(e, t) {
  Ov(this.prototype, e, t);
};
T$1.overwriteMethod = function(e, t) {
  qv(this.prototype, e, t);
};
T$1.overwriteChainableMethod = function(e, t, r) {
  Mv(this.prototype, e, t, r);
};
T$1.prototype.assert = function(e, t, r, n, i, s) {
  var a = xv(this, arguments);
  if (s !== false && (s = true), n === void 0 && i === void 0 && (s = false), at$1.showDiff !== true && (s = false), !a) {
    t = Tv(this, arguments);
    var l = Ol(this, arguments), u = {
      actual: l,
      expected: n,
      showDiff: s
    }, c = kv(this, arguments);
    throw c && (u.operator = c), new ue$1(
      t,
      u,
      at$1.includeStack ? this.assert : ee(this, "ssfi")
    );
  }
};
Object.defineProperty(T$1.prototype, "_obj", {
  get: /* @__PURE__ */ o(function() {
    return ee(this, "object");
  }, "get"),
  set: /* @__PURE__ */ o(function(e) {
    ee(this, "object", e);
  }, "set")
});
function Zi() {
  return at$1.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
o(Zi, "isProxyEnabled");
I$1(Zi, "isProxyEnabled");
function Pv(e, t, r) {
  r = r === void 0 ? function() {
  } : r, Object.defineProperty(e, t, {
    get: /* @__PURE__ */ I$1(/* @__PURE__ */ o(function n() {
      !Zi() && !ee(this, "lockSsfi") && ee(this, "ssfi", n);
      var i = r.call(this);
      if (i !== void 0)
        return i;
      var s = new T$1();
      return $t(this, s), s;
    }, "propertyGetter"), "propertyGetter"),
    configurable: true
  });
}
o(Pv, "addProperty");
I$1(Pv, "addProperty");
var VW = Object.getOwnPropertyDescriptor(function() {
}, "length");
function es(e, t, r) {
  return VW.configurable && Object.defineProperty(e, "length", {
    get: /* @__PURE__ */ o(function() {
      throw Error(
        r ? "Invalid Chai property: " + t + '.length. Due to a compatibility issue, "length" cannot directly follow "' + t + '". Use "' + t + '.lengthOf" instead.' : "Invalid Chai property: " + t + '.length. See docs for proper usage of "' + t + '".'
      );
    }, "get")
  }), e;
}
o(es, "addLengthGuard");
I$1(es, "addLengthGuard");
function wP(e) {
  var t = Object.getOwnPropertyNames(e);
  function r(i) {
    t.indexOf(i) === -1 && t.push(i);
  }
  o(r, "addProperty2"), I$1(r, "addProperty");
  for (var n = Object.getPrototypeOf(e); n !== null; )
    Object.getOwnPropertyNames(n).forEach(r), n = Object.getPrototypeOf(n);
  return t;
}
o(wP, "getProperties");
I$1(wP, "getProperties");
var FC = ["__flags", "__methods", "_obj", "assert"];
function Po(e, t) {
  return Zi() ? new Proxy(e, {
    get: /* @__PURE__ */ I$1(/* @__PURE__ */ o(function r(n, i) {
      if (typeof i == "string" && at$1.proxyExcludedKeys.indexOf(i) === -1 && !Reflect.has(n, i)) {
        if (t)
          throw Error(
            "Invalid Chai property: " + t + "." + i + '. See docs for proper usage of "' + t + '".'
          );
        var s = null, a = 4;
        throw wP(n).forEach(function(l) {
          if (
            // we actually mean to check `Object.prototype` here
            // eslint-disable-next-line no-prototype-builtins
            !Object.prototype.hasOwnProperty(l) && FC.indexOf(l) === -1
          ) {
            var u = TP(i, l, a);
            u < a && (s = l, a = u);
          }
        }), Error(
          s !== null ? "Invalid Chai property: " + i + '. Did you mean "' + s + '"?' : "Invalid Chai property: " + i
        );
      }
      return FC.indexOf(i) === -1 && !ee(n, "lockSsfi") && ee(n, "ssfi", r), Reflect.get(n, i);
    }, "proxyGetter"), "proxyGetter")
  }) : e;
}
o(Po, "proxify");
I$1(Po, "proxify");
function TP(e, t, r) {
  if (Math.abs(e.length - t.length) >= r)
    return r;
  var n = [];
  for (let s = 0; s <= e.length; s++)
    n[s] = Array(t.length + 1).fill(0), n[s][0] = s;
  for (let s = 0; s < t.length; s++)
    n[0][s] = s;
  for (let s = 1; s <= e.length; s++) {
    var i = e.charCodeAt(s - 1);
    for (let a = 1; a <= t.length; a++) {
      if (Math.abs(s - a) >= r) {
        n[s][a] = r;
        continue;
      }
      n[s][a] = Math.min(
        n[s - 1][a] + 1,
        n[s][a - 1] + 1,
        n[s - 1][a - 1] + (i === t.charCodeAt(a - 1) ? 0 : 1)
      );
    }
  }
  return n[e.length][t.length];
}
o(TP, "stringDistanceCapped");
I$1(TP, "stringDistanceCapped");
function Av(e, t, r) {
  var n = /* @__PURE__ */ I$1(function() {
    ee(this, "lockSsfi") || ee(this, "ssfi", n);
    var i = r.apply(this, arguments);
    if (i !== void 0)
      return i;
    var s = new T$1();
    return $t(this, s), s;
  }, "methodWrapper");
  es(n, t, false), e[t] = Po(n, t);
}
o(Av, "addMethod");
I$1(Av, "addMethod");
function Ov(e, t, r) {
  var n = Object.getOwnPropertyDescriptor(e, t), i = /* @__PURE__ */ I$1(function() {
  }, "_super");
  n && typeof n.get == "function" && (i = n.get), Object.defineProperty(e, t, {
    get: /* @__PURE__ */ I$1(/* @__PURE__ */ o(function s() {
      !Zi() && !ee(this, "lockSsfi") && ee(this, "ssfi", s);
      var a = ee(this, "lockSsfi");
      ee(this, "lockSsfi", true);
      var l = r(i).call(this);
      if (ee(this, "lockSsfi", a), l !== void 0)
        return l;
      var u = new T$1();
      return $t(this, u), u;
    }, "overwritingPropertyGetter"), "overwritingPropertyGetter"),
    configurable: true
  });
}
o(Ov, "overwriteProperty");
I$1(Ov, "overwriteProperty");
function qv(e, t, r) {
  var n = e[t], i = /* @__PURE__ */ I$1(function() {
    throw new Error(t + " is not a function");
  }, "_super");
  n && typeof n == "function" && (i = n);
  var s = /* @__PURE__ */ I$1(function() {
    ee(this, "lockSsfi") || ee(this, "ssfi", s);
    var a = ee(this, "lockSsfi");
    ee(this, "lockSsfi", true);
    var l = r(i).apply(this, arguments);
    if (ee(this, "lockSsfi", a), l !== void 0)
      return l;
    var u = new T$1();
    return $t(this, u), u;
  }, "overwritingMethodWrapper");
  es(s, t, false), e[t] = Po(s, t);
}
o(qv, "overwriteMethod");
I$1(qv, "overwriteMethod");
var zW = typeof Object.setPrototypeOf == "function", DC = /* @__PURE__ */ I$1(function() {
}, "testFn"), GW = Object.getOwnPropertyNames(DC).filter(function(e) {
  var t = Object.getOwnPropertyDescriptor(DC, e);
  return typeof t != "object" ? true : !t.configurable;
}), WW = Function.prototype.call, YW = Function.prototype.apply;
function Iv(e, t, r, n) {
  typeof n != "function" && (n = /* @__PURE__ */ I$1(function() {
  }, "chainingBehavior"));
  var i = {
    method: r,
    chainingBehavior: n
  };
  e.__methods || (e.__methods = {}), e.__methods[t] = i, Object.defineProperty(e, t, {
    get: /* @__PURE__ */ I$1(/* @__PURE__ */ o(function() {
      i.chainingBehavior.call(this);
      var a = /* @__PURE__ */ I$1(function() {
        ee(this, "lockSsfi") || ee(this, "ssfi", a);
        var c = i.method.apply(this, arguments);
        if (c !== void 0)
          return c;
        var d = new T$1();
        return $t(this, d), d;
      }, "chainableMethodWrapper");
      if (es(a, t, true), zW) {
        var l = Object.create(this);
        l.call = WW, l.apply = YW, Object.setPrototypeOf(a, l);
      } else {
        var u = Object.getOwnPropertyNames(e);
        u.forEach(function(c) {
          if (GW.indexOf(c) === -1) {
            var d = Object.getOwnPropertyDescriptor(e, c);
            Object.defineProperty(a, c, d);
          }
        });
      }
      return $t(this, a), Po(a);
    }, "chainableMethodGetter"), "chainableMethodGetter"),
    configurable: true
  });
}
o(Iv, "addChainableMethod");
I$1(Iv, "addChainableMethod");
function Mv(e, t, r, n) {
  var i = e.__methods[t], s = i.chainingBehavior;
  i.chainingBehavior = /* @__PURE__ */ I$1(/* @__PURE__ */ o(function() {
    var u = n(s).call(this);
    if (u !== void 0)
      return u;
    var c = new T$1();
    return $t(this, c), c;
  }, "overwritingChainableMethodGetter"), "overwritingChainableMethodGetter");
  var a = i.method;
  i.method = /* @__PURE__ */ I$1(/* @__PURE__ */ o(function() {
    var u = r(a).apply(this, arguments);
    if (u !== void 0)
      return u;
    var c = new T$1();
    return $t(this, c), c;
  }, "overwritingChainableMethodWrapper"), "overwritingChainableMethodWrapper");
}
o(Mv, "overwriteChainableMethod");
I$1(Mv, "overwriteChainableMethod");
function Sl(e, t) {
  return le$1(e) < le$1(t) ? -1 : 1;
}
o(Sl, "compareByInspect");
I$1(Sl, "compareByInspect");
function Nv(e) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(e).filter(function(t) {
    return Object.getOwnPropertyDescriptor(e, t).enumerable;
  });
}
o(Nv, "getOwnEnumerablePropertySymbols");
I$1(Nv, "getOwnEnumerablePropertySymbols");
function jv(e) {
  return Object.keys(e).concat(Nv(e));
}
o(jv, "getOwnEnumerableProperties");
I$1(jv, "getOwnEnumerableProperties");
var _l = Number.isNaN;
function RP(e) {
  var t = ye$1(e), r = ["Array", "Object", "Function"];
  return r.indexOf(t) !== -1;
}
o(RP, "isObjectType");
I$1(RP, "isObjectType");
function kv(e, t) {
  var r = ee(e, "operator"), n = ee(e, "negate"), i = t[3], s = n ? t[2] : t[1];
  if (r)
    return r;
  if (typeof s == "function" && (s = s()), s = s || "", !!s && !/\shave\s/.test(s)) {
    var a = RP(i);
    return /\snot\s/.test(s) ? a ? "notDeepStrictEqual" : "notStrictEqual" : a ? "deepStrictEqual" : "strictEqual";
  }
}
o(kv, "getOperator");
I$1(kv, "getOperator");
function Il(e) {
  return e.name;
}
o(Il, "getName");
I$1(Il, "getName");
function Cl(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
o(Cl, "isRegExp2");
I$1(Cl, "isRegExp");
function Ue$1(e) {
  return ["Number", "BigInt"].includes(ye$1(e));
}
o(Ue$1, "isNumeric");
I$1(Ue$1, "isNumeric");
var { flag: A$2 } = _t;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(e) {
  T$1.addProperty(e);
});
T$1.addProperty("not", function() {
  A$2(this, "negate", true);
});
T$1.addProperty("deep", function() {
  A$2(this, "deep", true);
});
T$1.addProperty("nested", function() {
  A$2(this, "nested", true);
});
T$1.addProperty("own", function() {
  A$2(this, "own", true);
});
T$1.addProperty("ordered", function() {
  A$2(this, "ordered", true);
});
T$1.addProperty("any", function() {
  A$2(this, "any", true), A$2(this, "all", false);
});
T$1.addProperty("all", function() {
  A$2(this, "all", true), A$2(this, "any", false);
});
var $C = {
  function: [
    "function",
    "asyncfunction",
    "generatorfunction",
    "asyncgeneratorfunction"
  ],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function Lv(e, t) {
  t && A$2(this, "message", t), e = e.toLowerCase();
  var r = A$2(this, "object"), n = ~["a", "e", "i", "o", "u"].indexOf(e.charAt(0)) ? "an " : "a ";
  let i = ye$1(r).toLowerCase();
  $C.function.includes(e) ? this.assert(
    $C[e].includes(i),
    "expected #{this} to be " + n + e,
    "expected #{this} not to be " + n + e
  ) : this.assert(
    e === i,
    "expected #{this} to be " + n + e,
    "expected #{this} not to be " + n + e
  );
}
o(Lv, "an");
I$1(Lv, "an");
T$1.addChainableMethod("an", Lv);
T$1.addChainableMethod("a", Lv);
function SP(e, t) {
  return _l(e) && _l(t) || e === t;
}
o(SP, "SameValueZero");
I$1(SP, "SameValueZero");
function ts() {
  A$2(this, "contains", true);
}
o(ts, "includeChainingBehavior");
I$1(ts, "includeChainingBehavior");
function rs(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = ye$1(r).toLowerCase(), i = A$2(this, "message"), s = A$2(this, "negate"), a = A$2(this, "ssfi"), l = A$2(this, "deep"), u = l ? "deep " : "", c = l ? A$2(this, "eql") : SP;
  i = i ? i + ": " : "";
  var d = false;
  switch (n) {
    case "string":
      d = r.indexOf(e) !== -1;
      break;
    case "weakset":
      if (l)
        throw new ue$1(
          i + "unable to use .deep.include with WeakSet",
          void 0,
          a
        );
      d = r.has(e);
      break;
    case "map":
      r.forEach(function(h) {
        d = d || c(h, e);
      });
      break;
    case "set":
      l ? r.forEach(function(h) {
        d = d || c(h, e);
      }) : d = r.has(e);
      break;
    case "array":
      l ? d = r.some(function(h) {
        return c(h, e);
      }) : d = r.indexOf(e) !== -1;
      break;
    default:
      if (e !== Object(e))
        throw new ue$1(
          i + "the given combination of arguments (" + n + " and " + ye$1(e).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + ye$1(e).toLowerCase(),
          void 0,
          a
        );
      var p = Object.keys(e), f = null, m = 0;
      if (p.forEach(function(h) {
        var b = new T$1(r);
        if ($t(this, b, true), A$2(b, "lockSsfi", true), !s || p.length === 1) {
          b.property(h, e[h]);
          return;
        }
        try {
          b.property(h, e[h]);
        } catch (v) {
          if (!vt$1.compatibleConstructor(v, ue$1))
            throw v;
          f === null && (f = v), m++;
        }
      }, this), s && p.length > 1 && m === p.length)
        throw f;
      return;
  }
  this.assert(
    d,
    "expected #{this} to " + u + "include " + le$1(e),
    "expected #{this} to not " + u + "include " + le$1(e)
  );
}
o(rs, "include");
I$1(rs, "include");
T$1.addChainableMethod("include", rs, ts);
T$1.addChainableMethod("contain", rs, ts);
T$1.addChainableMethod("contains", rs, ts);
T$1.addChainableMethod("includes", rs, ts);
T$1.addProperty("ok", function() {
  this.assert(
    A$2(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
T$1.addProperty("true", function() {
  this.assert(
    A$2(this, "object") === true,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !A$2(this, "negate")
  );
});
T$1.addProperty("numeric", function() {
  let e = A$2(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(ye$1(e)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !A$2(this, "negate")
  );
});
T$1.addProperty("callable", function() {
  let e = A$2(this, "object"), t = A$2(this, "ssfi"), r = A$2(this, "message"), n = r ? `${r}: ` : "", i = A$2(this, "negate"), s = i ? `${n}expected ${le$1(e)} not to be a callable function` : `${n}expected ${le$1(e)} to be a callable function`, a = [
    "Function",
    "AsyncFunction",
    "GeneratorFunction",
    "AsyncGeneratorFunction"
  ].includes(ye$1(e));
  if (a && i || !a && !i)
    throw new ue$1(s, void 0, t);
});
T$1.addProperty("false", function() {
  this.assert(
    A$2(this, "object") === false,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!A$2(this, "negate")
  );
});
T$1.addProperty("null", function() {
  this.assert(
    A$2(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
T$1.addProperty("undefined", function() {
  this.assert(
    A$2(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
T$1.addProperty("NaN", function() {
  this.assert(
    _l(A$2(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function Fv() {
  var e = A$2(this, "object");
  this.assert(
    e != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
o(Fv, "assertExist");
I$1(Fv, "assertExist");
T$1.addProperty("exist", Fv);
T$1.addProperty("exists", Fv);
T$1.addProperty("empty", function() {
  var e = A$2(this, "object"), t = A$2(this, "ssfi"), r = A$2(this, "message"), n;
  switch (r = r ? r + ": " : "", ye$1(e).toLowerCase()) {
    case "array":
    case "string":
      n = e.length;
      break;
    case "map":
    case "set":
      n = e.size;
      break;
    case "weakmap":
    case "weakset":
      throw new ue$1(
        r + ".empty was passed a weak collection",
        void 0,
        t
      );
    case "function":
      var i = r + ".empty was passed a function " + Il(e);
      throw new ue$1(i.trim(), void 0, t);
    default:
      if (e !== Object(e))
        throw new ue$1(
          r + ".empty was passed non-string primitive " + le$1(e),
          void 0,
          t
        );
      n = Object.keys(e).length;
  }
  this.assert(
    n === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function Dv() {
  var e = A$2(this, "object"), t = ye$1(e);
  this.assert(
    t === "Arguments",
    "expected #{this} to be arguments but got " + t,
    "expected #{this} to not be arguments"
  );
}
o(Dv, "checkArguments");
I$1(Dv, "checkArguments");
T$1.addProperty("arguments", Dv);
T$1.addProperty("Arguments", Dv);
function Ml(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object");
  if (A$2(this, "deep")) {
    var n = A$2(this, "lockSsfi");
    A$2(this, "lockSsfi", true), this.eql(e), A$2(this, "lockSsfi", n);
  } else
    this.assert(
      e === r,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      e,
      this._obj,
      true
    );
}
o(Ml, "assertEqual");
I$1(Ml, "assertEqual");
T$1.addMethod("equal", Ml);
T$1.addMethod("equals", Ml);
T$1.addMethod("eq", Ml);
function $v(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "eql");
  this.assert(
    r(e, A$2(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    e,
    this._obj,
    true
  );
}
o($v, "assertEql");
I$1($v, "assertEql");
T$1.addMethod("eql", $v);
T$1.addMethod("eqls", $v);
function Nl(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = A$2(this, "doLength"), i = A$2(this, "message"), s = i ? i + ": " : "", a = A$2(this, "ssfi"), l = ye$1(r).toLowerCase(), u = ye$1(e).toLowerCase();
  if (n && l !== "map" && l !== "set" && new T$1(r, i, a, true).to.have.property("length"), !n && l === "date" && u !== "date")
    throw new ue$1(
      s + "the argument to above must be a date",
      void 0,
      a
    );
  if (!Ue$1(e) && (n || Ue$1(r)))
    throw new ue$1(
      s + "the argument to above must be a number",
      void 0,
      a
    );
  if (!n && l !== "date" && !Ue$1(r)) {
    var c = l === "string" ? "'" + r + "'" : r;
    throw new ue$1(
      s + "expected " + c + " to be a number or a date",
      void 0,
      a
    );
  }
  if (n) {
    var d = "length", p;
    l === "map" || l === "set" ? (d = "size", p = r.size) : p = r.length, this.assert(
      p > e,
      "expected #{this} to have a " + d + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + d + " above #{exp}",
      e,
      p
    );
  } else
    this.assert(
      r > e,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      e
    );
}
o(Nl, "assertAbove");
I$1(Nl, "assertAbove");
T$1.addMethod("above", Nl);
T$1.addMethod("gt", Nl);
T$1.addMethod("greaterThan", Nl);
function jl(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = A$2(this, "doLength"), i = A$2(this, "message"), s = i ? i + ": " : "", a = A$2(this, "ssfi"), l = ye$1(r).toLowerCase(), u = ye$1(e).toLowerCase(), c, d = true;
  if (n && l !== "map" && l !== "set" && new T$1(r, i, a, true).to.have.property("length"), !n && l === "date" && u !== "date")
    c = s + "the argument to least must be a date";
  else if (!Ue$1(e) && (n || Ue$1(r)))
    c = s + "the argument to least must be a number";
  else if (!n && l !== "date" && !Ue$1(r)) {
    var p = l === "string" ? "'" + r + "'" : r;
    c = s + "expected " + p + " to be a number or a date";
  } else
    d = false;
  if (d)
    throw new ue$1(c, void 0, a);
  if (n) {
    var f = "length", m;
    l === "map" || l === "set" ? (f = "size", m = r.size) : m = r.length, this.assert(
      m >= e,
      "expected #{this} to have a " + f + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + f + " below #{exp}",
      e,
      m
    );
  } else
    this.assert(
      r >= e,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      e
    );
}
o(jl, "assertLeast");
I$1(jl, "assertLeast");
T$1.addMethod("least", jl);
T$1.addMethod("gte", jl);
T$1.addMethod("greaterThanOrEqual", jl);
function kl(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = A$2(this, "doLength"), i = A$2(this, "message"), s = i ? i + ": " : "", a = A$2(this, "ssfi"), l = ye$1(r).toLowerCase(), u = ye$1(e).toLowerCase(), c, d = true;
  if (n && l !== "map" && l !== "set" && new T$1(r, i, a, true).to.have.property("length"), !n && l === "date" && u !== "date")
    c = s + "the argument to below must be a date";
  else if (!Ue$1(e) && (n || Ue$1(r)))
    c = s + "the argument to below must be a number";
  else if (!n && l !== "date" && !Ue$1(r)) {
    var p = l === "string" ? "'" + r + "'" : r;
    c = s + "expected " + p + " to be a number or a date";
  } else
    d = false;
  if (d)
    throw new ue$1(c, void 0, a);
  if (n) {
    var f = "length", m;
    l === "map" || l === "set" ? (f = "size", m = r.size) : m = r.length, this.assert(
      m < e,
      "expected #{this} to have a " + f + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + f + " below #{exp}",
      e,
      m
    );
  } else
    this.assert(
      r < e,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      e
    );
}
o(kl, "assertBelow");
I$1(kl, "assertBelow");
T$1.addMethod("below", kl);
T$1.addMethod("lt", kl);
T$1.addMethod("lessThan", kl);
function Ll(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = A$2(this, "doLength"), i = A$2(this, "message"), s = i ? i + ": " : "", a = A$2(this, "ssfi"), l = ye$1(r).toLowerCase(), u = ye$1(e).toLowerCase(), c, d = true;
  if (n && l !== "map" && l !== "set" && new T$1(r, i, a, true).to.have.property("length"), !n && l === "date" && u !== "date")
    c = s + "the argument to most must be a date";
  else if (!Ue$1(e) && (n || Ue$1(r)))
    c = s + "the argument to most must be a number";
  else if (!n && l !== "date" && !Ue$1(r)) {
    var p = l === "string" ? "'" + r + "'" : r;
    c = s + "expected " + p + " to be a number or a date";
  } else
    d = false;
  if (d)
    throw new ue$1(c, void 0, a);
  if (n) {
    var f = "length", m;
    l === "map" || l === "set" ? (f = "size", m = r.size) : m = r.length, this.assert(
      m <= e,
      "expected #{this} to have a " + f + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + f + " above #{exp}",
      e,
      m
    );
  } else
    this.assert(
      r <= e,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      e
    );
}
o(Ll, "assertMost");
I$1(Ll, "assertMost");
T$1.addMethod("most", Ll);
T$1.addMethod("lte", Ll);
T$1.addMethod("lessThanOrEqual", Ll);
T$1.addMethod("within", function(e, t, r) {
  r && A$2(this, "message", r);
  var n = A$2(this, "object"), i = A$2(this, "doLength"), s = A$2(this, "message"), a = s ? s + ": " : "", l = A$2(this, "ssfi"), u = ye$1(n).toLowerCase(), c = ye$1(e).toLowerCase(), d = ye$1(t).toLowerCase(), p, f = true, m = c === "date" && d === "date" ? e.toISOString() + ".." + t.toISOString() : e + ".." + t;
  if (i && u !== "map" && u !== "set" && new T$1(n, s, l, true).to.have.property("length"), !i && u === "date" && (c !== "date" || d !== "date"))
    p = a + "the arguments to within must be dates";
  else if ((!Ue$1(e) || !Ue$1(t)) && (i || Ue$1(n)))
    p = a + "the arguments to within must be numbers";
  else if (!i && u !== "date" && !Ue$1(n)) {
    var h = u === "string" ? "'" + n + "'" : n;
    p = a + "expected " + h + " to be a number or a date";
  } else
    f = false;
  if (f)
    throw new ue$1(p, void 0, l);
  if (i) {
    var b = "length", v;
    u === "map" || u === "set" ? (b = "size", v = n.size) : v = n.length, this.assert(
      v >= e && v <= t,
      "expected #{this} to have a " + b + " within " + m,
      "expected #{this} to not have a " + b + " within " + m
    );
  } else
    this.assert(
      n >= e && n <= t,
      "expected #{this} to be within " + m,
      "expected #{this} to not be within " + m
    );
});
function Bv(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = A$2(this, "ssfi"), i = A$2(this, "message");
  try {
    var s = r instanceof e;
  } catch (l) {
    throw l instanceof TypeError ? (i = i ? i + ": " : "", new ue$1(
      i + "The instanceof assertion needs a constructor but " + ye$1(e) + " was given.",
      void 0,
      n
    )) : l;
  }
  var a = Il(e);
  a == null && (a = "an unnamed constructor"), this.assert(
    s,
    "expected #{this} to be an instance of " + a,
    "expected #{this} to not be an instance of " + a
  );
}
o(Bv, "assertInstanceOf");
I$1(Bv, "assertInstanceOf");
T$1.addMethod("instanceof", Bv);
T$1.addMethod("instanceOf", Bv);
function Hv(e, t, r) {
  r && A$2(this, "message", r);
  var n = A$2(this, "nested"), i = A$2(this, "own"), s = A$2(this, "message"), a = A$2(this, "object"), l = A$2(this, "ssfi"), u = typeof e;
  if (s = s ? s + ": " : "", n) {
    if (u !== "string")
      throw new ue$1(
        s + "the argument to property must be a string when using nested syntax",
        void 0,
        l
      );
  } else if (u !== "string" && u !== "number" && u !== "symbol")
    throw new ue$1(
      s + "the argument to property must be a string, number, or symbol",
      void 0,
      l
    );
  if (n && i)
    throw new ue$1(
      s + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      l
    );
  if (a == null)
    throw new ue$1(
      s + "Target cannot be null or undefined.",
      void 0,
      l
    );
  var c = A$2(this, "deep"), d = A$2(this, "negate"), p = n ? Cv(a, e) : null, f = n ? p.value : a[e], m = c ? A$2(this, "eql") : (v, g) => v === g, h = "";
  c && (h += "deep "), i && (h += "own "), n && (h += "nested "), h += "property ";
  var b;
  i ? b = Object.prototype.hasOwnProperty.call(a, e) : n ? b = p.exists : b = ql(a, e), (!d || arguments.length === 1) && this.assert(
    b,
    "expected #{this} to have " + h + le$1(e),
    "expected #{this} to not have " + h + le$1(e)
  ), arguments.length > 1 && this.assert(
    b && m(t, f),
    "expected #{this} to have " + h + le$1(e) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + h + le$1(e) + " of #{act}",
    t,
    f
  ), A$2(this, "object", f);
}
o(Hv, "assertProperty");
I$1(Hv, "assertProperty");
T$1.addMethod("property", Hv);
function Uv(e, t, r) {
  A$2(this, "own", true), Hv.apply(this, arguments);
}
o(Uv, "assertOwnProperty");
I$1(Uv, "assertOwnProperty");
T$1.addMethod("ownProperty", Uv);
T$1.addMethod("haveOwnProperty", Uv);
function Vv(e, t, r) {
  typeof t == "string" && (r = t, t = null), r && A$2(this, "message", r);
  var n = A$2(this, "object"), i = Object.getOwnPropertyDescriptor(Object(n), e), s = A$2(this, "eql");
  i && t ? this.assert(
    s(t, i),
    "expected the own property descriptor for " + le$1(e) + " on #{this} to match " + le$1(t) + ", got " + le$1(i),
    "expected the own property descriptor for " + le$1(e) + " on #{this} to not match " + le$1(t),
    t,
    i,
    true
  ) : this.assert(
    i,
    "expected #{this} to have an own property descriptor for " + le$1(e),
    "expected #{this} to not have an own property descriptor for " + le$1(e)
  ), A$2(this, "object", i);
}
o(Vv, "assertOwnPropertyDescriptor");
I$1(Vv, "assertOwnPropertyDescriptor");
T$1.addMethod("ownPropertyDescriptor", Vv);
T$1.addMethod("haveOwnPropertyDescriptor", Vv);
function zv() {
  A$2(this, "doLength", true);
}
o(zv, "assertLengthChain");
I$1(zv, "assertLengthChain");
function Gv(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = ye$1(r).toLowerCase(), i = A$2(this, "message"), s = A$2(this, "ssfi"), a = "length", l;
  switch (n) {
    case "map":
    case "set":
      a = "size", l = r.size;
      break;
    default:
      new T$1(r, i, s, true).to.have.property("length"), l = r.length;
  }
  this.assert(
    l == e,
    "expected #{this} to have a " + a + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + a + " of #{act}",
    e,
    l
  );
}
o(Gv, "assertLength");
I$1(Gv, "assertLength");
T$1.addChainableMethod("length", Gv, zv);
T$1.addChainableMethod("lengthOf", Gv, zv);
function Wv(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object");
  this.assert(
    e.exec(r),
    "expected #{this} to match " + e,
    "expected #{this} not to match " + e
  );
}
o(Wv, "assertMatch");
I$1(Wv, "assertMatch");
T$1.addMethod("match", Wv);
T$1.addMethod("matches", Wv);
T$1.addMethod("string", function(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = A$2(this, "message"), i = A$2(this, "ssfi");
  new T$1(r, n, i, true).is.a("string"), this.assert(
    ~r.indexOf(e),
    "expected #{this} to contain " + le$1(e),
    "expected #{this} to not contain " + le$1(e)
  );
});
function Yv(e) {
  var t = A$2(this, "object"), r = ye$1(t), n = ye$1(e), i = A$2(this, "ssfi"), s = A$2(this, "deep"), a, l = "", u, c = true, d = A$2(this, "message");
  d = d ? d + ": " : "";
  var p = d + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (r === "Map" || r === "Set")
    l = s ? "deeply " : "", u = [], t.forEach(function(w, E) {
      u.push(E);
    }), n !== "Array" && (e = Array.prototype.slice.call(arguments));
  else {
    switch (u = jv(t), n) {
      case "Array":
        if (arguments.length > 1)
          throw new ue$1(p, void 0, i);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new ue$1(p, void 0, i);
        e = Object.keys(e);
        break;
      default:
        e = Array.prototype.slice.call(arguments);
    }
    e = e.map(function(w) {
      return typeof w == "symbol" ? w : String(w);
    });
  }
  if (!e.length)
    throw new ue$1(d + "keys required", void 0, i);
  var f = e.length, m = A$2(this, "any"), h = A$2(this, "all"), b = e, v = s ? A$2(this, "eql") : (w, E) => w === E;
  if (!m && !h && (h = true), m && (c = b.some(function(w) {
    return u.some(function(E) {
      return v(w, E);
    });
  })), h && (c = b.every(function(w) {
    return u.some(function(E) {
      return v(w, E);
    });
  }), A$2(this, "contains") || (c = c && e.length == u.length)), f > 1) {
    e = e.map(function(w) {
      return le$1(w);
    });
    var g = e.pop();
    h && (a = e.join(", ") + ", and " + g), m && (a = e.join(", ") + ", or " + g);
  } else
    a = le$1(e[0]);
  a = (f > 1 ? "keys " : "key ") + a, a = (A$2(this, "contains") ? "contain " : "have ") + a, this.assert(
    c,
    "expected #{this} to " + l + a,
    "expected #{this} to not " + l + a,
    b.slice(0).sort(Sl),
    u.sort(Sl),
    true
  );
}
o(Yv, "assertKeys");
I$1(Yv, "assertKeys");
T$1.addMethod("keys", Yv);
T$1.addMethod("key", Yv);
function Fl(e, t, r) {
  r && A$2(this, "message", r);
  var n = A$2(this, "object"), i = A$2(this, "ssfi"), s = A$2(this, "message"), a = A$2(this, "negate") || false;
  new T$1(n, s, i, true).is.a("function"), (Cl(e) || typeof e == "string") && (t = e, e = null);
  let l, u = false;
  try {
    n();
  } catch (w) {
    u = true, l = w;
  }
  var c = e === void 0 && t === void 0, d = !!(e && t), p = false, f = false;
  if (c || !c && !a) {
    var m = "an error";
    e instanceof Error ? m = "#{exp}" : e && (m = vt$1.getConstructorName(e));
    let w = l;
    if (l instanceof Error)
      w = l.toString();
    else if (typeof l == "string")
      w = l;
    else if (l && (typeof l == "object" || typeof l == "function"))
      try {
        w = vt$1.getConstructorName(l);
      } catch {
      }
    this.assert(
      u,
      "expected #{this} to throw " + m,
      "expected #{this} to not throw an error but #{act} was thrown",
      e && e.toString(),
      w
    );
  }
  if (e && l) {
    if (e instanceof Error) {
      var h = vt$1.compatibleInstance(
        l,
        e
      );
      h === a && (d && a ? p = true : this.assert(
        a,
        "expected #{this} to throw #{exp} but #{act} was thrown",
        "expected #{this} to not throw #{exp}" + (l && !a ? " but #{act} was thrown" : ""),
        e.toString(),
        l.toString()
      ));
    }
    var b = vt$1.compatibleConstructor(
      l,
      e
    );
    b === a && (d && a ? p = true : this.assert(
      a,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + (l ? " but #{act} was thrown" : ""),
      e instanceof Error ? e.toString() : e && vt$1.getConstructorName(e),
      l instanceof Error ? l.toString() : l && vt$1.getConstructorName(l)
    ));
  }
  if (l && t !== void 0 && t !== null) {
    var v = "including";
    Cl(t) && (v = "matching");
    var g = vt$1.compatibleMessage(
      l,
      t
    );
    g === a && (d && a ? f = true : this.assert(
      a,
      "expected #{this} to throw error " + v + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + v + " #{exp}",
      t,
      vt$1.getMessage(l)
    ));
  }
  p && f && this.assert(
    a,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (l ? " but #{act} was thrown" : ""),
    e instanceof Error ? e.toString() : e && vt$1.getConstructorName(e),
    l instanceof Error ? l.toString() : l && vt$1.getConstructorName(l)
  ), A$2(this, "object", l);
}
o(Fl, "assertThrows");
I$1(Fl, "assertThrows");
T$1.addMethod("throw", Fl);
T$1.addMethod("throws", Fl);
T$1.addMethod("Throw", Fl);
function Kv(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = A$2(this, "itself"), i = typeof r == "function" && !n ? r.prototype[e] : r[e];
  this.assert(
    typeof i == "function",
    "expected #{this} to respond to " + le$1(e),
    "expected #{this} to not respond to " + le$1(e)
  );
}
o(Kv, "respondTo");
I$1(Kv, "respondTo");
T$1.addMethod("respondTo", Kv);
T$1.addMethod("respondsTo", Kv);
T$1.addProperty("itself", function() {
  A$2(this, "itself", true);
});
function Xv(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = e(r);
  this.assert(
    n,
    "expected #{this} to satisfy " + Rn(e),
    "expected #{this} to not satisfy" + Rn(e),
    !A$2(this, "negate"),
    n
  );
}
o(Xv, "satisfy");
I$1(Xv, "satisfy");
T$1.addMethod("satisfy", Xv);
T$1.addMethod("satisfies", Xv);
function Jv(e, t, r) {
  r && A$2(this, "message", r);
  var n = A$2(this, "object"), i = A$2(this, "message"), s = A$2(this, "ssfi");
  new T$1(n, i, s, true).is.numeric;
  let a = "A `delta` value is required for `closeTo`";
  if (t == null)
    throw new ue$1(
      i ? `${i}: ${a}` : a,
      void 0,
      s
    );
  if (new T$1(t, i, s, true).is.numeric, a = "A `expected` value is required for `closeTo`", e == null)
    throw new ue$1(
      i ? `${i}: ${a}` : a,
      void 0,
      s
    );
  new T$1(e, i, s, true).is.numeric;
  let l = /* @__PURE__ */ I$1((c) => c < 0n ? -c : c, "abs"), u = /* @__PURE__ */ I$1((c) => parseFloat(parseFloat(c).toPrecision(12)), "strip");
  this.assert(
    u(l(n - e)) <= t,
    "expected #{this} to be close to " + e + " +/- " + t,
    "expected #{this} not to be close to " + e + " +/- " + t
  );
}
o(Jv, "closeTo");
I$1(Jv, "closeTo");
T$1.addMethod("closeTo", Jv);
T$1.addMethod("approximately", Jv);
function _P(e, t, r, n, i) {
  let s = Array.from(t), a = Array.from(e);
  if (!n) {
    if (a.length !== s.length)
      return false;
    s = s.slice();
  }
  return a.every(function(l, u) {
    if (i)
      return r ? r(l, s[u]) : l === s[u];
    if (!r) {
      var c = s.indexOf(l);
      return c === -1 ? false : (n || s.splice(c, 1), true);
    }
    return s.some(function(d, p) {
      return r(l, d) ? (n || s.splice(p, 1), true) : false;
    });
  });
}
o(_P, "isSubsetOf");
I$1(_P, "isSubsetOf");
T$1.addMethod("members", function(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = A$2(this, "message"), i = A$2(this, "ssfi");
  new T$1(r, n, i, true).to.be.iterable, new T$1(e, n, i, true).to.be.iterable;
  var s = A$2(this, "contains"), a = A$2(this, "ordered"), l, u, c;
  s ? (l = a ? "an ordered superset" : "a superset", u = "expected #{this} to be " + l + " of #{exp}", c = "expected #{this} to not be " + l + " of #{exp}") : (l = a ? "ordered members" : "members", u = "expected #{this} to have the same " + l + " as #{exp}", c = "expected #{this} to not have the same " + l + " as #{exp}");
  var d = A$2(this, "deep") ? A$2(this, "eql") : void 0;
  this.assert(
    _P(e, r, d, s, a),
    u,
    c,
    e,
    r,
    true
  );
});
T$1.addProperty("iterable", function(e) {
  e && A$2(this, "message", e);
  var t = A$2(this, "object");
  this.assert(
    t != null && t[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    t
  );
});
function CP(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "object"), n = A$2(this, "message"), i = A$2(this, "ssfi"), s = A$2(this, "contains"), a = A$2(this, "deep"), l = A$2(this, "eql");
  new T$1(e, n, i, true).to.be.an("array"), s ? this.assert(
    e.some(function(u) {
      return r.indexOf(u) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    e,
    r
  ) : a ? this.assert(
    e.some(function(u) {
      return l(r, u);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    e,
    r
  ) : this.assert(
    e.indexOf(r) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    e,
    r
  );
}
o(CP, "oneOf");
I$1(CP, "oneOf");
T$1.addMethod("oneOf", CP);
function Qv(e, t, r) {
  r && A$2(this, "message", r);
  var n = A$2(this, "object"), i = A$2(this, "message"), s = A$2(this, "ssfi");
  new T$1(n, i, s, true).is.a("function");
  var a;
  t ? (new T$1(e, i, s, true).to.have.property(t), a = e[t]) : (new T$1(e, i, s, true).is.a("function"), a = e()), n();
  var l = t == null ? e() : e[t], u = t == null ? a : "." + t;
  A$2(this, "deltaMsgObj", u), A$2(this, "initialDeltaValue", a), A$2(this, "finalDeltaValue", l), A$2(this, "deltaBehavior", "change"), A$2(this, "realDelta", l !== a), this.assert(
    a !== l,
    "expected " + u + " to change",
    "expected " + u + " to not change"
  );
}
o(Qv, "assertChanges");
I$1(Qv, "assertChanges");
T$1.addMethod("change", Qv);
T$1.addMethod("changes", Qv);
function Zv(e, t, r) {
  r && A$2(this, "message", r);
  var n = A$2(this, "object"), i = A$2(this, "message"), s = A$2(this, "ssfi");
  new T$1(n, i, s, true).is.a("function");
  var a;
  t ? (new T$1(e, i, s, true).to.have.property(t), a = e[t]) : (new T$1(e, i, s, true).is.a("function"), a = e()), new T$1(a, i, s, true).is.a("number"), n();
  var l = t == null ? e() : e[t], u = t == null ? a : "." + t;
  A$2(this, "deltaMsgObj", u), A$2(this, "initialDeltaValue", a), A$2(this, "finalDeltaValue", l), A$2(this, "deltaBehavior", "increase"), A$2(this, "realDelta", l - a), this.assert(
    l - a > 0,
    "expected " + u + " to increase",
    "expected " + u + " to not increase"
  );
}
o(Zv, "assertIncreases");
I$1(Zv, "assertIncreases");
T$1.addMethod("increase", Zv);
T$1.addMethod("increases", Zv);
function eE(e, t, r) {
  r && A$2(this, "message", r);
  var n = A$2(this, "object"), i = A$2(this, "message"), s = A$2(this, "ssfi");
  new T$1(n, i, s, true).is.a("function");
  var a;
  t ? (new T$1(e, i, s, true).to.have.property(t), a = e[t]) : (new T$1(e, i, s, true).is.a("function"), a = e()), new T$1(a, i, s, true).is.a("number"), n();
  var l = t == null ? e() : e[t], u = t == null ? a : "." + t;
  A$2(this, "deltaMsgObj", u), A$2(this, "initialDeltaValue", a), A$2(this, "finalDeltaValue", l), A$2(this, "deltaBehavior", "decrease"), A$2(this, "realDelta", a - l), this.assert(
    l - a < 0,
    "expected " + u + " to decrease",
    "expected " + u + " to not decrease"
  );
}
o(eE, "assertDecreases");
I$1(eE, "assertDecreases");
T$1.addMethod("decrease", eE);
T$1.addMethod("decreases", eE);
function PP(e, t) {
  t && A$2(this, "message", t);
  var r = A$2(this, "deltaMsgObj"), n = A$2(this, "initialDeltaValue"), i = A$2(this, "finalDeltaValue"), s = A$2(this, "deltaBehavior"), a = A$2(
    this,
    "realDelta"
  ), l;
  s === "change" ? l = Math.abs(i - n) === Math.abs(e) : l = a === Math.abs(e), this.assert(
    l,
    "expected " + r + " to " + s + " by " + e,
    "expected " + r + " to not " + s + " by " + e
  );
}
o(PP, "assertDelta");
I$1(PP, "assertDelta");
T$1.addMethod("by", PP);
T$1.addProperty("extensible", function() {
  var e = A$2(this, "object"), t = e === Object(e) && Object.isExtensible(e);
  this.assert(
    t,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
T$1.addProperty("sealed", function() {
  var e = A$2(this, "object"), t = e === Object(e) ? Object.isSealed(e) : true;
  this.assert(
    t,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
T$1.addProperty("frozen", function() {
  var e = A$2(this, "object"), t = e === Object(e) ? Object.isFrozen(e) : true;
  this.assert(
    t,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
T$1.addProperty("finite", function(e) {
  var t = A$2(this, "object");
  this.assert(
    typeof t == "number" && isFinite(t),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function Pl(e, t) {
  return e === t ? true : typeof t != typeof e ? false : typeof e != "object" || e === null ? e === t : t ? Array.isArray(e) ? Array.isArray(t) ? e.every(function(r) {
    return t.some(function(n) {
      return Pl(r, n);
    });
  }) : false : e instanceof Date ? t instanceof Date ? e.getTime() === t.getTime() : false : Object.keys(e).every(function(r) {
    var n = e[r], i = t[r];
    return typeof n == "object" && n !== null && i !== null ? Pl(n, i) : typeof n == "function" ? n(i) : i === n;
  }) : false;
}
o(Pl, "compareSubset");
I$1(Pl, "compareSubset");
T$1.addMethod("containSubset", function(e) {
  let t = ee(this, "object"), r = at$1.showDiff;
  this.assert(
    Pl(e, t),
    "expected #{act} to contain subset #{exp}",
    "expected #{act} to not contain subset #{exp}",
    e,
    t,
    r
  );
});
function Lr$1(e, t) {
  return new T$1(e, t);
}
o(Lr$1, "expect");
I$1(Lr$1, "expect");
Lr$1.fail = function(e, t, r, n) {
  throw arguments.length < 2 && (r = e, e = void 0), r = r || "expect.fail()", new ue$1(
    r,
    {
      actual: e,
      expected: t,
      operator: n
    },
    Lr$1.fail
  );
};
var AP = {};
Ev(AP, {
  Should: /* @__PURE__ */ o(() => XW, "Should"),
  should: /* @__PURE__ */ o(() => KW, "should")
});
function tE() {
  function e() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new T$1(this.valueOf(), null, e) : new T$1(this, null, e);
  }
  o(e, "shouldGetter"), I$1(e, "shouldGetter");
  function t(n) {
    Object.defineProperty(this, "should", {
      value: n,
      enumerable: true,
      configurable: true,
      writable: true
    });
  }
  o(t, "shouldSetter"), I$1(t, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: t,
    get: e,
    configurable: true
  });
  var r = {};
  return r.fail = function(n, i, s, a) {
    throw arguments.length < 2 && (s = n, n = void 0), s = s || "should.fail()", new ue$1(
      s,
      {
        actual: n,
        expected: i,
        operator: a
      },
      r.fail
    );
  }, r.equal = function(n, i, s) {
    new T$1(n, s).to.equal(i);
  }, r.Throw = function(n, i, s, a) {
    new T$1(n, a).to.Throw(i, s);
  }, r.exist = function(n, i) {
    new T$1(n, i).to.exist;
  }, r.not = {}, r.not.equal = function(n, i, s) {
    new T$1(n, s).to.not.equal(i);
  }, r.not.Throw = function(n, i, s, a) {
    new T$1(n, a).to.not.Throw(i, s);
  }, r.not.exist = function(n, i) {
    new T$1(n, i).to.not.exist;
  }, r.throw = r.Throw, r.not.throw = r.not.Throw, r;
}
o(tE, "loadShould");
I$1(tE, "loadShould");
var KW = tE, XW = tE;
function x$1(e, t) {
  var r = new T$1(null, null, x$1, true);
  r.assert(e, t, "[ negation message unavailable ]");
}
o(x$1, "assert");
I$1(x$1, "assert");
x$1.fail = function(e, t, r, n) {
  throw arguments.length < 2 && (r = e, e = void 0), r = r || "assert.fail()", new ue$1(
    r,
    {
      actual: e,
      expected: t,
      operator: n
    },
    x$1.fail
  );
};
x$1.isOk = function(e, t) {
  new T$1(e, t, x$1.isOk, true).is.ok;
};
x$1.isNotOk = function(e, t) {
  new T$1(e, t, x$1.isNotOk, true).is.not.ok;
};
x$1.equal = function(e, t, r) {
  var n = new T$1(e, r, x$1.equal, true);
  n.assert(
    t == ee(n, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    t,
    e,
    true
  );
};
x$1.notEqual = function(e, t, r) {
  var n = new T$1(e, r, x$1.notEqual, true);
  n.assert(
    t != ee(n, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    t,
    e,
    true
  );
};
x$1.strictEqual = function(e, t, r) {
  new T$1(e, r, x$1.strictEqual, true).to.equal(t);
};
x$1.notStrictEqual = function(e, t, r) {
  new T$1(e, r, x$1.notStrictEqual, true).to.not.equal(t);
};
x$1.deepEqual = x$1.deepStrictEqual = function(e, t, r) {
  new T$1(e, r, x$1.deepEqual, true).to.eql(t);
};
x$1.notDeepEqual = function(e, t, r) {
  new T$1(e, r, x$1.notDeepEqual, true).to.not.eql(t);
};
x$1.isAbove = function(e, t, r) {
  new T$1(e, r, x$1.isAbove, true).to.be.above(t);
};
x$1.isAtLeast = function(e, t, r) {
  new T$1(e, r, x$1.isAtLeast, true).to.be.least(t);
};
x$1.isBelow = function(e, t, r) {
  new T$1(e, r, x$1.isBelow, true).to.be.below(t);
};
x$1.isAtMost = function(e, t, r) {
  new T$1(e, r, x$1.isAtMost, true).to.be.most(t);
};
x$1.isTrue = function(e, t) {
  new T$1(e, t, x$1.isTrue, true).is.true;
};
x$1.isNotTrue = function(e, t) {
  new T$1(e, t, x$1.isNotTrue, true).to.not.equal(true);
};
x$1.isFalse = function(e, t) {
  new T$1(e, t, x$1.isFalse, true).is.false;
};
x$1.isNotFalse = function(e, t) {
  new T$1(e, t, x$1.isNotFalse, true).to.not.equal(false);
};
x$1.isNull = function(e, t) {
  new T$1(e, t, x$1.isNull, true).to.equal(null);
};
x$1.isNotNull = function(e, t) {
  new T$1(e, t, x$1.isNotNull, true).to.not.equal(null);
};
x$1.isNaN = function(e, t) {
  new T$1(e, t, x$1.isNaN, true).to.be.NaN;
};
x$1.isNotNaN = function(e, t) {
  new T$1(e, t, x$1.isNotNaN, true).not.to.be.NaN;
};
x$1.exists = function(e, t) {
  new T$1(e, t, x$1.exists, true).to.exist;
};
x$1.notExists = function(e, t) {
  new T$1(e, t, x$1.notExists, true).to.not.exist;
};
x$1.isUndefined = function(e, t) {
  new T$1(e, t, x$1.isUndefined, true).to.equal(void 0);
};
x$1.isDefined = function(e, t) {
  new T$1(e, t, x$1.isDefined, true).to.not.equal(void 0);
};
x$1.isCallable = function(e, t) {
  new T$1(e, t, x$1.isCallable, true).is.callable;
};
x$1.isNotCallable = function(e, t) {
  new T$1(e, t, x$1.isNotCallable, true).is.not.callable;
};
x$1.isObject = function(e, t) {
  new T$1(e, t, x$1.isObject, true).to.be.a("object");
};
x$1.isNotObject = function(e, t) {
  new T$1(e, t, x$1.isNotObject, true).to.not.be.a("object");
};
x$1.isArray = function(e, t) {
  new T$1(e, t, x$1.isArray, true).to.be.an("array");
};
x$1.isNotArray = function(e, t) {
  new T$1(e, t, x$1.isNotArray, true).to.not.be.an("array");
};
x$1.isString = function(e, t) {
  new T$1(e, t, x$1.isString, true).to.be.a("string");
};
x$1.isNotString = function(e, t) {
  new T$1(e, t, x$1.isNotString, true).to.not.be.a("string");
};
x$1.isNumber = function(e, t) {
  new T$1(e, t, x$1.isNumber, true).to.be.a("number");
};
x$1.isNotNumber = function(e, t) {
  new T$1(e, t, x$1.isNotNumber, true).to.not.be.a("number");
};
x$1.isNumeric = function(e, t) {
  new T$1(e, t, x$1.isNumeric, true).is.numeric;
};
x$1.isNotNumeric = function(e, t) {
  new T$1(e, t, x$1.isNotNumeric, true).is.not.numeric;
};
x$1.isFinite = function(e, t) {
  new T$1(e, t, x$1.isFinite, true).to.be.finite;
};
x$1.isBoolean = function(e, t) {
  new T$1(e, t, x$1.isBoolean, true).to.be.a("boolean");
};
x$1.isNotBoolean = function(e, t) {
  new T$1(e, t, x$1.isNotBoolean, true).to.not.be.a("boolean");
};
x$1.typeOf = function(e, t, r) {
  new T$1(e, r, x$1.typeOf, true).to.be.a(t);
};
x$1.notTypeOf = function(e, t, r) {
  new T$1(e, r, x$1.notTypeOf, true).to.not.be.a(t);
};
x$1.instanceOf = function(e, t, r) {
  new T$1(e, r, x$1.instanceOf, true).to.be.instanceOf(t);
};
x$1.notInstanceOf = function(e, t, r) {
  new T$1(e, r, x$1.notInstanceOf, true).to.not.be.instanceOf(
    t
  );
};
x$1.include = function(e, t, r) {
  new T$1(e, r, x$1.include, true).include(t);
};
x$1.notInclude = function(e, t, r) {
  new T$1(e, r, x$1.notInclude, true).not.include(t);
};
x$1.deepInclude = function(e, t, r) {
  new T$1(e, r, x$1.deepInclude, true).deep.include(t);
};
x$1.notDeepInclude = function(e, t, r) {
  new T$1(e, r, x$1.notDeepInclude, true).not.deep.include(t);
};
x$1.nestedInclude = function(e, t, r) {
  new T$1(e, r, x$1.nestedInclude, true).nested.include(t);
};
x$1.notNestedInclude = function(e, t, r) {
  new T$1(e, r, x$1.notNestedInclude, true).not.nested.include(
    t
  );
};
x$1.deepNestedInclude = function(e, t, r) {
  new T$1(e, r, x$1.deepNestedInclude, true).deep.nested.include(
    t
  );
};
x$1.notDeepNestedInclude = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.notDeepNestedInclude,
    true
  ).not.deep.nested.include(t);
};
x$1.ownInclude = function(e, t, r) {
  new T$1(e, r, x$1.ownInclude, true).own.include(t);
};
x$1.notOwnInclude = function(e, t, r) {
  new T$1(e, r, x$1.notOwnInclude, true).not.own.include(t);
};
x$1.deepOwnInclude = function(e, t, r) {
  new T$1(e, r, x$1.deepOwnInclude, true).deep.own.include(t);
};
x$1.notDeepOwnInclude = function(e, t, r) {
  new T$1(e, r, x$1.notDeepOwnInclude, true).not.deep.own.include(
    t
  );
};
x$1.match = function(e, t, r) {
  new T$1(e, r, x$1.match, true).to.match(t);
};
x$1.notMatch = function(e, t, r) {
  new T$1(e, r, x$1.notMatch, true).to.not.match(t);
};
x$1.property = function(e, t, r) {
  new T$1(e, r, x$1.property, true).to.have.property(t);
};
x$1.notProperty = function(e, t, r) {
  new T$1(e, r, x$1.notProperty, true).to.not.have.property(t);
};
x$1.propertyVal = function(e, t, r, n) {
  new T$1(e, n, x$1.propertyVal, true).to.have.property(t, r);
};
x$1.notPropertyVal = function(e, t, r, n) {
  new T$1(e, n, x$1.notPropertyVal, true).to.not.have.property(
    t,
    r
  );
};
x$1.deepPropertyVal = function(e, t, r, n) {
  new T$1(e, n, x$1.deepPropertyVal, true).to.have.deep.property(
    t,
    r
  );
};
x$1.notDeepPropertyVal = function(e, t, r, n) {
  new T$1(
    e,
    n,
    x$1.notDeepPropertyVal,
    true
  ).to.not.have.deep.property(t, r);
};
x$1.ownProperty = function(e, t, r) {
  new T$1(e, r, x$1.ownProperty, true).to.have.own.property(t);
};
x$1.notOwnProperty = function(e, t, r) {
  new T$1(e, r, x$1.notOwnProperty, true).to.not.have.own.property(
    t
  );
};
x$1.ownPropertyVal = function(e, t, r, n) {
  new T$1(e, n, x$1.ownPropertyVal, true).to.have.own.property(
    t,
    r
  );
};
x$1.notOwnPropertyVal = function(e, t, r, n) {
  new T$1(
    e,
    n,
    x$1.notOwnPropertyVal,
    true
  ).to.not.have.own.property(t, r);
};
x$1.deepOwnPropertyVal = function(e, t, r, n) {
  new T$1(
    e,
    n,
    x$1.deepOwnPropertyVal,
    true
  ).to.have.deep.own.property(t, r);
};
x$1.notDeepOwnPropertyVal = function(e, t, r, n) {
  new T$1(
    e,
    n,
    x$1.notDeepOwnPropertyVal,
    true
  ).to.not.have.deep.own.property(t, r);
};
x$1.nestedProperty = function(e, t, r) {
  new T$1(e, r, x$1.nestedProperty, true).to.have.nested.property(
    t
  );
};
x$1.notNestedProperty = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.notNestedProperty,
    true
  ).to.not.have.nested.property(t);
};
x$1.nestedPropertyVal = function(e, t, r, n) {
  new T$1(
    e,
    n,
    x$1.nestedPropertyVal,
    true
  ).to.have.nested.property(t, r);
};
x$1.notNestedPropertyVal = function(e, t, r, n) {
  new T$1(
    e,
    n,
    x$1.notNestedPropertyVal,
    true
  ).to.not.have.nested.property(t, r);
};
x$1.deepNestedPropertyVal = function(e, t, r, n) {
  new T$1(
    e,
    n,
    x$1.deepNestedPropertyVal,
    true
  ).to.have.deep.nested.property(t, r);
};
x$1.notDeepNestedPropertyVal = function(e, t, r, n) {
  new T$1(
    e,
    n,
    x$1.notDeepNestedPropertyVal,
    true
  ).to.not.have.deep.nested.property(t, r);
};
x$1.lengthOf = function(e, t, r) {
  new T$1(e, r, x$1.lengthOf, true).to.have.lengthOf(t);
};
x$1.hasAnyKeys = function(e, t, r) {
  new T$1(e, r, x$1.hasAnyKeys, true).to.have.any.keys(t);
};
x$1.hasAllKeys = function(e, t, r) {
  new T$1(e, r, x$1.hasAllKeys, true).to.have.all.keys(t);
};
x$1.containsAllKeys = function(e, t, r) {
  new T$1(e, r, x$1.containsAllKeys, true).to.contain.all.keys(
    t
  );
};
x$1.doesNotHaveAnyKeys = function(e, t, r) {
  new T$1(e, r, x$1.doesNotHaveAnyKeys, true).to.not.have.any.keys(
    t
  );
};
x$1.doesNotHaveAllKeys = function(e, t, r) {
  new T$1(e, r, x$1.doesNotHaveAllKeys, true).to.not.have.all.keys(
    t
  );
};
x$1.hasAnyDeepKeys = function(e, t, r) {
  new T$1(e, r, x$1.hasAnyDeepKeys, true).to.have.any.deep.keys(
    t
  );
};
x$1.hasAllDeepKeys = function(e, t, r) {
  new T$1(e, r, x$1.hasAllDeepKeys, true).to.have.all.deep.keys(
    t
  );
};
x$1.containsAllDeepKeys = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.containsAllDeepKeys,
    true
  ).to.contain.all.deep.keys(t);
};
x$1.doesNotHaveAnyDeepKeys = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.doesNotHaveAnyDeepKeys,
    true
  ).to.not.have.any.deep.keys(t);
};
x$1.doesNotHaveAllDeepKeys = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.doesNotHaveAllDeepKeys,
    true
  ).to.not.have.all.deep.keys(t);
};
x$1.throws = function(e, t, r, n) {
  (typeof t == "string" || t instanceof RegExp) && (r = t, t = null);
  var i = new T$1(e, n, x$1.throws, true).to.throw(
    t,
    r
  );
  return ee(i, "object");
};
x$1.doesNotThrow = function(e, t, r, n) {
  (typeof t == "string" || t instanceof RegExp) && (r = t, t = null), new T$1(e, n, x$1.doesNotThrow, true).to.not.throw(
    t,
    r
  );
};
x$1.operator = function(e, t, r, n) {
  var i;
  switch (t) {
    case "==":
      i = e == r;
      break;
    case "===":
      i = e === r;
      break;
    case ">":
      i = e > r;
      break;
    case ">=":
      i = e >= r;
      break;
    case "<":
      i = e < r;
      break;
    case "<=":
      i = e <= r;
      break;
    case "!=":
      i = e != r;
      break;
    case "!==":
      i = e !== r;
      break;
    default:
      throw n = n && n + ": ", new ue$1(
        n + 'Invalid operator "' + t + '"',
        void 0,
        x$1.operator
      );
  }
  var s = new T$1(i, n, x$1.operator, true);
  s.assert(
    ee(s, "object") === true,
    "expected " + le$1(e) + " to be " + t + " " + le$1(r),
    "expected " + le$1(e) + " to not be " + t + " " + le$1(r)
  );
};
x$1.closeTo = function(e, t, r, n) {
  new T$1(e, n, x$1.closeTo, true).to.be.closeTo(t, r);
};
x$1.approximately = function(e, t, r, n) {
  new T$1(e, n, x$1.approximately, true).to.be.approximately(
    t,
    r
  );
};
x$1.sameMembers = function(e, t, r) {
  new T$1(e, r, x$1.sameMembers, true).to.have.same.members(t);
};
x$1.notSameMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.notSameMembers,
    true
  ).to.not.have.same.members(t);
};
x$1.sameDeepMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.sameDeepMembers,
    true
  ).to.have.same.deep.members(t);
};
x$1.notSameDeepMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.notSameDeepMembers,
    true
  ).to.not.have.same.deep.members(t);
};
x$1.sameOrderedMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.sameOrderedMembers,
    true
  ).to.have.same.ordered.members(t);
};
x$1.notSameOrderedMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.notSameOrderedMembers,
    true
  ).to.not.have.same.ordered.members(t);
};
x$1.sameDeepOrderedMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.sameDeepOrderedMembers,
    true
  ).to.have.same.deep.ordered.members(t);
};
x$1.notSameDeepOrderedMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.notSameDeepOrderedMembers,
    true
  ).to.not.have.same.deep.ordered.members(t);
};
x$1.includeMembers = function(e, t, r) {
  new T$1(e, r, x$1.includeMembers, true).to.include.members(
    t
  );
};
x$1.notIncludeMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.notIncludeMembers,
    true
  ).to.not.include.members(t);
};
x$1.includeDeepMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.includeDeepMembers,
    true
  ).to.include.deep.members(t);
};
x$1.notIncludeDeepMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.notIncludeDeepMembers,
    true
  ).to.not.include.deep.members(t);
};
x$1.includeOrderedMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.includeOrderedMembers,
    true
  ).to.include.ordered.members(t);
};
x$1.notIncludeOrderedMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.notIncludeOrderedMembers,
    true
  ).to.not.include.ordered.members(t);
};
x$1.includeDeepOrderedMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.includeDeepOrderedMembers,
    true
  ).to.include.deep.ordered.members(t);
};
x$1.notIncludeDeepOrderedMembers = function(e, t, r) {
  new T$1(
    e,
    r,
    x$1.notIncludeDeepOrderedMembers,
    true
  ).to.not.include.deep.ordered.members(t);
};
x$1.oneOf = function(e, t, r) {
  new T$1(e, r, x$1.oneOf, true).to.be.oneOf(t);
};
x$1.isIterable = function(e, t) {
  if (e == null || !e[Symbol.iterator])
    throw t = t ? `${t} expected ${le$1(e)} to be an iterable` : `expected ${le$1(e)} to be an iterable`, new ue$1(t, void 0, x$1.isIterable);
};
x$1.changes = function(e, t, r, n) {
  arguments.length === 3 && typeof t == "function" && (n = r, r = null), new T$1(e, n, x$1.changes, true).to.change(t, r);
};
x$1.changesBy = function(e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = n;
    n = r, i = s;
  } else arguments.length === 3 && (n = r, r = null);
  new T$1(e, i, x$1.changesBy, true).to.change(t, r).by(n);
};
x$1.doesNotChange = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new T$1(e, n, x$1.doesNotChange, true).to.not.change(
    t,
    r
  );
};
x$1.changesButNotBy = function(e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = n;
    n = r, i = s;
  } else arguments.length === 3 && (n = r, r = null);
  new T$1(e, i, x$1.changesButNotBy, true).to.change(t, r).but.not.by(n);
};
x$1.increases = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new T$1(e, n, x$1.increases, true).to.increase(t, r);
};
x$1.increasesBy = function(e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = n;
    n = r, i = s;
  } else arguments.length === 3 && (n = r, r = null);
  new T$1(e, i, x$1.increasesBy, true).to.increase(t, r).by(n);
};
x$1.doesNotIncrease = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new T$1(e, n, x$1.doesNotIncrease, true).to.not.increase(
    t,
    r
  );
};
x$1.increasesButNotBy = function(e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = n;
    n = r, i = s;
  } else arguments.length === 3 && (n = r, r = null);
  new T$1(e, i, x$1.increasesButNotBy, true).to.increase(t, r).but.not.by(n);
};
x$1.decreases = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new T$1(e, n, x$1.decreases, true).to.decrease(t, r);
};
x$1.decreasesBy = function(e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = n;
    n = r, i = s;
  } else arguments.length === 3 && (n = r, r = null);
  new T$1(e, i, x$1.decreasesBy, true).to.decrease(t, r).by(n);
};
x$1.doesNotDecrease = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new T$1(e, n, x$1.doesNotDecrease, true).to.not.decrease(
    t,
    r
  );
};
x$1.doesNotDecreaseBy = function(e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = n;
    n = r, i = s;
  } else arguments.length === 3 && (n = r, r = null);
  return new T$1(e, i, x$1.doesNotDecreaseBy, true).to.not.decrease(t, r).by(n);
};
x$1.decreasesButNotBy = function(e, t, r, n, i) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = n;
    n = r, i = s;
  } else arguments.length === 3 && (n = r, r = null);
  new T$1(e, i, x$1.decreasesButNotBy, true).to.decrease(t, r).but.not.by(n);
};
x$1.ifError = function(e) {
  if (e)
    throw e;
};
x$1.isExtensible = function(e, t) {
  new T$1(e, t, x$1.isExtensible, true).to.be.extensible;
};
x$1.isNotExtensible = function(e, t) {
  new T$1(e, t, x$1.isNotExtensible, true).to.not.be.extensible;
};
x$1.isSealed = function(e, t) {
  new T$1(e, t, x$1.isSealed, true).to.be.sealed;
};
x$1.isNotSealed = function(e, t) {
  new T$1(e, t, x$1.isNotSealed, true).to.not.be.sealed;
};
x$1.isFrozen = function(e, t) {
  new T$1(e, t, x$1.isFrozen, true).to.be.frozen;
};
x$1.isNotFrozen = function(e, t) {
  new T$1(e, t, x$1.isNotFrozen, true).to.not.be.frozen;
};
x$1.isEmpty = function(e, t) {
  new T$1(e, t, x$1.isEmpty, true).to.be.empty;
};
x$1.isNotEmpty = function(e, t) {
  new T$1(e, t, x$1.isNotEmpty, true).to.not.be.empty;
};
x$1.containsSubset = function(e, t, r) {
  new T$1(e, r).to.containSubset(t);
};
x$1.doesNotContainSubset = function(e, t, r) {
  new T$1(e, r).to.not.containSubset(t);
};
var JW = [
  ["isOk", "ok"],
  ["isNotOk", "notOk"],
  ["throws", "throw"],
  ["throws", "Throw"],
  ["isExtensible", "extensible"],
  ["isNotExtensible", "notExtensible"],
  ["isSealed", "sealed"],
  ["isNotSealed", "notSealed"],
  ["isFrozen", "frozen"],
  ["isNotFrozen", "notFrozen"],
  ["isEmpty", "empty"],
  ["isNotEmpty", "notEmpty"],
  ["isCallable", "isFunction"],
  ["isNotCallable", "isNotFunction"],
  ["containsSubset", "containSubset"]
];
for (let [e, t] of JW)
  x$1[t] = x$1[e];
var BC = [];
function Fr$1(e) {
  let t = {
    use: Fr$1,
    AssertionError: ue$1,
    util: _t,
    config: at$1,
    expect: Lr$1,
    assert: x$1,
    Assertion: T$1,
    ...AP
  };
  return ~BC.indexOf(e) || (e(t, _t), BC.push(e)), t;
}
o(Fr$1, "use");
I$1(Fr$1, "use");
var Fx = {};
st$1(Fx, {
  toBeChecked: () => Ax,
  toBeDisabled: () => wx,
  toBeEmpty: () => px,
  toBeEmptyDOMElement: () => fx,
  toBeEnabled: () => Tx,
  toBeInTheDOM: () => Jd,
  toBeInTheDocument: () => dx,
  toBeInvalid: () => Sx,
  toBePartiallyChecked: () => Ox,
  toBeRequired: () => Rx,
  toBeValid: () => _x,
  toBeVisible: () => xx,
  toContainElement: () => Qd,
  toContainHTML: () => mx,
  toHaveAccessibleDescription: () => Zd,
  toHaveAccessibleErrorMessage: () => yx,
  toHaveAccessibleName: () => tp,
  toHaveAttribute: () => bx,
  toHaveClass: () => gx,
  toHaveDescription: () => qx,
  toHaveDisplayValue: () => Px,
  toHaveErrorMessage: () => Ix,
  toHaveFocus: () => vx,
  toHaveFormValues: () => Ex,
  toHaveRole: () => ep,
  toHaveSelection: () => Mx,
  toHaveStyle: () => rp,
  toHaveTextContent: () => hx,
  toHaveValue: () => Cx
});
var lx = Ne(rE(), 1);
function LP(e) {
  Object.defineProperty(e, "__esModule", { value: true, configurable: true });
}
o(LP, "$parcel$defineInteropFlag");
function iE(e, t, r, n) {
  Object.defineProperty(e, t, { get: r, set: n, enumerable: true, configurable: true });
}
o(iE, "$parcel$export");
var FP = {};
LP(FP);
iE(FP, "default", () => Dl);
var sE = class sE2 extends Error {
  constructor(t, r, n, i, s) {
    super(t + ":" + n + ":" + i + ": " + r), this.reason = r, this.filename = t, this.line = n, this.column = i, this.source = s;
  }
};
o(sE, "$009ddb00d3ec72b8$export$2e2bcd8739ae039");
var Dl = sE, DP = {};
LP(DP);
iE(DP, "default", () => $l);
var aE = class aE2 {
  constructor(t, r, n) {
    this.start = t, this.end = r, this.source = n;
  }
};
o(aE, "$0865a9fb4cc365fe$export$2e2bcd8739ae039");
var $l = aE, r8 = {};
iE(r8, "CssTypes", () => Ve$1);
var Ve$1 = /* @__PURE__ */ function(e) {
  return e.stylesheet = "stylesheet", e.rule = "rule", e.declaration = "declaration", e.comment = "comment", e.container = "container", e.charset = "charset", e.document = "document", e.customMedia = "custom-media", e.fontFace = "font-face", e.host = "host", e.import = "import", e.keyframes = "keyframes", e.keyframe = "keyframe", e.layer = "layer", e.media = "media", e.namespace = "namespace", e.page = "page", e.startingStyle = "starting-style", e.supports = "supports", e;
}({}), nE = /\/\*[^]*?(?:\*\/|$)/g, n8 = /* @__PURE__ */ o((e, t) => {
  t = t || {};
  let r = 1, n = 1;
  function i(F) {
    let j = F.match(/\n/g);
    j && (r += j.length);
    let K = F.lastIndexOf(`
`);
    n = ~K ? F.length - K : n + F.length;
  }
  o(i, "updatePosition");
  function s() {
    let F = {
      line: r,
      column: n
    };
    return function(j) {
      return j.position = new $l(F, {
        line: r,
        column: n
      }, t?.source || ""), m(), j;
    };
  }
  o(s, "position");
  let a = [];
  function l(F) {
    let j = new Dl(t?.source || "", F, r, n, e);
    if (t?.silent) a.push(j);
    else throw j;
  }
  o(l, "error");
  function u() {
    let F = p();
    return {
      type: Ve$1.stylesheet,
      stylesheet: {
        source: t?.source,
        rules: F,
        parsingErrors: a
      }
    };
  }
  o(u, "stylesheet");
  function c() {
    return f(/^{\s*/);
  }
  o(c, "open");
  function d() {
    return f(/^}/);
  }
  o(d, "close");
  function p() {
    let F, j = [];
    for (m(), h(j); e.length && e.charAt(0) !== "}" && (F = pe() || Oe()); ) F && (j.push(F), h(j));
    return j;
  }
  o(p, "rules");
  function f(F) {
    let j = F.exec(e);
    if (!j) return;
    let K = j[0];
    return i(K), e = e.slice(K.length), j;
  }
  o(f, "match");
  function m() {
    f(/^\s*/);
  }
  o(m, "whitespace");
  function h(F) {
    let j;
    for (F = F || []; j = b(); ) j && F.push(j);
    return F;
  }
  o(h, "comments");
  function b() {
    let F = s();
    if (e.charAt(0) !== "/" || e.charAt(1) !== "*") return;
    let j = f(/^\/\*[^]*?\*\//);
    return j ? F({
      type: Ve$1.comment,
      comment: j[0].slice(2, -2)
    }) : l("End of comment missing");
  }
  o(b, "comment");
  function v(F, j, K) {
    let G = j + 1, Z = false, ve = F.indexOf(")", G);
    for (; !Z && ve !== -1; ) {
      let qe = F.indexOf("(", G);
      qe !== -1 && qe < ve ? (G = v(F, qe + 1) + 1, ve = F.indexOf(")", G)) : Z = true;
    }
    return Z && ve !== -1 ? ve : -1;
  }
  o(v, "findClosingParenthese");
  function g() {
    let F = f(/^([^{]+)/);
    if (!F) return;
    let j = Pt$1(F[0]).replace(nE, "");
    if (j.indexOf(",") === -1) return [
      j
    ];
    let K = 0, G = j.indexOf("(", K);
    for (; G !== -1; ) {
      let Z = v(j, G);
      if (Z === -1) break;
      K = Z + 1, j = j.substring(0, G) + j.substring(G, Z).replace(/,/g, "") + j.substring(Z), G = j.indexOf("(", K);
    }
    return j = j.replace(/("|')(?:\\\1|.)*?\1/g, (Z) => Z.replace(/,/g, "")), j.split(",").map((Z) => Pt$1(Z.replace(/\u200C/g, ",")));
  }
  o(g, "selector");
  function w() {
    let F = s(), j = f(/^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
    if (!j) return;
    let K = Pt$1(j[0]);
    if (!f(/^:\s*/)) return l("property missing ':'");
    let G = f(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|[^)])*?\)|[^};])+)/), Z = F({
      type: Ve$1.declaration,
      property: K.replace(nE, ""),
      value: G ? Pt$1(G[0]).replace(nE, "") : ""
    });
    return f(/^[;\s]*/), Z;
  }
  o(w, "declaration");
  function E() {
    let F = [];
    if (!c()) return l("missing '{'");
    h(F);
    let j;
    for (; j = w(); ) j && (F.push(j), h(F));
    return d() ? F : l("missing '}'");
  }
  o(E, "declarations");
  function R() {
    let F, j = [], K = s();
    for (; F = f(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/); )
      j.push(F[1]), f(/^,\s*/);
    if (j.length)
      return K({
        type: Ve$1.keyframe,
        values: j,
        declarations: E() || []
      });
  }
  o(R, "keyframe");
  function S() {
    let F = s(), j = f(/^@([-\w]+)?keyframes\s*/);
    if (!j) return;
    let K = j[1], G = f(/^([-\w]+)\s*/);
    if (!G) return l("@keyframes missing name");
    let Z = G[1];
    if (!c()) return l("@keyframes missing '{'");
    let ve, qe = h();
    for (; ve = R(); )
      qe.push(ve), qe = qe.concat(h());
    return d() ? F({
      type: Ve$1.keyframes,
      name: Z,
      vendor: K,
      keyframes: qe
    }) : l("@keyframes missing '}'");
  }
  o(S, "atkeyframes");
  function P() {
    let F = s(), j = f(/^@supports *([^{]+)/);
    if (!j) return;
    let K = Pt$1(j[1]);
    if (!c()) return l("@supports missing '{'");
    let G = h().concat(p());
    return d() ? F({
      type: Ve$1.supports,
      supports: K,
      rules: G
    }) : l("@supports missing '}'");
  }
  o(P, "atsupports");
  function _() {
    let F = s();
    if (!f(/^@host\s*/)) return;
    if (!c()) return l("@host missing '{'");
    let K = h().concat(p());
    return d() ? F({
      type: Ve$1.host,
      rules: K
    }) : l("@host missing '}'");
  }
  o(_, "athost");
  function C() {
    let F = s(), j = f(/^@container *([^{]+)/);
    if (!j) return;
    let K = Pt$1(j[1]);
    if (!c()) return l("@container missing '{'");
    let G = h().concat(p());
    return d() ? F({
      type: Ve$1.container,
      container: K,
      rules: G
    }) : l("@container missing '}'");
  }
  o(C, "atcontainer");
  function O() {
    let F = s(), j = f(/^@layer *([^{;@]+)/);
    if (!j) return;
    let K = Pt$1(j[1]);
    if (!c())
      return f(/^[;\s]*/), F({
        type: Ve$1.layer,
        layer: K
      });
    let G = h().concat(p());
    return d() ? F({
      type: Ve$1.layer,
      layer: K,
      rules: G
    }) : l("@layer missing '}'");
  }
  o(O, "atlayer");
  function L() {
    let F = s(), j = f(/^@media *([^{]+)/);
    if (!j) return;
    let K = Pt$1(j[1]);
    if (!c()) return l("@media missing '{'");
    let G = h().concat(p());
    return d() ? F({
      type: Ve$1.media,
      media: K,
      rules: G
    }) : l("@media missing '}'");
  }
  o(L, "atmedia");
  function q() {
    let F = s(), j = f(/^@custom-media\s+(--\S+)\s*([^{;\s][^{;]*);/);
    if (j)
      return F({
        type: Ve$1.customMedia,
        name: Pt$1(j[1]),
        media: Pt$1(j[2])
      });
  }
  o(q, "atcustommedia");
  function D() {
    let F = s();
    if (!f(/^@page */)) return;
    let K = g() || [];
    if (!c()) return l("@page missing '{'");
    let G = h(), Z;
    for (; Z = w(); )
      G.push(Z), G = G.concat(h());
    return d() ? F({
      type: Ve$1.page,
      selectors: K,
      declarations: G
    }) : l("@page missing '}'");
  }
  o(D, "atpage");
  function H() {
    let F = s(), j = f(/^@([-\w]+)?document *([^{]+)/);
    if (!j) return;
    let K = Pt$1(j[1]), G = Pt$1(j[2]);
    if (!c()) return l("@document missing '{'");
    let Z = h().concat(p());
    return d() ? F({
      type: Ve$1.document,
      document: G,
      vendor: K,
      rules: Z
    }) : l("@document missing '}'");
  }
  o(H, "atdocument");
  function M() {
    let F = s();
    if (!f(/^@font-face\s*/)) return;
    if (!c()) return l("@font-face missing '{'");
    let K = h(), G;
    for (; G = w(); )
      K.push(G), K = K.concat(h());
    return d() ? F({
      type: Ve$1.fontFace,
      declarations: K
    }) : l("@font-face missing '}'");
  }
  o(M, "atfontface");
  function U() {
    let F = s();
    if (!f(/^@starting-style\s*/)) return;
    if (!c()) return l("@starting-style missing '{'");
    let K = h().concat(p());
    return d() ? F({
      type: Ve$1.startingStyle,
      rules: K
    }) : l("@starting-style missing '}'");
  }
  o(U, "atstartingstyle");
  let N = ae("import"), W = ae("charset"), Y = ae("namespace");
  function ae(F) {
    let j = new RegExp("^@" + F + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`);
    return function() {
      let K = s(), G = f(j);
      if (!G) return;
      let Z = {
        type: F
      };
      return Z[F] = G[1].trim(), K(Z);
    };
  }
  o(ae, "_compileAtrule");
  function pe() {
    if (e[0] === "@")
      return S() || L() || q() || P() || N() || W() || Y() || H() || D() || _() || M() || C() || U() || O();
  }
  o(pe, "atrule");
  function Oe() {
    let F = s(), j = g();
    return j ? (h(), F({
      type: Ve$1.rule,
      selectors: j,
      declarations: E() || []
    })) : l("selector missing");
  }
  return o(Oe, "rule"), oE(u());
}, "$d708735ed1303b43$export$98e6a39c04603d36");
function Pt$1(e) {
  return e ? e.trim() : "";
}
o(Pt$1, "$d708735ed1303b43$var$trim");
function oE(e, t) {
  let r = e && typeof e.type == "string", n = r ? e : t;
  for (let i in e) {
    let s = e[i];
    Array.isArray(s) ? s.forEach((a) => {
      oE(a, n);
    }) : s && typeof s == "object" && oE(s, n);
  }
  return r && Object.defineProperty(e, "parent", {
    configurable: true,
    writable: true,
    enumerable: false,
    value: t || null
  }), e;
}
o(oE, "$d708735ed1303b43$var$addParent");
var o8 = n8;
var $P = o8;
var i8 = Object.prototype.toString;
function BP(e) {
  return typeof e == "function" || i8.call(e) === "[object Function]";
}
o(BP, "isCallable");
function s8(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
o(s8, "toInteger");
var a8 = Math.pow(2, 53) - 1;
function l8(e) {
  var t = s8(e);
  return Math.min(Math.max(t, 0), a8);
}
o(l8, "toLength");
function Et$1(e, t) {
  var r = Array, n = Object(e);
  if (e == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof t < "u" && !BP(t))
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var i = l8(n.length), s = BP(r) ? Object(new r(i)) : new Array(i), a = 0, l; a < i; )
    l = n[a], t ? s[a] = t(l, a) : s[a] = l, a += 1;
  return s.length = i, s;
}
o(Et$1, "arrayFrom");
function ns(e) {
  "@babel/helpers - typeof";
  return ns = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ns(e);
}
o(ns, "_typeof");
function u8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
o(u8, "_classCallCheck");
function HP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, UP(n.key), n);
  }
}
o(HP, "_defineProperties");
function c8(e, t, r) {
  return t && HP(e.prototype, t), r && HP(e, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
o(c8, "_createClass");
function d8(e, t, r) {
  return t = UP(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
}
o(d8, "_defineProperty");
function UP(e) {
  var t = p8(e, "string");
  return ns(t) === "symbol" ? t : String(t);
}
o(UP, "_toPropertyKey");
function p8(e, t) {
  if (ns(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (ns(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
o(p8, "_toPrimitive");
var f8 = /* @__PURE__ */ function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    u8(this, e), d8(this, "items", void 0), this.items = t;
  }
  return o(e, "SetLike"), c8(e, [{
    key: "add",
    value: /* @__PURE__ */ o(function(r) {
      return this.has(r) === false && this.items.push(r), this;
    }, "add")
  }, {
    key: "clear",
    value: /* @__PURE__ */ o(function() {
      this.items = [];
    }, "clear")
  }, {
    key: "delete",
    value: /* @__PURE__ */ o(function(r) {
      var n = this.items.length;
      return this.items = this.items.filter(function(i) {
        return i !== r;
      }), n !== this.items.length;
    }, "_delete")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ o(function(r) {
      var n = this;
      this.items.forEach(function(i) {
        r(i, i, n);
      });
    }, "forEach")
  }, {
    key: "has",
    value: /* @__PURE__ */ o(function(r) {
      return this.items.indexOf(r) !== -1;
    }, "has")
  }, {
    key: "size",
    get: /* @__PURE__ */ o(function() {
      return this.items.length;
    }, "get")
  }]), e;
}(), VP = typeof Set > "u" ? Set : f8;
function ke(e) {
  var t;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (t = e.localName) !== null && t !== void 0 ? t : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      e.tagName.toLowerCase()
    )
  );
}
o(ke, "getLocalName");
var m8 = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, h8 = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  none: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function y8(e, t) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-description",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(r) {
    var n;
    return e.hasAttribute(r) && !((n = h8[t]) !== null && n !== void 0 && n.has(r));
  });
}
o(y8, "hasGlobalAriaAttributes");
function zP(e, t) {
  return y8(e, t);
}
o(zP, "ignorePresentationalRole");
function Bl(e) {
  var t = g8(e);
  if (t === null || os.indexOf(t) !== -1) {
    var r = b8(e);
    if (os.indexOf(t || "") === -1 || zP(e, r || ""))
      return r;
  }
  return t;
}
o(Bl, "getRole");
function b8(e) {
  var t = m8[ke(e)];
  if (t !== void 0)
    return t;
  switch (ke(e)) {
    case "a":
    case "area":
    case "link":
      if (e.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return e.getAttribute("alt") === "" && !zP(e, "img") ? "presentation" : "img";
    case "input": {
      var r = e, n = r.type;
      switch (n) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return n;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return e.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return e.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
o(b8, "getImplicitRole");
function g8(e) {
  var t = e.getAttribute("role");
  if (t !== null) {
    var r = t.trim().split(" ")[0];
    if (r.length > 0)
      return r;
  }
  return null;
}
o(g8, "getExplicitRole");
var os = ["presentation", "none"];
function Re$1(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
o(Re$1, "isElement");
function lE(e) {
  return Re$1(e) && ke(e) === "caption";
}
o(lE, "isHTMLTableCaptionElement");
function is(e) {
  return Re$1(e) && ke(e) === "input";
}
o(is, "isHTMLInputElement");
function GP(e) {
  return Re$1(e) && ke(e) === "optgroup";
}
o(GP, "isHTMLOptGroupElement");
function WP(e) {
  return Re$1(e) && ke(e) === "select";
}
o(WP, "isHTMLSelectElement");
function YP(e) {
  return Re$1(e) && ke(e) === "table";
}
o(YP, "isHTMLTableElement");
function KP(e) {
  return Re$1(e) && ke(e) === "textarea";
}
o(KP, "isHTMLTextAreaElement");
function XP(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument, r = t.defaultView;
  if (r === null)
    throw new TypeError("no window available");
  return r;
}
o(XP, "safeWindow");
function JP(e) {
  return Re$1(e) && ke(e) === "fieldset";
}
o(JP, "isHTMLFieldSetElement");
function QP(e) {
  return Re$1(e) && ke(e) === "legend";
}
o(QP, "isHTMLLegendElement");
function ZP(e) {
  return Re$1(e) && ke(e) === "slot";
}
o(ZP, "isHTMLSlotElement");
function v8(e) {
  return Re$1(e) && e.ownerSVGElement !== void 0;
}
o(v8, "isSVGElement");
function e0(e) {
  return Re$1(e) && ke(e) === "svg";
}
o(e0, "isSVGSVGElement");
function t0(e) {
  return v8(e) && ke(e) === "title";
}
o(t0, "isSVGTitleElement");
function Ao(e, t) {
  if (Re$1(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(" "), n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r.map(function(i) {
      return n.getElementById(i);
    }).filter(
      function(i) {
        return i !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
o(Ao, "queryIdRefs");
function Bt(e, t) {
  return Re$1(e) ? t.indexOf(Bl(e)) !== -1 : false;
}
o(Bt, "hasAnyConcreteRoles");
function E8(e) {
  return e.trim().replace(/\s\s+/g, " ");
}
o(E8, "asFlatString");
function x8(e, t) {
  if (!Re$1(e))
    return false;
  if (e.hasAttribute("hidden") || e.getAttribute("aria-hidden") === "true")
    return true;
  var r = t(e);
  return r.getPropertyValue("display") === "none" || r.getPropertyValue("visibility") === "hidden";
}
o(x8, "isHidden");
function w8(e) {
  return Bt(e, ["button", "combobox", "listbox", "textbox"]) || o0(e, "range");
}
o(w8, "isControl");
function o0(e, t) {
  if (!Re$1(e))
    return false;
  switch (t) {
    case "range":
      return Bt(e, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(t, "'. This is likely a bug :("));
  }
}
o(o0, "hasAbstractRole");
function r0(e, t) {
  var r = Et$1(e.querySelectorAll(t));
  return Ao(e, "aria-owns").forEach(function(n) {
    r.push.apply(r, Et$1(n.querySelectorAll(t)));
  }), r;
}
o(r0, "querySelectorAllSubtree");
function T8(e) {
  return WP(e) ? e.selectedOptions || r0(e, "[selected]") : r0(e, '[aria-selected="true"]');
}
o(T8, "querySelectedOptions");
function R8(e) {
  return Bt(e, os);
}
o(R8, "isMarkedPresentational");
function S8(e) {
  return lE(e);
}
o(S8, "isNativeHostLanguageTextAlternativeElement");
function _8(e) {
  return Bt(e, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
o(_8, "allowsNameFromContent");
function C8(e) {
  return false;
}
o(C8, "isDescendantOfNativeHostLanguageTextAlternativeElement");
function P8(e) {
  return is(e) || KP(e) ? e.value : e.textContent || "";
}
o(P8, "getValueOfTextbox");
function n0(e) {
  var t = e.getPropertyValue("content");
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : "";
}
o(n0, "getTextualContent");
function i0(e) {
  var t = ke(e);
  return t === "button" || t === "input" && e.getAttribute("type") !== "hidden" || t === "meter" || t === "output" || t === "progress" || t === "select" || t === "textarea";
}
o(i0, "isLabelableElement");
function s0(e) {
  if (i0(e))
    return e;
  var t = null;
  return e.childNodes.forEach(function(r) {
    if (t === null && Re$1(r)) {
      var n = s0(r);
      n !== null && (t = n);
    }
  }), t;
}
o(s0, "findLabelableElement");
function A8(e) {
  if (e.control !== void 0)
    return e.control;
  var t = e.getAttribute("for");
  return t !== null ? e.ownerDocument.getElementById(t) : s0(e);
}
o(A8, "getControlOfLabel");
function O8(e) {
  var t = e.labels;
  if (t === null)
    return t;
  if (t !== void 0)
    return Et$1(t);
  if (!i0(e))
    return null;
  var r = e.ownerDocument;
  return Et$1(r.querySelectorAll("label")).filter(function(n) {
    return A8(n) === e;
  });
}
o(O8, "getLabels");
function q8(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? Et$1(e.childNodes) : t;
}
o(q8, "getSlotContents");
function Hl(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = new VP(), n = XP(e), i = t.compute, s = i === void 0 ? "name" : i, a = t.computedStyleSupportsPseudoElements, l = a === void 0 ? t.getComputedStyle !== void 0 : a, u = t.getComputedStyle, c = u === void 0 ? n.getComputedStyle.bind(n) : u, d = t.hidden, p = d === void 0 ? false : d;
  function f(g, w) {
    var E = "";
    if (Re$1(g) && l) {
      var R = c(g, "::before"), S = n0(R);
      E = "".concat(S, " ").concat(E);
    }
    var P = ZP(g) ? q8(g) : Et$1(g.childNodes).concat(Ao(g, "aria-owns"));
    if (P.forEach(function(O) {
      var L = v(O, {
        isEmbeddedInLabel: w.isEmbeddedInLabel,
        isReferenced: false,
        recursion: true
      }), q = Re$1(O) ? c(O).getPropertyValue("display") : "inline", D = q !== "inline" ? " " : "";
      E += "".concat(D).concat(L).concat(D);
    }), Re$1(g) && l) {
      var _ = c(g, "::after"), C = n0(_);
      E = "".concat(E, " ").concat(C);
    }
    return E.trim();
  }
  o(f, "computeMiscTextAlternative");
  function m(g, w) {
    var E = g.getAttributeNode(w);
    return E !== null && !r.has(E) && E.value.trim() !== "" ? (r.add(E), E.value) : null;
  }
  o(m, "useAttribute");
  function h(g) {
    return Re$1(g) ? m(g, "title") : null;
  }
  o(h, "computeTooltipAttributeValue");
  function b(g) {
    if (!Re$1(g))
      return null;
    if (JP(g)) {
      r.add(g);
      for (var w = Et$1(g.childNodes), E = 0; E < w.length; E += 1) {
        var R = w[E];
        if (QP(R))
          return v(R, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
      }
    } else if (YP(g)) {
      r.add(g);
      for (var S = Et$1(g.childNodes), P = 0; P < S.length; P += 1) {
        var _ = S[P];
        if (lE(_))
          return v(_, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
      }
    } else if (e0(g)) {
      r.add(g);
      for (var C = Et$1(g.childNodes), O = 0; O < C.length; O += 1) {
        var L = C[O];
        if (t0(L))
          return L.textContent;
      }
      return null;
    } else if (ke(g) === "img" || ke(g) === "area") {
      var q = m(g, "alt");
      if (q !== null)
        return q;
    } else if (GP(g)) {
      var D = m(g, "label");
      if (D !== null)
        return D;
    }
    if (is(g) && (g.type === "button" || g.type === "submit" || g.type === "reset")) {
      var H = m(g, "value");
      if (H !== null)
        return H;
      if (g.type === "submit")
        return "Submit";
      if (g.type === "reset")
        return "Reset";
    }
    var M = O8(g);
    if (M !== null && M.length !== 0)
      return r.add(g), Et$1(M).map(function(Y) {
        return v(Y, {
          isEmbeddedInLabel: true,
          isReferenced: false,
          recursion: true
        });
      }).filter(function(Y) {
        return Y.length > 0;
      }).join(" ");
    if (is(g) && g.type === "image") {
      var U = m(g, "alt");
      if (U !== null)
        return U;
      var N = m(g, "title");
      return N !== null ? N : "Submit Query";
    }
    if (Bt(g, ["button"])) {
      var W = f(g, {
        isEmbeddedInLabel: false,
        isReferenced: false
      });
      if (W !== "")
        return W;
    }
    return null;
  }
  o(b, "computeElementTextAlternative");
  function v(g, w) {
    if (r.has(g))
      return "";
    if (!p && x8(g, c) && !w.isReferenced)
      return r.add(g), "";
    var E = Re$1(g) ? g.getAttributeNode("aria-labelledby") : null, R = E !== null && !r.has(E) ? Ao(g, "aria-labelledby") : [];
    if (s === "name" && !w.isReferenced && R.length > 0)
      return r.add(E), R.map(function(q) {
        return v(q, {
          isEmbeddedInLabel: w.isEmbeddedInLabel,
          isReferenced: true,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: false
        });
      }).join(" ");
    var S = w.recursion && w8(g) && s === "name";
    if (!S) {
      var P = (Re$1(g) && g.getAttribute("aria-label") || "").trim();
      if (P !== "" && s === "name")
        return r.add(g), P;
      if (!R8(g)) {
        var _ = b(g);
        if (_ !== null)
          return r.add(g), _;
      }
    }
    if (Bt(g, ["menu"]))
      return r.add(g), "";
    if (S || w.isEmbeddedInLabel || w.isReferenced) {
      if (Bt(g, ["combobox", "listbox"])) {
        r.add(g);
        var C = T8(g);
        return C.length === 0 ? is(g) ? g.value : "" : Et$1(C).map(function(q) {
          return v(q, {
            isEmbeddedInLabel: w.isEmbeddedInLabel,
            isReferenced: false,
            recursion: true
          });
        }).join(" ");
      }
      if (o0(g, "range"))
        return r.add(g), g.hasAttribute("aria-valuetext") ? g.getAttribute("aria-valuetext") : g.hasAttribute("aria-valuenow") ? g.getAttribute(
          "aria-valuenow"
        ) : g.getAttribute("value") || "";
      if (Bt(g, ["textbox"]))
        return r.add(g), P8(g);
    }
    if (_8(g) || Re$1(g) && w.isReferenced || S8(g) || C8()) {
      var O = f(g, {
        isEmbeddedInLabel: w.isEmbeddedInLabel,
        isReferenced: false
      });
      if (O !== "")
        return r.add(g), O;
    }
    if (g.nodeType === g.TEXT_NODE)
      return r.add(g), g.textContent || "";
    if (w.recursion)
      return r.add(g), f(g, {
        isEmbeddedInLabel: w.isEmbeddedInLabel,
        isReferenced: false
      });
    var L = h(g);
    return L !== null ? (r.add(g), L) : (r.add(g), "");
  }
  return o(v, "computeTextAlternative"), E8(v(e, {
    isEmbeddedInLabel: false,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: s === "description",
    recursion: false
  }));
}
o(Hl, "computeTextAlternative");
function ss(e) {
  "@babel/helpers - typeof";
  return ss = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ss(e);
}
o(ss, "_typeof");
function a0(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
o(a0, "ownKeys");
function l0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a0(Object(r), true).forEach(function(n) {
      I8(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : a0(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
o(l0, "_objectSpread");
function I8(e, t, r) {
  return t = M8(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
}
o(I8, "_defineProperty");
function M8(e) {
  var t = N8(e, "string");
  return ss(t) === "symbol" ? t : String(t);
}
o(M8, "_toPropertyKey");
function N8(e, t) {
  if (ss(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (ss(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
o(N8, "_toPrimitive");
function uE(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = Ao(e, "aria-describedby").map(function(s) {
    return Hl(s, l0(l0({}, t), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (r === "") {
    var n = e.getAttribute("aria-description");
    r = n === null ? "" : n;
  }
  if (r === "") {
    var i = e.getAttribute("title");
    r = i === null ? "" : i;
  }
  return r;
}
o(uE, "computeAccessibleDescription");
function j8(e) {
  return Bt(e, [
    "caption",
    "code",
    "deletion",
    "emphasis",
    "generic",
    "insertion",
    "none",
    "paragraph",
    "presentation",
    "strong",
    "subscript",
    "superscript"
  ]);
}
o(j8, "prohibitsNaming");
function cE(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return j8(e) ? "" : Hl(e, t);
}
o(cE, "computeAccessibleName");
var Rs = Ne(AE(), 1), mN = Ne(DE(), 1), np = Ne(ix(), 1), hN = Ne(ax(), 1);
var Nx = class Nx2 extends Error {
  constructor(t, r, n, i) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, n);
    let s = "";
    try {
      s = i.utils.printWithType(
        "Received",
        r,
        i.utils.printReceived
      );
    } catch {
    }
    this.message = [
      i.utils.matcherHint(
        `${i.isNot ? ".not" : ""}.${n.name}`,
        "received",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      `${i.utils.RECEIVED_COLOR(
        "received"
      )} value must ${t}.`,
      s
    ].join(`
`);
  }
};
o(Nx, "GenericTypeError");
var Yd = Nx, jx = class jx2 extends Yd {
  constructor(...t) {
    super("be an HTMLElement or an SVGElement", ...t);
  }
};
o(jx, "HtmlElementTypeError");
var Kd = jx, kx = class kx2 extends Yd {
  constructor(...t) {
    super("be a Node", ...t);
  }
};
o(kx, "NodeTypeError");
var Xd = kx;
function yN(e, t, ...r) {
  if (!e || !e.ownerDocument || !e.ownerDocument.defaultView)
    throw new t(e, ...r);
}
o(yN, "checkHasWindow");
function _ne(e, ...t) {
  yN(e, Xd, ...t);
  let r = e.ownerDocument.defaultView;
  if (!(e instanceof r.Node))
    throw new Xd(e, ...t);
}
o(_ne, "checkNode");
function me$1(e, ...t) {
  yN(e, Kd, ...t);
  let r = e.ownerDocument.defaultView;
  if (!(e instanceof r.HTMLElement) && !(e instanceof r.SVGElement))
    throw new Kd(e, ...t);
}
o(me$1, "checkHtmlElement");
var Lx = class Lx2 extends Error {
  constructor(t, r, n) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, r), this.message = [
      t.message,
      "",
      // eslint-disable-next-line new-cap
      n.utils.RECEIVED_COLOR("Failing css:"),
      // eslint-disable-next-line new-cap
      n.utils.RECEIVED_COLOR(`${t.css}`)
    ].join(`
`);
  }
};
o(Lx, "InvalidCSSError");
var ux = Lx;
function Cne(e, ...t) {
  let r = $P(`selector { ${e} }`, { silent: true }).stylesheet;
  if (r.parsingErrors && r.parsingErrors.length > 0) {
    let { reason: i, line: s } = r.parsingErrors[0];
    throw new ux(
      {
        css: e,
        message: `Syntax error parsing expected css: ${i} on line: ${s}`
      },
      ...t
    );
  }
  return r.rules[0].declarations.filter((i) => i.type === "declaration").reduce(
    (i, { property: s, value: a }) => Object.assign(i, { [s]: a }),
    {}
  );
}
o(Cne, "parseCSS");
function uN(e, t) {
  return typeof t == "string" ? t : e.utils.stringify(t);
}
o(uN, "display");
function Xe(e, t, r, n, i, s) {
  return [
    `${t}
`,
    // eslint-disable-next-line new-cap
    `${r}:
${e.utils.EXPECTED_COLOR(
      (0, lx.default)(uN(e, n), 2)
    )}`,
    // eslint-disable-next-line new-cap
    `${i}:
${e.utils.RECEIVED_COLOR(
      (0, lx.default)(uN(e, s), 2)
    )}`
  ].join(`
`);
}
o(Xe, "getMessage");
function Pne(e, t) {
  return t instanceof RegExp ? t.test(e) : e.includes(String(t));
}
o(Pne, "matches");
function op(e, t) {
  console.warn(
    `Warning: ${e} has been deprecated and will be removed in future updates.`,
    t
  );
}
o(op, "deprecate");
function ip(e) {
  return e.replace(/\s+/g, " ").trim();
}
o(ip, "normalize");
function Br$1(e) {
  return e.tagName && e.tagName.toLowerCase();
}
o(Br$1, "getTag");
function Ane({ multiple: e, options: t }) {
  let r = [...t].filter((n) => n.selected);
  if (e)
    return [...r].map((n) => n.value);
  if (r.length !== 0)
    return r[0].value;
}
o(Ane, "getSelectValue");
function One(e) {
  switch (e.type) {
    case "number":
      return e.value === "" ? null : Number(e.value);
    case "checkbox":
      return e.checked;
    default:
      return e.value;
  }
}
o(One, "getInputValue");
var qne = ["meter", "progressbar", "slider", "spinbutton"];
function Ine(e) {
  if (qne.includes(e.getAttribute("role")))
    return Number(e.getAttribute("aria-valuenow"));
}
o(Ine, "getAccessibleValue");
function bN(e) {
  if (e)
    switch (e.tagName.toLowerCase()) {
      case "input":
        return One(e);
      case "select":
        return Ane(e);
      default:
        return e.value ?? Ine(e);
    }
}
o(bN, "getSingleElementValue");
function Mne(e, { wordConnector: t = ", ", lastWordConnector: r = " and " } = {}) {
  return [e.slice(0, -1).join(t), e[e.length - 1]].join(
    e.length > 1 ? r : ""
  );
}
o(Mne, "toSentence");
function cx(e, t) {
  if (Array.isArray(e) && Array.isArray(t))
    return [...new Set(e)].every((r) => new Set(t).has(r));
}
o(cx, "compareArraysAsSet");
function Jd(e, t) {
  return op(
    "toBeInTheDOM",
    "Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container."
  ), e && me$1(e, Jd, this), t && me$1(t, Jd, this), {
    pass: t ? t.contains(e) : !!e,
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDOM`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(
        e && e.cloneNode(false)
      )}`
    ].join(`
`), "message")
  };
}
o(Jd, "toBeInTheDOM");
function dx(e) {
  (e !== null || !this.isNot) && me$1(e, dx, this);
  let t = e === null ? false : e.ownerDocument === e.getRootNode({ composed: true }), r = /* @__PURE__ */ o(() => `expected document not to contain element, found ${this.utils.stringify(
    e.cloneNode(true)
  )} instead`, "errorFound"), n = /* @__PURE__ */ o(() => "element could not be found in the document", "errorNotFound");
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDocument`,
        "element",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(this.isNot ? r() : n())
    ].join(`
`), "message")
  };
}
o(dx, "toBeInTheDocument");
function px(e) {
  return op(
    "toBeEmpty",
    "Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM."
  ), me$1(e, px, this), {
    pass: e.innerHTML === "",
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmpty`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(e.innerHTML)}`
    ].join(`
`), "message")
  };
}
o(px, "toBeEmpty");
function fx(e) {
  return me$1(e, fx, this), {
    pass: Nne(e),
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmptyDOMElement`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(e.innerHTML)}`
    ].join(`
`), "message")
  };
}
o(fx, "toBeEmptyDOMElement");
function Nne(e) {
  return [...e.childNodes].filter((r) => r.nodeType !== 8).length === 0;
}
o(Nne, "isEmptyElement");
function Qd(e, t) {
  return me$1(e, Qd, this), t !== null && me$1(t, Qd, this), {
    pass: e.contains(t),
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainElement`,
        "element",
        "element"
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(`${this.utils.stringify(
        e.cloneNode(false)
      )} ${this.isNot ? "contains:" : "does not contain:"} ${this.utils.stringify(t && t.cloneNode(false))}
        `)
    ].join(`
`), "message")
  };
}
o(Qd, "toContainElement");
function jne(e, t) {
  let r = e.ownerDocument.createElement("div");
  return r.innerHTML = t, r.innerHTML;
}
o(jne, "getNormalizedHtml");
function mx(e, t) {
  if (me$1(e, mx, this), typeof t != "string")
    throw new Error(`.toContainHTML() expects a string value, got ${t}`);
  return {
    pass: e.outerHTML.includes(jne(e, t)),
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainHTML`,
        "element",
        ""
      ),
      "Expected:",
      // eslint-disable-next-line new-cap
      `  ${this.utils.EXPECTED_COLOR(t)}`,
      "Received:",
      `  ${this.utils.printReceived(e.cloneNode(true))}`
    ].join(`
`), "message")
  };
}
o(mx, "toContainHTML");
function hx(e, t, r = { normalizeWhitespace: true }) {
  _ne(e, hx, this);
  let n = r.normalizeWhitespace ? ip(e.textContent) : e.textContent.replace(/\u00a0/g, " "), i = n !== "" && t === "";
  return {
    pass: !i && Pne(n, t),
    message: /* @__PURE__ */ o(() => {
      let s = this.isNot ? "not to" : "to";
      return Xe(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveTextContent`,
          "element",
          ""
        ),
        i ? "Checking with empty string will always match, use .toBeEmptyDOMElement() instead" : `Expected element ${s} have text content`,
        t,
        "Received",
        n
      );
    }, "message")
  };
}
o(hx, "toHaveTextContent");
function Zd(e, t) {
  me$1(e, Zd, this);
  let r = uE(e), n = arguments.length === 1, i = false;
  return n ? i = r !== "" : i = t instanceof RegExp ? t.test(r) : this.equals(
    r,
    t
  ), {
    pass: i,
    message: /* @__PURE__ */ o(() => {
      let s = this.isNot ? "not to" : "to";
      return Xe(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${Zd.name}`,
          "element",
          ""
        ),
        `Expected element ${s} have accessible description`,
        t,
        "Received",
        r
      );
    }, "message")
  };
}
o(Zd, "toHaveAccessibleDescription");
var Ts = "aria-invalid", kne = ["false"];
function yx(e, t) {
  me$1(e, yx, this);
  let r = this.isNot ? "not to" : "to", n = this.isNot ? ".not.toHaveAccessibleErrorMessage" : ".toHaveAccessibleErrorMessage", i = e.getAttribute(
    "aria-errormessage"
  );
  if (!!i && /\s+/.test(i))
    return {
      pass: false,
      message: /* @__PURE__ */ o(() => Xe(
        this,
        this.utils.matcherHint(n, "element"),
        "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
        "",
        "Received",
        `aria-errormessage="${i}"`
      ), "message")
    };
  let a = e.getAttribute(Ts);
  if (!e.hasAttribute(Ts) || kne.includes(a))
    return {
      pass: false,
      message: /* @__PURE__ */ o(() => Xe(
        this,
        this.utils.matcherHint(n, "element"),
        "Expected element to be marked as invalid with attribute",
        `${Ts}="${String(true)}"`,
        "Received",
        e.hasAttribute("aria-invalid") ? `${Ts}="${e.getAttribute(Ts)}` : null
      ), "message")
    };
  let u = ip(
    e.ownerDocument.getElementById(i)?.textContent ?? ""
  );
  return {
    pass: t === void 0 ? !!u : t instanceof RegExp ? t.test(u) : this.equals(u, t),
    message: /* @__PURE__ */ o(() => Xe(
      this,
      this.utils.matcherHint(n, "element"),
      `Expected element ${r} have accessible error message`,
      t ?? "",
      "Received",
      u
    ), "message")
  };
}
o(yx, "toHaveAccessibleErrorMessage");
var Lne = $ne(Rs.elementRoles);
function ep(e, t) {
  me$1(e, ep, this);
  let r = Fne(e);
  return {
    pass: r.some((i) => i === t),
    message: /* @__PURE__ */ o(() => {
      let i = this.isNot ? "not to" : "to";
      return Xe(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${ep.name}`,
          "element",
          ""
        ),
        `Expected element ${i} have role`,
        t,
        "Received",
        r.join(", ")
      );
    }, "message")
  };
}
o(ep, "toHaveRole");
function Fne(e) {
  return e.hasAttribute("role") ? e.getAttribute("role").split(" ").filter(Boolean) : Dne(e);
}
o(Fne, "getExplicitOrImplicitRoles");
function Dne(e) {
  for (let { match: t, roles: r } of Lne)
    if (t(e))
      return [...r];
  return [];
}
o(Dne, "getImplicitAriaRoles");
function $ne(e) {
  function t({ name: a, attributes: l }) {
    return `${a}${l.map(({ name: u, value: c, constraints: d = [] }) => d.indexOf("undefined") !== -1 ? `:not([${u}])` : c ? `[${u}="${c}"]` : `[${u}]`).join("")}`;
  }
  o(t, "makeElementSelector");
  function r({ attributes: a = [] }) {
    return a.length;
  }
  o(r, "getSelectorSpecificity");
  function n({ specificity: a }, { specificity: l }) {
    return l - a;
  }
  o(n, "bySelectorSpecificity");
  function i(a) {
    let { attributes: l = [] } = a, u = l.findIndex(
      (d) => d.value && d.name === "type" && d.value === "text"
    );
    u >= 0 && (l = [
      ...l.slice(0, u),
      ...l.slice(u + 1)
    ]);
    let c = t({ ...a, attributes: l });
    return (d) => u >= 0 && d.type !== "text" ? false : d.matches(c);
  }
  o(i, "match");
  let s = [];
  for (let [a, l] of e.entries())
    s = [
      ...s,
      {
        match: i(a),
        roles: Array.from(l),
        specificity: r(a)
      }
    ];
  return s.sort(n);
}
o($ne, "buildElementRoleList");
function tp(e, t) {
  me$1(e, tp, this);
  let r = cE(e), n = arguments.length === 1, i = false;
  return n ? i = r !== "" : i = t instanceof RegExp ? t.test(r) : this.equals(r, t), {
    pass: i,
    message: /* @__PURE__ */ o(() => {
      let s = this.isNot ? "not to" : "to";
      return Xe(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${tp.name}`,
          "element",
          ""
        ),
        `Expected element ${s} have accessible name`,
        t,
        "Received",
        r
      );
    }, "message")
  };
}
o(tp, "toHaveAccessibleName");
function cN(e, t, r) {
  return r === void 0 ? t : `${t}=${e(r)}`;
}
o(cN, "printAttribute");
function Bne(e, t, r) {
  return r === void 0 ? `element.hasAttribute(${e(t)})` : `element.getAttribute(${e(t)}) === ${e(r)}`;
}
o(Bne, "getAttributeComment");
function bx(e, t, r) {
  me$1(e, bx, this);
  let n = r !== void 0, i = e.hasAttribute(t), s = e.getAttribute(t);
  return {
    pass: n ? i && this.equals(s, r) : i,
    message: /* @__PURE__ */ o(() => {
      let a = this.isNot ? "not to" : "to", l = i ? cN(this.utils.stringify, t, s) : null, u = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveAttribute`,
        "element",
        this.utils.printExpected(t),
        {
          secondArgument: n ? this.utils.printExpected(r) : void 0,
          comment: Bne(
            this.utils.stringify,
            t,
            r
          )
        }
      );
      return Xe(
        this,
        u,
        `Expected the element ${a} have attribute`,
        cN(this.utils.stringify, t, r),
        "Received",
        l
      );
    }, "message")
  };
}
o(bx, "toHaveAttribute");
function Hne(e) {
  let t = e.pop(), r, n;
  return typeof t == "object" && !(t instanceof RegExp) ? (r = e, n = t) : (r = e.concat(t), n = { exact: false }), { expectedClassNames: r, options: n };
}
o(Hne, "getExpectedClassNamesAndOptions");
function dN(e) {
  return e ? e.split(/\s+/).filter((t) => t.length > 0) : [];
}
o(dN, "splitClassNames");
function pN(e, t) {
  return e.every(
    (r) => typeof r == "string" ? t.includes(r) : t.some((n) => r.test(n))
  );
}
o(pN, "isSubset$1");
function gx(e, ...t) {
  me$1(e, gx, this);
  let { expectedClassNames: r, options: n } = Hne(t), i = dN(e.getAttribute("class")), s = r.reduce(
    (l, u) => l.concat(
      typeof u == "string" || !u ? dN(u) : u
    ),
    []
  ), a = s.some((l) => l instanceof RegExp);
  if (n.exact && a)
    throw new Error("Exact option does not support RegExp expected class names");
  return n.exact ? {
    pass: pN(s, i) && s.length === i.length,
    message: /* @__PURE__ */ o(() => {
      let l = this.isNot ? "not to" : "to";
      return Xe(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(s.join(" "))
        ),
        `Expected the element ${l} have EXACTLY defined classes`,
        s.join(" "),
        "Received",
        i.join(" ")
      );
    }, "message")
  } : s.length > 0 ? {
    pass: pN(s, i),
    message: /* @__PURE__ */ o(() => {
      let l = this.isNot ? "not to" : "to";
      return Xe(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(s.join(" "))
        ),
        `Expected the element ${l} have class`,
        s.join(" "),
        "Received",
        i.join(" ")
      );
    }, "message")
  } : {
    pass: this.isNot ? i.length > 0 : false,
    message: /* @__PURE__ */ o(() => this.isNot ? Xe(
      this,
      this.utils.matcherHint(".not.toHaveClass", "element", ""),
      "Expected the element to have classes",
      "(none)",
      "Received",
      i.join(" ")
    ) : [
      this.utils.matcherHint(".toHaveClass", "element"),
      "At least one expected class must be provided."
    ].join(`
`), "message")
  };
}
o(gx, "toHaveClass");
function Une(e, t) {
  let r = {}, n = e.createElement("div");
  return Object.keys(t).forEach((i) => {
    n.style[i] = t[i], r[i] = n.style[i];
  }), r;
}
o(Une, "getStyleDeclaration");
function Vne(e, t) {
  return !!Object.keys(e).length && Object.entries(e).every(([r, n]) => {
    let i = r.startsWith("--"), s = [r];
    return i || s.push(r.toLowerCase()), s.some(
      (a) => t[a] === n || t.getPropertyValue(a) === n
    );
  });
}
o(Vne, "isSubset");
function fN(e) {
  return Object.keys(e).sort().map((t) => `${t}: ${e[t]};`).join(`
`);
}
o(fN, "printoutStyles");
function zne(e, t, r) {
  let n = Array.from(r).filter((s) => t[s] !== void 0).reduce(
    (s, a) => Object.assign(s, { [a]: r.getPropertyValue(a) }),
    {}
  );
  return e(fN(t), fN(n)).replace(`${mN.default.red("+ Received")}
`, "");
}
o(zne, "expectedDiff");
function rp(e, t) {
  me$1(e, rp, this);
  let r = typeof t == "object" ? t : Cne(t, rp, this), { getComputedStyle: n } = e.ownerDocument.defaultView, i = Une(e.ownerDocument, r), s = n(
    e
  );
  return {
    pass: Vne(i, s),
    message: /* @__PURE__ */ o(() => {
      let a = `${this.isNot ? ".not" : ""}.toHaveStyle`;
      return [
        this.utils.matcherHint(a, "element", ""),
        zne(this.utils.diff, i, s)
      ].join(`

`);
    }, "message")
  };
}
o(rp, "toHaveStyle");
function vx(e) {
  return me$1(e, vx, this), {
    pass: e.ownerDocument.activeElement === e,
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveFocus`,
        "element",
        ""
      ),
      "",
      ...this.isNot ? [
        "Received element is focused:",
        `  ${this.utils.printReceived(e)}`
      ] : [
        "Expected element with focus:",
        `  ${this.utils.printExpected(e)}`,
        "Received element with focus:",
        `  ${this.utils.printReceived(
          e.ownerDocument.activeElement
        )}`
      ]
    ].join(`
`), "message")
  };
}
o(vx, "toHaveFocus");
function Gne(e) {
  let t = [...new Set(e.map((r) => r.type))];
  if (t.length !== 1)
    throw new Error(
      "Multiple form elements with the same name must be of the same type"
    );
  switch (t[0]) {
    case "radio": {
      let r = e.find((n) => n.checked);
      return r ? r.value : void 0;
    }
    case "checkbox":
      return e.filter((r) => r.checked).map((r) => r.value);
    default:
      return e.map((r) => r.value);
  }
}
o(Gne, "getMultiElementValue");
function Wne(e, t) {
  let r = [...e.querySelectorAll(`[name="${(0, hN.default)(t)}"]`)];
  if (r.length !== 0)
    switch (r.length) {
      case 1:
        return bN(r[0]);
      default:
        return Gne(r);
    }
}
o(Wne, "getFormValue");
function Yne(e) {
  return /\[\]$/.test(e) ? e.slice(0, -2) : e;
}
o(Yne, "getPureName");
function Kne(e) {
  return Array.from(e.elements).map((r) => r.name).reduce(
    (r, n) => ({
      ...r,
      [Yne(n)]: Wne(e, n)
    }),
    {}
  );
}
o(Kne, "getAllFormValues");
function Ex(e, t) {
  if (me$1(e, Ex, this), !e.elements)
    throw new Error("toHaveFormValues must be called on a form or a fieldset");
  let r = Kne(e);
  return {
    pass: Object.entries(t).every(
      ([n, i]) => (0, np.default)(r[n], i, cx)
    ),
    message: /* @__PURE__ */ o(() => {
      let n = this.isNot ? "not to" : "to", i = `${this.isNot ? ".not" : ""}.toHaveFormValues`, s = Object.keys(r).filter((a) => t.hasOwnProperty(
        a
      )).reduce((a, l) => ({ ...a, [l]: r[l] }), {});
      return [
        this.utils.matcherHint(i, "element", ""),
        `Expected the element ${n} have form values`,
        this.utils.diff(t, s)
      ].join(`

`);
    }, "message")
  };
}
o(Ex, "toHaveFormValues");
function Xne(e) {
  let { getComputedStyle: t } = e.ownerDocument.defaultView, { display: r, visibility: n, opacity: i } = t(e);
  return r !== "none" && n !== "hidden" && n !== "collapse" && i !== "0" && i !== 0;
}
o(Xne, "isStyleVisible");
function Jne(e, t) {
  let r;
  return t ? r = e.nodeName === "DETAILS" && t.nodeName !== "SUMMARY" ? e.hasAttribute("open") : true : r = e.nodeName === "DETAILS" ? e.hasAttribute(
    "open"
  ) : true, !e.hasAttribute("hidden") && r;
}
o(Jne, "isAttributeVisible");
function gN(e, t) {
  return Xne(e) && Jne(e, t) && (!e.parentElement || gN(e.parentElement, e));
}
o(gN, "isElementVisible");
function xx(e) {
  me$1(e, xx, this);
  let t = e.ownerDocument === e.getRootNode({ composed: true }), r = t && gN(e);
  return {
    pass: r,
    message: /* @__PURE__ */ o(() => {
      let n = r ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeVisible`,
          "element",
          ""
        ),
        "",
        `Received element ${n} visible${t ? "" : " (element is not in the document)"}:`,
        `  ${this.utils.printReceived(e.cloneNode(false))}`
      ].join(`
`);
    }, "message")
  };
}
o(xx, "toBeVisible");
var Qne = [
  "fieldset",
  "input",
  "select",
  "optgroup",
  "option",
  "button",
  "textarea"
];
function Zne(e, t) {
  return Br$1(e) === "legend" && Br$1(t) === "fieldset" && e.isSameNode(
    Array.from(t.children).find((r) => Br$1(r) === "legend")
  );
}
o(Zne, "isFirstLegendChildOfFieldset");
function eoe(e, t) {
  return EN(t) && !Zne(e, t);
}
o(eoe, "isElementDisabledByParent");
function toe(e) {
  return e.includes("-");
}
o(toe, "isCustomElement");
function vN(e) {
  let t = Br$1(e);
  return Qne.includes(t) || toe(t);
}
o(vN, "canElementBeDisabled");
function EN(e) {
  return vN(e) && e.hasAttribute("disabled");
}
o(EN, "isElementDisabled");
function xN(e) {
  let t = e.parentElement;
  return !!t && (eoe(e, t) || xN(t));
}
o(xN, "isAncestorDisabled");
function wN(e) {
  return vN(e) && (EN(e) || xN(e));
}
o(wN, "isElementOrAncestorDisabled");
function wx(e) {
  me$1(e, wx, this);
  let t = wN(e);
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => {
      let r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeDisabled`,
          "element",
          ""
        ),
        "",
        `Received element ${r} disabled:`,
        `  ${this.utils.printReceived(e.cloneNode(false))}`
      ].join(`
`);
    }, "message")
  };
}
o(wx, "toBeDisabled");
function Tx(e) {
  me$1(e, Tx, this);
  let t = !wN(e);
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => {
      let r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeEnabled`,
          "element",
          ""
        ),
        "",
        `Received element ${r} enabled:`,
        `  ${this.utils.printReceived(e.cloneNode(false))}`
      ].join(`
`);
    }, "message")
  };
}
o(Tx, "toBeEnabled");
var roe = ["select", "textarea"], noe = ["input", "select", "textarea"], ooe = [
  "color",
  "hidden",
  "range",
  "submit",
  "image",
  "reset"
], ioe = [
  "checkbox",
  "combobox",
  "gridcell",
  "listbox",
  "radiogroup",
  "spinbutton",
  "textbox",
  "tree"
];
function soe(e) {
  return roe.includes(Br$1(e)) && e.hasAttribute("required");
}
o(soe, "isRequiredOnFormTagsExceptInput");
function aoe(e) {
  return Br$1(e) === "input" && e.hasAttribute("required") && (e.hasAttribute("type") && !ooe.includes(e.getAttribute("type")) || !e.hasAttribute(
    "type"
  ));
}
o(aoe, "isRequiredOnSupportedInput");
function loe(e) {
  return e.hasAttribute("aria-required") && e.getAttribute("aria-required") === "true" && (noe.includes(Br$1(e)) || e.hasAttribute("role") && ioe.includes(e.getAttribute("role")));
}
o(loe, "isElementRequiredByARIA");
function Rx(e) {
  me$1(e, Rx, this);
  let t = soe(e) || aoe(e) || loe(e);
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => {
      let r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeRequired`,
          "element",
          ""
        ),
        "",
        `Received element ${r} required:`,
        `  ${this.utils.printReceived(e.cloneNode(false))}`
      ].join(`
`);
    }, "message")
  };
}
o(Rx, "toBeRequired");
var uoe = ["form", "input", "select", "textarea"];
function coe(e) {
  return e.hasAttribute("aria-invalid") && e.getAttribute("aria-invalid") !== "false";
}
o(coe, "isElementHavingAriaInvalid");
function doe(e) {
  return uoe.includes(Br$1(e));
}
o(doe, "isSupportsValidityMethod");
function TN(e) {
  let t = coe(e);
  return doe(e) ? t || !e.checkValidity() : t;
}
o(TN, "isElementInvalid");
function Sx(e) {
  me$1(e, Sx, this);
  let t = TN(e);
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => {
      let r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeInvalid`,
          "element",
          ""
        ),
        "",
        `Received element ${r} currently invalid:`,
        `  ${this.utils.printReceived(e.cloneNode(false))}`
      ].join(`
`);
    }, "message")
  };
}
o(Sx, "toBeInvalid");
function _x(e) {
  me$1(e, _x, this);
  let t = !TN(e);
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => {
      let r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeValid`,
          "element",
          ""
        ),
        "",
        `Received element ${r} currently valid:`,
        `  ${this.utils.printReceived(e.cloneNode(false))}`
      ].join(`
`);
    }, "message")
  };
}
o(_x, "toBeValid");
function Cx(e, t) {
  if (me$1(e, Cx, this), e.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(e.type))
    throw new Error(
      "input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead"
    );
  let r = bN(e), n = t !== void 0, i = t, s = r;
  return t == r && t !== r && (i = `${t} (${typeof t})`, s = `${r} (${typeof r})`), {
    pass: n ? (0, np.default)(r, t, cx) : !!r,
    message: /* @__PURE__ */ o(() => {
      let a = this.isNot ? "not to" : "to", l = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveValue`,
        "element",
        t
      );
      return Xe(
        this,
        l,
        `Expected the element ${a} have value`,
        n ? i : "(any)",
        "Received",
        s
      );
    }, "message")
  };
}
o(Cx, "toHaveValue");
function Px(e, t) {
  me$1(e, Px, this);
  let r = e.tagName.toLowerCase();
  if (!["select", "input", "textarea"].includes(r))
    throw new Error(
      ".toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead."
    );
  if (r === "input" && ["radio", "checkbox"].includes(e.type))
    throw new Error(
      `.toHaveDisplayValue() currently does not support input[type="${e.type}"], try with another matcher instead.`
    );
  let n = poe(r, e), i = foe(t), s = i.filter(
    (u) => n.some(
      (c) => u instanceof RegExp ? u.test(c) : this.equals(c, String(u))
    )
  ).length, a = s === n.length, l = s === i.length;
  return {
    pass: a && l,
    message: /* @__PURE__ */ o(() => Xe(
      this,
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveDisplayValue`,
        "element",
        ""
      ),
      `Expected element ${this.isNot ? "not " : ""}to have display value`,
      t,
      "Received",
      n
    ), "message")
  };
}
o(Px, "toHaveDisplayValue");
function poe(e, t) {
  return e === "select" ? Array.from(t).filter((r) => r.selected).map((r) => r.textContent) : [t.value];
}
o(poe, "getValues");
function foe(e) {
  return e instanceof Array ? e : [e];
}
o(foe, "getExpectedValues");
function Ax(e) {
  me$1(e, Ax, this);
  let t = /* @__PURE__ */ o(() => e.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(e.type), "isValidInput"), r = /* @__PURE__ */ o(
    () => RN(e.getAttribute("role")) && ["true", "false"].includes(e.getAttribute("aria-checked")),
    "isValidAriaElement"
  );
  if (!t() && !r())
    return {
      pass: false,
      message: /* @__PURE__ */ o(() => `only inputs with type="checkbox" or type="radio" or elements with ${moe()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`, "message")
    };
  let n = /* @__PURE__ */ o(() => t() ? e.checked : e.getAttribute("aria-checked") === "true", "isChecked");
  return {
    pass: n(),
    message: /* @__PURE__ */ o(() => {
      let i = n() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${i} checked:`,
        `  ${this.utils.printReceived(e.cloneNode(false))}`
      ].join(`
`);
    }, "message")
  };
}
o(Ax, "toBeChecked");
function moe() {
  return Mne(
    hoe().map((e) => `role="${e}"`),
    { lastWordConnector: " or " }
  );
}
o(moe, "supportedRolesSentence");
function hoe() {
  return Rs.roles.keys().filter(RN);
}
o(hoe, "supportedRoles");
function RN(e) {
  return Rs.roles.get(e)?.props["aria-checked"] !== void 0;
}
o(RN, "roleSupportsChecked");
function Ox(e) {
  me$1(e, Ox, this);
  let t = /* @__PURE__ */ o(() => e.tagName.toLowerCase() === "input" && e.type === "checkbox", "isValidInput"), r = /* @__PURE__ */ o(() => e.getAttribute("role") === "checkbox", "isValidAriaElement");
  if (!t() && !r())
    return {
      pass: false,
      message: /* @__PURE__ */ o(() => 'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead', "message")
    };
  let n = /* @__PURE__ */ o(() => {
    let i = e.getAttribute("aria-checked") === "mixed";
    return t() && e.indeterminate || i;
  }, "isPartiallyChecked");
  return {
    pass: n(),
    message: /* @__PURE__ */ o(() => {
      let i = n() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBePartiallyChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${i} partially checked:`,
        `  ${this.utils.printReceived(e.cloneNode(false))}`
      ].join(`
`);
    }, "message")
  };
}
o(Ox, "toBePartiallyChecked");
function qx(e, t) {
  op(
    "toHaveDescription",
    "Please use toHaveAccessibleDescription."
  ), me$1(e, qx, this);
  let r = t !== void 0, i = (e.getAttribute("aria-describedby") || "").split(/\s+/).filter(Boolean), s = "";
  if (i.length > 0) {
    let a = e.ownerDocument, l = i.map((u) => a.getElementById(u)).filter(Boolean);
    s = ip(l.map((u) => u.textContent).join(" "));
  }
  return {
    pass: r ? t instanceof RegExp ? t.test(s) : this.equals(s, t) : !!s,
    message: /* @__PURE__ */ o(() => {
      let a = this.isNot ? "not to" : "to";
      return Xe(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveDescription`,
          "element",
          ""
        ),
        `Expected the element ${a} have description`,
        this.utils.printExpected(t),
        "Received",
        this.utils.printReceived(s)
      );
    }, "message")
  };
}
o(qx, "toHaveDescription");
function Ix(e, t) {
  if (op("toHaveErrorMessage", "Please use toHaveAccessibleErrorMessage."), me$1(e, Ix, this), !e.hasAttribute("aria-invalid") || e.getAttribute(
    "aria-invalid"
  ) === "false") {
    let a = this.isNot ? ".not" : "";
    return {
      pass: false,
      message: /* @__PURE__ */ o(() => Xe(
        this,
        this.utils.matcherHint(`${a}.toHaveErrorMessage`, "element", ""),
        "Expected the element to have invalid state indicated by",
        'aria-invalid="true"',
        "Received",
        e.hasAttribute("aria-invalid") ? `aria-invalid="${e.getAttribute("aria-invalid")}"` : this.utils.printReceived("")
      ), "message")
    };
  }
  let r = t !== void 0, i = (e.getAttribute("aria-errormessage") || "").split(/\s+/).filter(Boolean), s = "";
  if (i.length > 0) {
    let a = e.ownerDocument, l = i.map((u) => a.getElementById(u)).filter(Boolean);
    s = ip(
      l.map((u) => u.textContent).join(" ")
    );
  }
  return {
    pass: r ? t instanceof RegExp ? t.test(s) : this.equals(s, t) : !!s,
    message: /* @__PURE__ */ o(() => {
      let a = this.isNot ? "not to" : "to";
      return Xe(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveErrorMessage`,
          "element",
          ""
        ),
        `Expected the element ${a} have error message`,
        this.utils.printExpected(t),
        "Received",
        this.utils.printReceived(s)
      );
    }, "message")
  };
}
o(Ix, "toHaveErrorMessage");
function yoe(e) {
  let t = e.ownerDocument.getSelection();
  if (["input", "textarea"].includes(e.tagName.toLowerCase()))
    return ["radio", "checkbox"].includes(e.type) ? "" : e.value.toString().substring(e.selectionStart, e.selectionEnd);
  if (t.anchorNode === null || t.focusNode === null)
    return "";
  let r = t.getRangeAt(0), n = e.ownerDocument.createRange();
  if (t.containsNode(e, false))
    n.selectNodeContents(e), t.removeAllRanges(), t.addRange(n);
  else if (!(e.contains(t.anchorNode) && e.contains(t.focusNode))) {
    let s = e === r.startContainer || e.contains(r.startContainer), a = e === r.endContainer || e.contains(r.endContainer);
    t.removeAllRanges(), (s || a) && (n.selectNodeContents(e), s && n.setStart(
      r.startContainer,
      r.startOffset
    ), a && n.setEnd(
      r.endContainer,
      r.endOffset
    ), t.addRange(n));
  }
  let i = t.toString();
  return t.removeAllRanges(), t.addRange(r), i;
}
o(yoe, "getSelection");
function Mx(e, t) {
  me$1(e, Mx, this);
  let r = t !== void 0;
  if (r && typeof t != "string")
    throw new Error("expected selection must be a string or undefined");
  let n = yoe(e);
  return {
    pass: r ? (0, np.default)(n, t, cx) : !!n,
    message: /* @__PURE__ */ o(() => {
      let i = this.isNot ? "not to" : "to", s = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveSelection`,
        "element",
        t
      );
      return Xe(
        this,
        s,
        `Expected the element ${i} have selection`,
        r ? t : "(any)",
        "Received",
        n
      );
    }, "message")
  };
}
o(Mx, "toHaveSelection");
Ne(rE(), 1);
Ne(AE(), 1); Ne(DE(), 1); Ne(ix(), 1); Ne(ax(), 1);
var Dx, SN;
function boe() {
  if (SN) return Dx;
  SN = 1;
  var e, t, r, n, i, s, a, l, u, c, d, p, f, m, h, b, v, g, w;
  return f = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu, p = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y, e = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu, h = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y, d = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y, b = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y, w = /[\t\v\f\ufeff\p{Zs}]+/yu, l = /\r?\n|[\r\u2028\u2029]/y, u = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y, m = /\/\/.*/y, r = /[<>.:={}]|\/(?![\/*])/y, t = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu, n = /(['"])(?:(?!\1)[^])*(\1)?/y, i = /[^<>{}]+/y, g = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/, v = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/, s = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/, a = /^(?:return|throw|yield)$/, c = RegExp(l.source), Dx = /* @__PURE__ */ o(function* (E, { jsx: R = false } = {}) {
    var S, P, _, C, O, L, q, D, H, M, U, N, W, Y;
    for ({ length: L } = E, C = 0, O = "", Y = [
      { tag: "JS" }
    ], S = [], U = 0, N = false; C < L; ) {
      switch (D = Y[Y.length - 1], D.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (E[C] === "/" && (g.test(O) || s.test(O)) && (f.lastIndex = C, q = f.exec(E))) {
            C = f.lastIndex, O = q[0], N = true, yield {
              type: "RegularExpressionLiteral",
              value: q[0],
              closed: q[1] !== void 0 && q[1] !== "\\"
            };
            continue;
          }
          if (p.lastIndex = C, q = p.exec(E)) {
            switch (W = q[0], H = p.lastIndex, M = W, W) {
              case "(":
                O === "?NonExpressionParenKeyword" && Y.push({
                  tag: "JSNonExpressionParen",
                  nesting: U
                }), U++, N = false;
                break;
              case ")":
                U--, N = true, D.tag === "JSNonExpressionParen" && U === D.nesting && (Y.pop(), M = "?NonExpressionParenEnd", N = false);
                break;
              case "{":
                p.lastIndex = 0, _ = !v.test(O) && (g.test(O) || s.test(O)), S.push(_), N = false;
                break;
              case "}":
                switch (D.tag) {
                  case "InterpolationInTemplate":
                    if (S.length === D.nesting) {
                      b.lastIndex = C, q = b.exec(E), C = b.lastIndex, O = q[0], q[1] === "${" ? (O = "?InterpolationInTemplate", N = false, yield {
                        type: "TemplateMiddle",
                        value: q[0]
                      }) : (Y.pop(), N = true, yield {
                        type: "TemplateTail",
                        value: q[0],
                        closed: q[1] === "`"
                      });
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (S.length === D.nesting) {
                      Y.pop(), C += 1, O = "}", yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                N = S.pop(), M = N ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                N = true;
                break;
              case "++":
              case "--":
                M = N ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (R && (g.test(O) || s.test(O))) {
                  Y.push({ tag: "JSXTag" }), C += 1, O = "<", yield {
                    type: "JSXPunctuator",
                    value: W
                  };
                  continue;
                }
                N = false;
                break;
              default:
                N = false;
            }
            C = H, O = M, yield {
              type: "Punctuator",
              value: W
            };
            continue;
          }
          if (e.lastIndex = C, q = e.exec(E)) {
            switch (C = e.lastIndex, M = q[0], q[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                O !== "." && O !== "?." && (M = "?NonExpressionParenKeyword");
            }
            O = M, N = !s.test(q[0]), yield {
              type: q[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: q[0]
            };
            continue;
          }
          if (h.lastIndex = C, q = h.exec(E)) {
            C = h.lastIndex, O = q[0], N = true, yield {
              type: "StringLiteral",
              value: q[0],
              closed: q[2] !== void 0
            };
            continue;
          }
          if (d.lastIndex = C, q = d.exec(E)) {
            C = d.lastIndex, O = q[0], N = true, yield {
              type: "NumericLiteral",
              value: q[0]
            };
            continue;
          }
          if (b.lastIndex = C, q = b.exec(E)) {
            C = b.lastIndex, O = q[0], q[1] === "${" ? (O = "?InterpolationInTemplate", Y.push({
              tag: "InterpolationInTemplate",
              nesting: S.length
            }), N = false, yield {
              type: "TemplateHead",
              value: q[0]
            }) : (N = true, yield {
              type: "NoSubstitutionTemplate",
              value: q[0],
              closed: q[1] === "`"
            });
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          if (r.lastIndex = C, q = r.exec(E)) {
            switch (C = r.lastIndex, M = q[0], q[0]) {
              case "<":
                Y.push({ tag: "JSXTag" });
                break;
              case ">":
                Y.pop(), O === "/" || D.tag === "JSXTagEnd" ? (M = "?JSX", N = true) : Y.push({ tag: "JSXChildren" });
                break;
              case "{":
                Y.push({
                  tag: "InterpolationInJSX",
                  nesting: S.length
                }), M = "?InterpolationInJSX", N = false;
                break;
              case "/":
                O === "<" && (Y.pop(), Y[Y.length - 1].tag === "JSXChildren" && Y.pop(), Y.push({ tag: "JSXTagEnd" }));
            }
            O = M, yield {
              type: "JSXPunctuator",
              value: q[0]
            };
            continue;
          }
          if (t.lastIndex = C, q = t.exec(E)) {
            C = t.lastIndex, O = q[0], yield {
              type: "JSXIdentifier",
              value: q[0]
            };
            continue;
          }
          if (n.lastIndex = C, q = n.exec(E)) {
            C = n.lastIndex, O = q[0], yield {
              type: "JSXString",
              value: q[0],
              closed: q[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          if (i.lastIndex = C, q = i.exec(E)) {
            C = i.lastIndex, O = q[0], yield {
              type: "JSXText",
              value: q[0]
            };
            continue;
          }
          switch (E[C]) {
            case "<":
              Y.push({ tag: "JSXTag" }), C++, O = "<", yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              Y.push({
                tag: "InterpolationInJSX",
                nesting: S.length
              }), C++, O = "?InterpolationInJSX", N = false, yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      if (w.lastIndex = C, q = w.exec(E)) {
        C = w.lastIndex, yield {
          type: "WhiteSpace",
          value: q[0]
        };
        continue;
      }
      if (l.lastIndex = C, q = l.exec(E)) {
        C = l.lastIndex, N = false, a.test(O) && (O = "?NoLineTerminatorHere"), yield {
          type: "LineTerminatorSequence",
          value: q[0]
        };
        continue;
      }
      if (u.lastIndex = C, q = u.exec(E)) {
        C = u.lastIndex, c.test(q[0]) && (N = false, a.test(O) && (O = "?NoLineTerminatorHere")), yield {
          type: "MultiLineComment",
          value: q[0],
          closed: q[1] !== void 0
        };
        continue;
      }
      if (m.lastIndex = C, q = m.exec(E)) {
        C = m.lastIndex, N = false, yield {
          type: "SingleLineComment",
          value: q[0]
        };
        continue;
      }
      P = String.fromCodePoint(E.codePointAt(C)), C += P.length, O = P, N = false, yield {
        type: D.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: P
      };
    }
  }, "jsTokens_1"), Dx;
}
o(boe, "requireJsTokens");
boe();
var _N = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
}; new Set(_N.keyword); new Set(_N.strict);
function sp(e, t) {
  if (!e)
    throw new Error(t);
}
o(sp, "assert");
function Vo(e, t) {
  return typeof t === e;
}
o(Vo, "isType");
function goe(e) {
  return e instanceof Promise;
}
o(goe, "isPromise");
function Ss(e, t, r) {
  Object.defineProperty(e, t, r);
}
o(Ss, "define");
function zo(e, t, r) {
  Ss(e, t, { value: r, configurable: true, writable: true });
}
o(zo, "defineValue");
var Hr$1 = Symbol.for("tinyspy:spy"), voe = /* @__PURE__ */ new Set(), Eoe = /* @__PURE__ */ o((e) => {
  e.called = false, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, "reset"), xoe = /* @__PURE__ */ o((e) => (Ss(e, Hr$1, {
  value: { reset: /* @__PURE__ */ o(() => Eoe(e[Hr$1]), "reset") }
}), e[Hr$1]), "defineState"), ap = /* @__PURE__ */ o((e) => e[Hr$1] || xoe(e), "getInternalState");
function woe(e) {
  sp(
    Vo("function", e) || Vo("undefined", e),
    "cannot spy on a non-function value"
  );
  let t = /* @__PURE__ */ o(function(...n) {
    let i = ap(t);
    i.called = true, i.callCount++, i.calls.push(n);
    let s = i.next.shift();
    if (s) {
      i.results.push(s);
      let [d, p] = s;
      if (d === "ok")
        return p;
      throw p;
    }
    let a, l = "ok", u = i.results.length;
    if (i.impl)
      try {
        new.target ? a = Reflect.construct(i.impl, n, new.target) : a = i.impl.apply(this, n), l = "ok";
      } catch (d) {
        throw a = d, l = "error", i.results.push([l, d]), d;
      }
    let c = [l, a];
    return goe(a) && a.then(
      (d) => i.resolves[u] = ["ok", d],
      (d) => i.resolves[u] = ["error", d]
    ), i.results.push(c), a;
  }, "fn");
  zo(t, "_isMockFunction", true), zo(t, "length", e ? e.length : 0), zo(t, "name", e && e.name || "spy");
  let r = ap(t);
  return r.reset(), r.impl = e, t;
}
o(woe, "createInternalSpy");
function Toe(e) {
  return !!e && e._isMockFunction === true;
}
o(Toe, "isMockFunction");
var PN = /* @__PURE__ */ o((e, t) => {
  let r = Object.getOwnPropertyDescriptor(e, t);
  if (r)
    return [e, r];
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    let i = Object.getOwnPropertyDescriptor(n, t);
    if (i)
      return [n, i];
    n = Object.getPrototypeOf(n);
  }
}, "getDescriptor"), CN = /* @__PURE__ */ o((e, t) => {
  t != null && typeof t == "function" && t.prototype != null && Object.setPrototypeOf(e.prototype, t.prototype);
}, "setPototype");
function $x(e, t, r) {
  sp(
    !Vo("undefined", e),
    "spyOn could not find an object to spy upon"
  ), sp(
    Vo("object", e) || Vo("function", e),
    "cannot spyOn on a primitive value"
  );
  let [n, i] = (() => {
    if (!Vo("object", t))
      return [t, "value"];
    if ("getter" in t && "setter" in t)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t)
      return [t.getter, "get"];
    if ("setter" in t)
      return [t.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), [s, a] = PN(e, n) || [];
  sp(
    a || n in e,
    `${String(n)} does not exist`
  );
  let l = false;
  i === "value" && a && !a.value && a.get && (i = "get", l = true, r = a.get());
  let u;
  a ? u = a[i] : i !== "value" ? u = /* @__PURE__ */ o(() => e[n], "original") : u = e[n], u && Coe(u) && (u = u[Hr$1].getOriginal());
  let c = /* @__PURE__ */ o((m) => {
    let { value: h, ...b } = a || {
      configurable: true,
      writable: true
    };
    i !== "value" && delete b.writable, b[i] = m, Ss(e, n, b);
  }, "reassign"), d = /* @__PURE__ */ o(() => {
    s !== e ? Reflect.deleteProperty(e, n) : a && !u ? Ss(e, n, a) : c(u);
  }, "restore");
  r || (r = u);
  let p = _oe(woe(r), r);
  i === "value" && CN(p, u);
  let f = p[Hr$1];
  return zo(f, "restore", d), zo(f, "getOriginal", () => l ? u() : u), zo(f, "willCall", (m) => (f.impl = m, p)), c(
    l ? () => (CN(p, r), p) : p
  ), voe.add(p), p;
}
o($x, "internalSpyOn");
var Roe = /* @__PURE__ */ new Set([
  "length",
  "name",
  "prototype"
]);
function Soe(e) {
  let t = /* @__PURE__ */ new Set(), r = {};
  for (; e && e !== Object.prototype && e !== Function.prototype; ) {
    let n = [
      ...Object.getOwnPropertyNames(e),
      ...Object.getOwnPropertySymbols(e)
    ];
    for (let i of n)
      r[i] || Roe.has(i) || (t.add(i), r[i] = Object.getOwnPropertyDescriptor(e, i));
    e = Object.getPrototypeOf(e);
  }
  return {
    properties: t,
    descriptors: r
  };
}
o(Soe, "getAllProperties");
function _oe(e, t) {
  if (!t || // the original is already a spy, so it has all the properties
  Hr$1 in t)
    return e;
  let { properties: r, descriptors: n } = Soe(t);
  for (let i of r) {
    let s = n[i];
    PN(e, i) || Ss(e, i, s);
  }
  return e;
}
o(_oe, "wrap");
function Coe(e) {
  return Toe(e) && "getOriginal" in e[Hr$1];
}
o(Coe, "isSpyFunction");
var Go = /* @__PURE__ */ new Set();
function hr$1(e) {
  return typeof e == "function" && "_isMockFunction" in e && e._isMockFunction;
}
o(hr$1, "isMockFunction");
function AN(e, t, r) {
  let i = r ? { [{
    get: "getter",
    set: "setter"
  }[r]]: t } : t, s, a = Ooe(e, t), l = a && a[r || "value"];
  hr$1(l) && (s = l.mock._state());
  try {
    let u = $x(e, i), c = ON(u);
    return s && c.mock._state(s), c;
  } catch (u) {
    throw u instanceof TypeError && Symbol.toStringTag && e[Symbol.toStringTag] === "Module" && (u.message.includes("Cannot redefine property") || u.message.includes("Cannot replace module namespace") || u.message.includes("can't redefine non-configurable property")) ? new TypeError(
      `Cannot spy on export "${String(i)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`,
      {
        cause: u
      }
    ) : u;
  }
}
o(AN, "spyOn");
var Aoe = 0;
function ON(e) {
  let t = e, r, n = [], i = false, s = [], a = [], l = [], u = ap(e), c = {
    get calls() {
      return u.calls;
    },
    get contexts() {
      return a;
    },
    get instances() {
      return s;
    },
    get invocationCallOrder() {
      return l;
    },
    get results() {
      return u.results.map(([m, h]) => ({
        type: m === "error" ? "throw" : "return",
        value: h
      }));
    },
    get settledResults() {
      return u.resolves.map(([m, h]) => ({
        type: m === "error" ? "rejected" : "fulfilled",
        value: h
      }));
    },
    get lastCall() {
      return u.calls[u.calls.length - 1];
    },
    _state(m) {
      return m && (r = m.implementation, n = m.onceImplementations, i = m.implementationChangedTemporarily), {
        implementation: r,
        onceImplementations: n,
        implementationChangedTemporarily: i
      };
    }
  };
  function d(...m) {
    return s.push(this), a.push(this), l.push(++Aoe), (i ? r : n.shift() || r || u.getOriginal() || (() => {
    })).apply(this, m);
  }
  o(d, "mockCall");
  let p = t.name;
  t.getMockName = () => p || "vi.fn()", t.mockName = (m) => (p = m, t), t.mockClear = () => (u.reset(), s = [], a = [], l = [], t), t.mockReset = () => (t.mockClear(), r = void 0, n = [], t), t.mockRestore = () => (t.mockReset(), u.restore(), t), Symbol.dispose && (t[Symbol.dispose] = () => t.mockRestore()), t.getMockImplementation = () => i ? r : n.at(0) || r, t.mockImplementation = (m) => (r = m, u.willCall(d), t), t.mockImplementationOnce = (m) => (n.push(m), t);
  function f(m, h) {
    let b = r;
    r = m, u.willCall(d), i = true;
    let v = /* @__PURE__ */ o(() => {
      r = b, i = false;
    }, "reset"), g = h();
    return typeof g == "object" && g && typeof g.then == "function" ? g.then(() => (v(), t)) : (v(), t);
  }
  return o(f, "withImplementation"), t.withImplementation = f, t.mockReturnThis = () => t.mockImplementation(function() {
    return this;
  }), t.mockReturnValue = (m) => t.mockImplementation(() => m), t.mockReturnValueOnce = (m) => t.mockImplementationOnce(() => m), t.mockResolvedValue = (m) => t.mockImplementation(() => Promise.resolve(m)), t.mockResolvedValueOnce = (m) => t.mockImplementationOnce(() => Promise.resolve(m)), t.mockRejectedValue = (m) => t.mockImplementation(() => Promise.reject(m)), t.mockRejectedValueOnce = (m) => t.mockImplementationOnce(() => Promise.reject(m)), Object.defineProperty(t, "mock", { get: /* @__PURE__ */ o(() => c, "get") }), u.willCall(d), Go.add(t), t;
}
o(ON, "enhanceSpy");
function Bx(e) {
  let t = ON($x({ spy: e || function() {
  } }, "spy"));
  return e && t.mockImplementation(e), t;
}
o(Bx, "fn");
function Ooe(e, t) {
  let r = Object.getOwnPropertyDescriptor(e, t);
  if (r)
    return r;
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    let i = Object.getOwnPropertyDescriptor(n, t);
    if (i)
      return i;
    n = Object.getPrototypeOf(n);
  }
}
o(Ooe, "getDescriptor");
var Ps = Symbol.for("matchers-object"), As = Symbol.for("$$jest-matchers-object-storybook"), hp = Symbol.for("expect-global"), Vx = Symbol.for(
  "asymmetric-matchers-object"
), $N = {
  toSatisfy(e, t, r) {
    let { printReceived: n, printExpected: i, matcherHint: s } = this.utils, a = t(e);
    return {
      pass: a,
      message: /* @__PURE__ */ o(() => a ? `${s(".not.toSatisfy", "received", "")}

Expected value to not satisfy:
${r || i(t)}
Received:
${n(e)}` : `${s(".toSatisfy", "received", "")}

Expected value to satisfy:
${r || i(t)}

Received:
${n(e)}`, "message")
    };
  },
  toBeOneOf(e, t) {
    let { equals: r, customTesters: n } = this, { printReceived: i, printExpected: s, matcherHint: a } = this.utils;
    if (!Array.isArray(t))
      throw new TypeError(`You must provide an array to ${a(".toBeOneOf")}, not '${typeof t}'.`);
    let l = t.length === 0 || t.some((u) => r(u, e, n));
    return {
      pass: l,
      message: /* @__PURE__ */ o(() => l ? `${a(".not.toBeOneOf", "received", "")}

Expected value to not be one of:
${s(t)}
Received:
${i(e)}` : `${a(".toBeOneOf", "received", "")}

Expected value to be one of:
${s(t)}

Received:
${i(e)}`, "message")
    };
  }
}, lp = Ee.green, Yx = Ee.red, qoe = Ee.inverse, Ioe = Ee.bold, Ur$1 = Ee.dim;
function Moe(e, t = "received", r = "expected", n = {}) {
  let {
    comment: i = "",
    isDirectExpectCall: s = false,
    isNot: a = false,
    promise: l = "",
    secondArgument: u = "",
    expectedColor: c = lp,
    receivedColor: d = Yx,
    secondArgumentColor: p = lp
  } = n, f = "", m = "expect";
  return !s && t !== "" && (f += Ur$1(`${m}(`) + d(t), m = ")"), l !== "" && (f += Ur$1(`${m}.`) + l, m = ""), a && (f += `${Ur$1(`${m}.`)}not`, m = ""), e.includes(".") ? m += e : (f += Ur$1(`${m}.`) + e, m = ""), r === "" ? m += "()" : (f += Ur$1(`${m}(`) + c(r), u && (f += Ur$1(", ") + p(u)), m = ")"), i !== "" && (m += ` // ${i}`), m !== "" && (f += Ur$1(m)), f;
}
o(Moe, "matcherHint");
var Noe = "";
function BN(e) {
  return e.replace(/\s+$/gm, (t) => Noe.repeat(t.length));
}
o(BN, "replaceTrailingSpaces");
function joe(e) {
  return Yx(BN(Ye(e)));
}
o(joe, "printReceived");
function koe(e) {
  return lp(BN(Ye(e)));
}
o(koe, "printExpected");
function HN() {
  return {
    EXPECTED_COLOR: lp,
    RECEIVED_COLOR: Yx,
    INVERTED_COLOR: qoe,
    BOLD_WEIGHT: Ioe,
    DIM_COLOR: Ur$1,
    diff: Tn,
    matcherHint: Moe,
    printReceived: joe,
    printExpected: koe,
    printDiffOrStringify: vl,
    printWithType: Loe
  };
}
o(HN, "getMatcherUtils");
function Loe(e, t, r) {
  let n = xn(t), i = n !== "null" && n !== "undefined" ? `${e} has type:  ${n}
` : "", s = `${e} has value: ${r(t)}`;
  return i + s;
}
o(Loe, "printWithType");
function Kx() {
  return globalThis[As].customEqualityTesters;
}
o(Kx, "getCustomEqualityTesters");
function ce$1(e, t, r, n) {
  return r = r || [], _s(e, t, [], [], r, n ? UN : $oe);
}
o(ce$1, "equals");
function qN(e) {
  return !!e && typeof e == "object" && "asymmetricMatch" in e && Ht("Function", e.asymmetricMatch);
}
o(qN, "isAsymmetric");
function Foe(e, t) {
  let r = qN(e), n = qN(t);
  if (!(r && n)) {
    if (r)
      return e.asymmetricMatch(t);
    if (n)
      return t.asymmetricMatch(e);
  }
}
o(Foe, "asymmetricMatch");
function _s(e, t, r, n, i, s) {
  let a = true, l = Foe(e, t);
  if (l !== void 0)
    return l;
  let u = { equals: ce$1 };
  for (let h = 0; h < i.length; h++) {
    let b = i[h].call(u, e, t, i);
    if (b !== void 0)
      return b;
  }
  if (typeof URL == "function" && e instanceof URL && t instanceof URL)
    return e.href === t.href;
  if (Object.is(e, t))
    return true;
  if (e === null || t === null)
    return e === t;
  let c = Object.prototype.toString.call(e);
  if (c !== Object.prototype.toString.call(t))
    return false;
  switch (c) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      return typeof e != typeof t ? false : typeof e != "object" && typeof t != "object" ? Object.is(e, t) : Object.is(e.valueOf(), t.valueOf());
    case "[object Date]": {
      let h = +e, b = +t;
      return h === b || Number.isNaN(h) && Number.isNaN(b);
    }
    case "[object RegExp]":
      return e.source === t.source && e.flags === t.flags;
    case "[object Temporal.Instant]":
    case "[object Temporal.ZonedDateTime]":
    case "[object Temporal.PlainDateTime]":
    case "[object Temporal.PlainDate]":
    case "[object Temporal.PlainTime]":
    case "[object Temporal.PlainYearMonth]":
    case "[object Temporal.PlainMonthDay]":
      return e.equals(t);
    case "[object Temporal.Duration]":
      return e.toString() === t.toString();
  }
  if (typeof e != "object" || typeof t != "object")
    return false;
  if (MN(e) && MN(t))
    return e.isEqualNode(t);
  let d = r.length;
  for (; d--; ) {
    if (r[d] === e)
      return n[d] === t;
    if (n[d] === t)
      return false;
  }
  if (r.push(e), n.push(t), c === "[object Array]" && e.length !== t.length)
    return false;
  if (e instanceof Error && t instanceof Error)
    try {
      return Doe(e, t, r, n, i, s);
    } finally {
      r.pop(), n.pop();
    }
  let p = IN(e, s), f, m = p.length;
  if (IN(t, s).length !== m)
    return false;
  for (; m--; )
    if (f = p[m], a = s(t, f) && _s(e[f], t[f], r, n, i, s), !a)
      return false;
  return r.pop(), n.pop(), a;
}
o(_s, "eq");
function Doe(e, t, r, n, i, s) {
  let a = Object.getPrototypeOf(e) === Object.getPrototypeOf(t) && e.name === t.name && e.message === t.message;
  return typeof t.cause < "u" && a && (a = _s(e.cause, t.cause, r, n, i, s)), e instanceof AggregateError && t instanceof AggregateError && a && (a = _s(e.errors, t.errors, r, n, i, s)), a && (a = _s({ ...e }, { ...t }, r, n, i, s)), a;
}
o(Doe, "isErrorEqual");
function IN(e, t) {
  let r = [];
  for (let n in e)
    t(e, n) && r.push(n);
  return r.concat(Object.getOwnPropertySymbols(e).filter((n) => Object.getOwnPropertyDescriptor(e, n).enumerable));
}
o(IN, "keys");
function $oe(e, t) {
  return UN(e, t) && e[t] !== void 0;
}
o($oe, "hasDefinedKey");
function UN(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
o(UN, "hasKey");
function Ht(e, t) {
  return Object.prototype.toString.apply(t) === `[object ${e}]`;
}
o(Ht, "isA");
function MN(e) {
  return e !== null && typeof e == "object" && "nodeType" in e && typeof e.nodeType == "number" && "nodeName" in e && typeof e.nodeName == "string" && "isEqualNode" in e && typeof e.isEqualNode == "function";
}
o(MN, "isDomNode");
var VN = "@@__IMMUTABLE_KEYED__@@", zN = "@@__IMMUTABLE_SET__@@", Boe = "@@__IMMUTABLE_LIST__@@", yp = "@@__IMMUTABLE_ORDERED__@@", Hoe = "@@__IMMUTABLE_RECORD__@@";
function Uoe(e) {
  return !!(e && e[VN] && !e[yp]);
}
o(Uoe, "isImmutableUnorderedKeyed");
function Voe(e) {
  return !!(e && e[zN] && !e[yp]);
}
o(Voe, "isImmutableUnorderedSet");
function bp(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
o(bp, "isObjectLiteral");
function zoe(e) {
  return !!(e && bp(e) && e[Boe]);
}
o(zoe, "isImmutableList");
function Goe(e) {
  return !!(e && bp(e) && e[VN] && e[yp]);
}
o(Goe, "isImmutableOrderedKeyed");
function Woe(e) {
  return !!(e && bp(e) && e[zN] && e[yp]);
}
o(Woe, "isImmutableOrderedSet");
function Yoe(e) {
  return !!(e && bp(e) && e[Hoe]);
}
o(Yoe, "isImmutableRecord");
var GN = Symbol.iterator;
function NN(e) {
  return !!(e != null && e[GN]);
}
o(NN, "hasIterator");
function qt(e, t, r = [], n = [], i = []) {
  if (typeof e != "object" || typeof t != "object" || Array.isArray(e) || Array.isArray(t) || !NN(e) || !NN(t))
    return;
  if (e.constructor !== t.constructor)
    return false;
  let s = n.length;
  for (; s--; )
    if (n[s] === e)
      return i[s] === t;
  n.push(e), i.push(t);
  let a = [...r.filter((c) => c !== qt), l];
  function l(c, d) {
    return qt(c, d, [...r], [...n], [...i]);
  }
  if (o(l, "iterableEqualityWithStack"), e.size !== void 0) {
    if (e.size !== t.size)
      return false;
    if (Ht("Set", e) || Voe(e)) {
      let c = true;
      for (let d of e)
        if (!t.has(d)) {
          let p = false;
          for (let f of t)
            ce$1(d, f, a) === true && (p = true);
          if (p === false) {
            c = false;
            break;
          }
        }
      return n.pop(), i.pop(), c;
    } else if (Ht("Map", e) || Uoe(e)) {
      let c = true;
      for (let d of e)
        if (!t.has(d[0]) || !ce$1(d[1], t.get(d[0]), a)) {
          let p = false;
          for (let f of t) {
            let m = ce$1(d[0], f[0], a), h = false;
            m === true && (h = ce$1(d[1], f[1], a)), h === true && (p = true);
          }
          if (p === false) {
            c = false;
            break;
          }
        }
      return n.pop(), i.pop(), c;
    }
  }
  let u = t[GN]();
  for (let c of e) {
    let d = u.next();
    if (d.done || !ce$1(c, d.value, a))
      return false;
  }
  if (!u.next().done)
    return false;
  if (!zoe(e) && !Goe(e) && !Woe(e) && !Yoe(e)) {
    let c = Object.entries(e), d = Object.entries(t);
    if (!ce$1(c, d, a))
      return false;
  }
  return n.pop(), i.pop(), true;
}
o(qt, "iterableEquality");
function Xx(e, t) {
  return !e || typeof e != "object" || e === Object.prototype ? false : Object.prototype.hasOwnProperty.call(e, t) || Xx(Object.getPrototypeOf(
    e
  ), t);
}
o(Xx, "hasPropertyInObject");
function Koe(e) {
  return To(e) && !(e instanceof Error) && !Array.isArray(e) && !(e instanceof Date);
}
o(Koe, "isObjectWithKeys");
function Os(e, t, r = []) {
  let n = r.filter((s) => s !== Os), i = /* @__PURE__ */ o((s = /* @__PURE__ */ new WeakMap()) => (a, l) => {
    if (Koe(l))
      return Object.keys(l).every((u) => {
        if (l[u] != null && typeof l[u] == "object") {
          if (s.has(l[u]))
            return ce$1(a[u], l[u], n);
          s.set(l[u], true);
        }
        let c = a != null && Xx(a, u) && ce$1(a[u], l[u], [...n, i(s)]);
        return s.delete(l[u]), c;
      });
  }, "subsetEqualityWithContext");
  return i()(e, t);
}
o(Os, "subsetEquality");
function jN(e, t) {
  if (!(e == null || t == null || e.constructor === t.constructor))
    return false;
}
o(jN, "typeEquality");
function kN(e, t) {
  let r = e, n = t;
  if (!(e instanceof DataView && t instanceof DataView)) {
    if (!(e instanceof ArrayBuffer) || !(t instanceof ArrayBuffer))
      return;
    try {
      r = new DataView(e), n = new DataView(t);
    } catch {
      return;
    }
  }
  if (r.byteLength !== n.byteLength)
    return false;
  for (let i = 0; i < r.byteLength; i++)
    if (r.getUint8(i) !== n.getUint8(i))
      return false;
  return true;
}
o(kN, "arrayBufferEquality");
function zx(e, t, r = []) {
  if (!Array.isArray(e) || !Array.isArray(t))
    return;
  let n = Object.keys(e), i = Object.keys(t), s = r.filter((a) => a !== zx);
  return ce$1(e, t, s, true) && ce$1(n, i);
}
o(zx, "sparseArrayEquality");
function Xoe(e, t = "#{this}", r = "#{exp}") {
  let n = `expected ${t} to be ${r} // Object.is equality`;
  return ["toStrictEqual", "toEqual"].includes(e) ? `${n}

If it should pass with deep equality, replace "toBe" with "${e}"

Expected: ${t}
Received: serializes to the same string
` : n;
}
o(Xoe, "generateToBeMessage");
function Joe(e, t) {
  return `${t} ${e}${t === 1 ? "" : "s"}`;
}
o(Joe, "pluralize");
function Hx(e) {
  return [...Object.keys(e), ...Object.getOwnPropertySymbols(e).filter((t) => {
    var r;
    return (r = Object.getOwnPropertyDescriptor(e, t)) === null || r === void 0 ? void 0 : r.enumerable;
  })];
}
o(Hx, "getObjectKeys");
function Qoe(e, t, r) {
  let n = 0, i = /* @__PURE__ */ o((s = /* @__PURE__ */ new WeakMap()) => (a, l) => {
    if (Array.isArray(a)) {
      if (Array.isArray(l) && l.length === a.length)
        return l.map((u, c) => i(s)(a[c], u));
    } else {
      if (a instanceof Date)
        return a;
      if (To(a) && To(l)) {
        if (ce$1(a, l, [
          ...r,
          qt,
          Os
        ]))
          return l;
        let u = {};
        s.set(a, u), typeof a.constructor == "function" && typeof a.constructor.name == "string" && Object.defineProperty(u, "constructor", {
          enumerable: false,
          value: a.constructor
        });
        for (let c of Hx(a))
          Xx(l, c) ? u[c] = s.has(a[c]) ? s.get(a[c]) : i(s)(a[c], l[c]) : s.has(a[c]) || (n += 1, To(a[c]) && (n += Hx(a[c]).length), i(s)(
            a[c],
            l[c]
          ));
        if (Hx(u).length > 0)
          return u;
      }
    }
    return a;
  }, "getObjectSubsetWithContext");
  return {
    subset: i()(e, t),
    stripped: n
  };
}
o(Qoe, "getObjectSubset");
if (!Object.prototype.hasOwnProperty.call(globalThis, Ps)) {
  let e = /* @__PURE__ */ new WeakMap();
  Object.defineProperty(globalThis, Ps, { get: /* @__PURE__ */ o(() => e, "get") });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, As)) {
  let e = /* @__PURE__ */ Object.create(null), t = [];
  Object.defineProperty(globalThis, As, {
    configurable: true,
    get: /* @__PURE__ */ o(() => ({
      state: globalThis[Ps].get(globalThis[hp]),
      matchers: e,
      customEqualityTesters: t
    }), "get")
  });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, Vx)) {
  let e = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, Vx, { get: /* @__PURE__ */ o(() => e, "get") });
}
function qs(e) {
  return globalThis[Ps].get(e);
}
o(qs, "getState");
function gp(e, t) {
  let r = globalThis[Ps], n = r.get(t) || {}, i = Object.defineProperties(n, {
    ...Object.getOwnPropertyDescriptors(n),
    ...Object.getOwnPropertyDescriptors(e)
  });
  r.set(t, i);
}
o(gp, "setState");
var Jx = class Jx2 {
  // should have "jest" to be compatible with its ecosystem
  $$typeof = Symbol.for("jest.asymmetricMatcher");
  constructor(t, r = false) {
    this.sample = t, this.inverse = r;
  }
  getMatcherContext(t) {
    return {
      ...qs(t || globalThis[hp]),
      equals: ce$1,
      isNot: this.inverse,
      customTesters: Kx(),
      utils: {
        ...HN(),
        diff: Tn,
        stringify: Ye,
        iterableEquality: qt,
        subsetEquality: Os
      }
    };
  }
};
o(Jx, "AsymmetricMatcher");
var Ut = Jx;
Ut.prototype[Symbol.for("chai/inspect")] = function(e) {
  let t = Ye(this, e.depth, { min: true });
  return t.length <= e.truncate ? t : `${this.toString()}{}`;
};
var Qx = class Qx2 extends Ut {
  constructor(t, r = false) {
    if (!Ht("String", t))
      throw new Error("Expected is not a string");
    super(t, r);
  }
  asymmetricMatch(t) {
    let r = Ht("String", t) && t.includes(this.sample);
    return this.inverse ? !r : r;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "string";
  }
};
o(Qx, "StringContaining");
var up = Qx, Zx = class Zx2 extends Ut {
  asymmetricMatch(t) {
    return t != null;
  }
  toString() {
    return "Anything";
  }
  toAsymmetricMatcher() {
    return "Anything";
  }
};
o(Zx, "Anything");
var Gx = Zx, ew = class ew2 extends Ut {
  constructor(t, r = false) {
    super(t, r);
  }
  getPrototype(t) {
    return Object.getPrototypeOf ? Object.getPrototypeOf(t) : t.constructor.prototype === t ? null : t.constructor.prototype;
  }
  hasProperty(t, r) {
    return t ? Object.prototype.hasOwnProperty.call(t, r) ? true : this.hasProperty(this.getPrototype(t), r) : false;
  }
  asymmetricMatch(t) {
    if (typeof this.sample != "object")
      throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
    let r = true, n = this.getMatcherContext();
    for (let i in this.sample)
      if (!this.hasProperty(t, i) || !ce$1(this.sample[i], t[i], n.customTesters)) {
        r = false;
        break;
      }
    return this.inverse ? !r : r;
  }
  toString() {
    return `Object${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "object";
  }
};
o(ew, "ObjectContaining");
var cp = ew, tw = class tw2 extends Ut {
  constructor(t, r = false) {
    super(t, r);
  }
  asymmetricMatch(t) {
    if (!Array.isArray(this.sample))
      throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
    let r = this.getMatcherContext(), n = this.sample.length === 0 || Array.isArray(t) && this.sample.every((i) => t.some((s) => ce$1(i, s, r.customTesters)));
    return this.inverse ? !n : n;
  }
  toString() {
    return `Array${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "array";
  }
};
o(tw, "ArrayContaining");
var dp = tw, rw = class rw2 extends Ut {
  constructor(t) {
    if (typeof t > "u")
      throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
    super(t);
  }
  fnNameFor(t) {
    if (t.name)
      return t.name;
    let n = Function.prototype.toString.call(t).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
    return n ? n[1] : "<anonymous>";
  }
  asymmetricMatch(t) {
    return this.sample === String ? typeof t == "string" || t instanceof String : this.sample === Number ? typeof t == "number" || t instanceof Number : this.sample === Function ? typeof t == "function" || typeof t == "function" : this.sample === Boolean ? typeof t == "boolean" || t instanceof Boolean : this.sample === BigInt ? typeof t == "bigint" || t instanceof BigInt : this.sample === Symbol ? typeof t == "symbol" || t instanceof Symbol : this.sample === Object ? typeof t == "object" : t instanceof this.sample;
  }
  toString() {
    return "Any";
  }
  getExpectedType() {
    return this.sample === String ? "string" : this.sample === Number ? "number" : this.sample === Function ? "function" : this.sample === Object ? "object" : this.sample === Boolean ? "boolean" : this.fnNameFor(this.sample);
  }
  toAsymmetricMatcher() {
    return `Any<${this.fnNameFor(this.sample)}>`;
  }
};
o(rw, "Any");
var Wx = rw, nw = class nw2 extends Ut {
  constructor(t, r = false) {
    if (!Ht("String", t) && !Ht("RegExp", t))
      throw new Error("Expected is not a String or a RegExp");
    super(new RegExp(t), r);
  }
  asymmetricMatch(t) {
    let r = Ht("String", t) && this.sample.test(t);
    return this.inverse ? !r : r;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Matching`;
  }
  getExpectedType() {
    return "string";
  }
};
o(nw, "StringMatching");
var pp = nw, ow = class ow2 extends Ut {
  precision;
  constructor(t, r = 2, n = false) {
    if (!Ht("Number", t))
      throw new Error("Expected is not a Number");
    if (!Ht("Number", r))
      throw new Error("Precision is not a Number");
    super(t), this.inverse = n, this.precision = r;
  }
  asymmetricMatch(t) {
    if (!Ht("Number", t))
      return false;
    let r = false;
    return t === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY || t === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY ? r = true : r = Math.abs(this.sample - t) < 10 ** -this.precision / 2, this.inverse ? !r : r;
  }
  toString() {
    return `Number${this.inverse ? "Not" : ""}CloseTo`;
  }
  getExpectedType() {
    return "number";
  }
  toAsymmetricMatcher() {
    return [
      this.toString(),
      this.sample,
      `(${Joe("digit", this.precision)})`
    ].join(" ");
  }
};
o(ow, "CloseTo");
var fp = ow, WN = /* @__PURE__ */ o((e, t) => {
  t.addMethod(e.expect, "anything", () => new Gx()), t.addMethod(e.expect, "any", (r) => new Wx(r)), t.addMethod(
    e.expect,
    "stringContaining",
    (r) => new up(r)
  ), t.addMethod(e.expect, "objectContaining", (r) => new cp(r)), t.addMethod(e.expect, "arrayContaining", (r) => new dp(r)), t.addMethod(e.expect, "stringMatching", (r) => new pp(r)), t.addMethod(e.expect, "closeTo", (r, n) => new fp(r, n)), e.expect.not = {
    stringContaining: /* @__PURE__ */ o((r) => new up(r, true), "stringContaining"),
    objectContaining: /* @__PURE__ */ o((r) => new cp(r, true), "objectContaining"),
    arrayContaining: /* @__PURE__ */ o((r) => new dp(r, true), "arrayContaining"),
    stringMatching: /* @__PURE__ */ o((r) => new pp(r, true), "stringMatching"),
    closeTo: /* @__PURE__ */ o((r, n) => new fp(r, n, true), "closeTo")
  };
}, "JestAsymmetricMatchers");
function LN(e, t, r) {
  let n = e.flag(t, "negate") ? "not." : "", i = `${e.flag(t, "_name")}(${r ? "expected" : ""})`, s = e.flag(t, "promise");
  return `expect(actual)${s ? `.${s}` : ""}.${n}${i}`;
}
o(LN, "createAssertionMessage");
function FN(e, t, r, n) {
  let i = e;
  if (i && t instanceof Promise) {
    t = t.finally(() => {
      if (!i.promises)
        return;
      let a = i.promises.indexOf(t);
      a !== -1 && i.promises.splice(a, 1);
    }), i.promises || (i.promises = []), i.promises.push(t);
    let s = false;
    return i.onFinished ?? (i.onFinished = []), i.onFinished.push(() => {
      if (!s) {
        var a;
        let u = (((a = globalThis.__vitest_worker__) === null || a === void 0 ? void 0 : a.onFilterStackTrace) || ((c) => c || ""))(n.stack);
        console.warn([
          `Promise returned by \`${r}\` was not awaited. `,
          "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
          `Please remember to await the assertion.
`,
          u
        ].join(""));
      }
    }), {
      then(a, l) {
        return s = true, t.then(a, l);
      },
      catch(a) {
        return t.catch(a);
      },
      finally(a) {
        return t.finally(a);
      },
      [Symbol.toStringTag]: "Promise"
    };
  }
  return t;
}
o(FN, "recordAsyncExpect");
function DN(e, t) {
  var r;
  e.result || (e.result = { state: "fail" }), e.result.state = "fail", (r = e.result).errors || (r.errors = []), e.result.errors.push(Ki(t));
}
o(DN, "handleTestError");
function YN(e, t, r) {
  return function(...n) {
    if (t !== "withTest" && e.flag(this, "_name", t), !e.flag(this, "soft"))
      return r.apply(this, n);
    let i = e.flag(this, "vitest-test");
    if (!i)
      throw new Error("expect.soft() can only be used inside a test");
    try {
      let s = r.apply(this, n);
      return s && typeof s == "object" && typeof s.then == "function" ? s.then(Ug, (a) => {
        DN(i, a);
      }) : s;
    } catch (s) {
      DN(i, s);
    }
  };
}
o(YN, "wrapAssertion");
var KN = /* @__PURE__ */ o((e, t) => {
  let { AssertionError: r } = e, n = Kx();
  function i(c, d) {
    let p = /* @__PURE__ */ o((f) => {
      let m = YN(t, f, d);
      t.addMethod(e.Assertion.prototype, f, m), t.addMethod(globalThis[As].matchers, f, m);
    }, "addMethod");
    Array.isArray(c) ? c.forEach((f) => p(f)) : p(c);
  }
  o(i, "def"), [
    "throw",
    "throws",
    "Throw"
  ].forEach((c) => {
    t.overwriteMethod(e.Assertion.prototype, c, (d) => function(...p) {
      let f = t.flag(this, "promise"), m = t.flag(this, "object"), h = t.flag(this, "negate");
      if (f === "rejects")
        t.flag(this, "object", () => {
          throw m;
        });
      else if (f === "resolves" && typeof m != "function") {
        if (h)
          return;
        {
          let b = t.flag(this, "message") || "expected promise to throw an error, but it didn't", v = { showDiff: false };
          throw new r(b, v, t.flag(this, "ssfi"));
        }
      }
      d.apply(this, p);
    });
  }), i("withTest", function(c) {
    return t.flag(this, "vitest-test", c), this;
  }), i("toEqual", function(c) {
    let d = t.flag(this, "object"), p = ce$1(d, c, [...n, qt]);
    return this.assert(p, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", c, d);
  }), i("toStrictEqual", function(c) {
    let d = t.flag(this, "object"), p = ce$1(d, c, [
      ...n,
      qt,
      jN,
      zx,
      kN
    ], true);
    return this.assert(p, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", c, d);
  }), i("toBe", function(c) {
    let d = this._obj, p = Object.is(d, c), f = "";
    return p || (ce$1(d, c, [
      ...n,
      qt,
      jN,
      zx,
      kN
    ], true) ? f = "toStrictEqual" : ce$1(d, c, [...n, qt]) && (f = "toEqual")), this.assert(p, Xoe(f), "expected #{this} not to be #{exp} // Object.is equality", c, d);
  }), i("toMatchObject", function(c) {
    let d = this._obj, p = ce$1(d, c, [
      ...n,
      qt,
      Os
    ]), f = t.flag(this, "negate"), { subset: m, stripped: h } = Qoe(d, c, n);
    if (p && f || !p && !f) {
      let b = t.getMessage(this, [
        p,
        "expected #{this} to match object #{exp}",
        "expected #{this} to not match object #{exp}",
        c,
        m,
        false
      ]), v = h === 0 ? b : `${b}
(${h} matching ${h === 1 ? "property" : "properties"} omitted from actual)`;
      throw new r(v, {
        showDiff: true,
        expected: c,
        actual: m
      });
    }
  }), i("toMatch", function(c) {
    let d = this._obj;
    if (typeof d != "string")
      throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof d}`);
    return this.assert(typeof c == "string" ? d.includes(c) : d.match(c), "expected #{this} to match #{exp}", "expected #{this} not to match #{exp}", c, d);
  }), i("toContain", function(c) {
    let d = this._obj;
    if (typeof Node < "u" && d instanceof Node) {
      if (!(c instanceof Node))
        throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof c}`);
      return this.assert(d.contains(c), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", c, d);
    }
    if (typeof DOMTokenList < "u" && d instanceof DOMTokenList) {
      Dt$1(c, "class name", ["string"]);
      let f = t.flag(this, "negate") ? d.value.replace(c, "").trim() : `${d.value} ${c}`;
      return this.assert(d.contains(c), `expected "${d.value}" to contain "${c}"`, `expected "${d.value}" not to contain "${c}"`, f, d.value);
    }
    return typeof d == "string" && typeof c == "string" ? this.assert(d.includes(c), "expected #{this} to contain #{exp}", "expected #{this} not to contain #{exp}", c, d) : (d != null && typeof d != "string" && t.flag(this, "object", Array.from(d)), this.contain(c));
  }), i("toContainEqual", function(c) {
    let d = t.flag(this, "object"), p = Array.from(d).findIndex((f) => ce$1(f, c, n));
    this.assert(p !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", c);
  }), i("toBeTruthy", function() {
    let c = t.flag(this, "object");
    this.assert(!!c, "expected #{this} to be truthy", "expected #{this} to not be truthy", true, c);
  }), i("toBeFalsy", function() {
    let c = t.flag(this, "object");
    this.assert(!c, "expected #{this} to be falsy", "expected #{this} to not be falsy", false, c);
  }), i("toBeGreaterThan", function(c) {
    let d = this._obj;
    return Dt$1(d, "actual", ["number", "bigint"]), Dt$1(c, "expected", ["number", "bigint"]), this.assert(d > c, `expected ${d} to be greater than ${c}`, `expected ${d} to be not greater than ${c}`, c, d, false);
  }), i("toBeGreaterThanOrEqual", function(c) {
    let d = this._obj;
    return Dt$1(d, "actual", ["number", "bigint"]), Dt$1(c, "expected", ["number", "bigint"]), this.assert(d >= c, `expected ${d} to be greater than or equal to ${c}`, `expected ${d} to be not greater than or equal to ${c}`, c, d, false);
  }), i("toBeLessThan", function(c) {
    let d = this._obj;
    return Dt$1(d, "actual", ["number", "bigint"]), Dt$1(c, "expected", ["number", "bigint"]), this.assert(d < c, `expected ${d} to be less than ${c}`, `expected ${d} to be not less than ${c}`, c, d, false);
  }), i("toBeLessThanOrEqual", function(c) {
    let d = this._obj;
    return Dt$1(d, "actual", ["number", "bigint"]), Dt$1(c, "expected", ["number", "bigint"]), this.assert(d <= c, `expected ${d} to be less than or equal to ${c}`, `expected ${d} to be not less than or equal to ${c}`, c, d, false);
  }), i("toBeNaN", function() {
    let c = t.flag(this, "object");
    this.assert(Number.isNaN(c), "expected #{this} to be NaN", "expected #{this} not to be NaN", Number.NaN, c);
  }), i("toBeUndefined", function() {
    let c = t.flag(this, "object");
    this.assert(c === void 0, "expected #{this} to be undefined", "expected #{this} not to be undefined", void 0, c);
  }), i("toBeNull", function() {
    let c = t.flag(this, "object");
    this.assert(c === null, "expected #{this} to be null", "expected #{this} not to be null", null, c);
  }), i("toBeDefined", function() {
    let c = t.flag(this, "object");
    this.assert(typeof c < "u", "expected #{this} to be defined", "expected #{this} to be undefined", c);
  }), i("toBeTypeOf", function(c) {
    let d = typeof this._obj, p = c === d;
    return this.assert(p, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", c, d);
  }), i("toBeInstanceOf", function(c) {
    return this.instanceOf(c);
  }), i("toHaveLength", function(c) {
    return this.have.length(c);
  }), i("toHaveProperty", function(...c) {
    Array.isArray(c[0]) && (c[0] = c[0].map((w) => String(w).replace(/([.[\]])/g, "\\$1")).join("."));
    let d = this._obj, [p, f] = c, m = /* @__PURE__ */ o(() => Object.prototype.hasOwnProperty.call(d, p) ? {
      value: d[p],
      exists: true
    } : t.getPathInfo(d, p), "getValue"), { value: h, exists: b } = m(), v = b && (c.length === 1 || ce$1(f, h, n)), g = c.length === 1 ? "" : ` with value ${t.objDisplay(f)}`;
    return this.assert(v, `expected #{this} to have property "${p}"${g}`, `expected #{this} to not have property "${p}"${g}`, f, b ? h : void 0);
  }), i("toBeCloseTo", function(c, d = 2) {
    let p = this._obj, f = false, m = 0, h = 0;
    return c === Number.POSITIVE_INFINITY && p === Number.POSITIVE_INFINITY || c === Number.NEGATIVE_INFINITY && p === Number.NEGATIVE_INFINITY ? f = true : (m = 10 ** -d / 2, h = Math.abs(p - c), f = h < m), this.assert(f, `expected #{this} to be close to #{exp}, received difference is ${h}, but expected ${m}`, `expected #{this} to not be close to #{exp}, received difference is ${h}, but expected ${m}`, c, p, false);
  });
  function s(c) {
    if (!hr$1(c._obj))
      throw new TypeError(`${t.inspect(c._obj)} is not a spy or a call to a spy!`);
  }
  o(s, "assertIsMock");
  function a(c) {
    return s(c), c._obj;
  }
  o(a, "getSpy"), i(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(c) {
    let d = a(this), p = d.getMockName(), f = d.mock.calls.length;
    return this.assert(f === c, `expected "${p}" to be called #{exp} times, but got ${f} times`, `expected "${p}" to not be called #{exp} times`, c, f, false);
  }), i("toHaveBeenCalledOnce", function() {
    let c = a(this), d = c.getMockName(), p = c.mock.calls.length;
    return this.assert(p === 1, `expected "${d}" to be called once, but got ${p} times`, `expected "${d}" to not be called once`, 1, p, false);
  }), i(["toHaveBeenCalled", "toBeCalled"], function() {
    let c = a(this), d = c.getMockName(), p = c.mock.calls.length, f = p > 0, m = t.flag(this, "negate"), h = t.getMessage(this, [
      f,
      `expected "${d}" to be called at least once`,
      `expected "${d}" to not be called at all, but actually been called ${p} times`,
      true,
      f
    ]);
    if (f && m && (h = Ux(c, h)), f && m || !f && !m)
      throw new r(h);
  });
  function l(c, d) {
    return c.length === d.length && c.every((p, f) => ce$1(p, d[f], [...n, qt]));
  }
  o(l, "equalsArgumentArray"), i(["toHaveBeenCalledWith", "toBeCalledWith"], function(...c) {
    let d = a(this), p = d.getMockName(), f = d.mock.calls.some((b) => l(b, c)), m = t.flag(this, "negate"), h = t.getMessage(this, [
      f,
      `expected "${p}" to be called with arguments: #{exp}`,
      `expected "${p}" to not be called with arguments: #{exp}`,
      c
    ]);
    if (f && m || !f && !m)
      throw new r(Ux(d, h, c));
  }), i("toHaveBeenCalledExactlyOnceWith", function(...c) {
    let d = a(this), p = d.getMockName(), f = d.mock.calls.length, h = d.mock.calls.some((g) => l(g, c)) && f === 1, b = t.flag(this, "negate"), v = t.getMessage(this, [
      h,
      `expected "${p}" to be called once with arguments: #{exp}`,
      `expected "${p}" to not be called once with arguments: #{exp}`,
      c
    ]);
    if (h && b || !h && !b)
      throw new r(Ux(d, v, c));
  }), i(["toHaveBeenNthCalledWith", "nthCalledWith"], function(c, ...d) {
    let p = a(this), f = p.getMockName(), m = p.mock.calls[c - 1], h = p.mock.calls.length, b = c <= h;
    this.assert(m && l(m, d), `expected ${Cs(c)} "${f}" call to have been called with #{exp}${b ? "" : `, but called only ${h} times`}`, `expected ${Cs(c)} "${f}" call to not have been called with #{exp}`, d, m, b);
  }), i(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...c) {
    let d = a(this), p = d.getMockName(), f = d.mock.calls[d.mock.calls.length - 1];
    this.assert(f && l(f, c), `expected last "${p}" call to have been called with #{exp}`, `expected last "${p}" call to not have been called with #{exp}`, c, f);
  });
  function u(c, d, p) {
    let f = c.mock.invocationCallOrder, m = d.mock.invocationCallOrder;
    return f.length === 0 ? !p : m.length === 0 ? false : f[0] < m[0];
  }
  o(u, "isSpyCalledBeforeAnotherSpy"), i(["toHaveBeenCalledBefore"], function(c, d = true) {
    let p = a(this);
    if (!hr$1(c))
      throw new TypeError(`${t.inspect(c)} is not a spy or a call to a spy`);
    this.assert(u(p, c, d), `expected "${p.getMockName()}" to have been called before "${c.getMockName()}"`, `expected "${p.getMockName()}" to not have been called before "${c.getMockName()}"`, c, p);
  }), i(["toHaveBeenCalledAfter"], function(c, d = true) {
    let p = a(this);
    if (!hr$1(c))
      throw new TypeError(`${t.inspect(c)} is not a spy or a call to a spy`);
    this.assert(u(c, p, d), `expected "${p.getMockName()}" to have been called after "${c.getMockName()}"`, `expected "${p.getMockName()}" to not have been called after "${c.getMockName()}"`, c, p);
  }), i(["toThrow", "toThrowError"], function(c) {
    if (typeof c == "string" || typeof c > "u" || c instanceof RegExp)
      return this.throws(c === "" ? /^$/ : c);
    let d = this._obj, p = t.flag(this, "promise"), f = t.flag(this, "negate"), m = null;
    if (p === "rejects")
      m = d;
    else if (p === "resolves" && typeof d != "function") {
      if (f)
        return;
      {
        let h = t.flag(this, "message") || "expected promise to throw an error, but it didn't", b = { showDiff: false };
        throw new r(h, b, t.flag(this, "ssfi"));
      }
    } else {
      let h = false;
      try {
        d();
      } catch (b) {
        h = true, m = b;
      }
      if (!h && !f) {
        let b = t.flag(this, "message") || "expected function to throw an error, but it didn't", v = { showDiff: false };
        throw new r(b, v, t.flag(this, "ssfi"));
      }
    }
    if (typeof c == "function") {
      let h = c.name || c.prototype.constructor.name;
      return this.assert(m && m instanceof c, `expected error to be instance of ${h}`, `expected error not to be instance of ${h}`, c, m);
    }
    if (c instanceof Error) {
      let h = ce$1(m, c, [...n, qt]);
      return this.assert(h, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", c, m);
    }
    if (typeof c == "object" && "asymmetricMatch" in c && typeof c.asymmetricMatch == "function") {
      let h = c;
      return this.assert(m && h.asymmetricMatch(m), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", h, m);
    }
    throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof c}"`);
  }), [{
    name: "toHaveResolved",
    condition: /* @__PURE__ */ o((c) => c.mock.settledResults.length > 0 && c.mock.settledResults.some(({ type: d }) => d === "fulfilled"), "condition"),
    action: "resolved"
  }, {
    name: ["toHaveReturned", "toReturn"],
    condition: /* @__PURE__ */ o((c) => c.mock.calls.length > 0 && c.mock.results.some(({ type: d }) => d !== "throw"), "condition"),
    action: "called"
  }].forEach(({ name: c, condition: d, action: p }) => {
    i(c, function() {
      let f = a(this), m = f.getMockName(), h = d(f);
      this.assert(h, `expected "${m}" to be successfully ${p} at least once`, `expected "${m}" to not be successfully ${p}`, h, !h, false);
    });
  }), [{
    name: "toHaveResolvedTimes",
    condition: /* @__PURE__ */ o((c, d) => c.mock.settledResults.reduce((p, { type: f }) => f === "fulfilled" ? ++p : p, 0) === d, "condition"),
    action: "resolved"
  }, {
    name: ["toHaveReturnedTimes", "toReturnTimes"],
    condition: /* @__PURE__ */ o((c, d) => c.mock.results.reduce((p, { type: f }) => f === "throw" ? p : ++p, 0) === d, "condition"),
    action: "called"
  }].forEach(({ name: c, condition: d, action: p }) => {
    i(c, function(f) {
      let m = a(this), h = m.getMockName(), b = d(m, f);
      this.assert(b, `expected "${h}" to be successfully ${p} ${f} times`, `expected "${h}" to not be successfully ${p} ${f} times`, `expected resolved times: ${f}`, `received resolved times: ${b}`, false);
    });
  }), [{
    name: "toHaveResolvedWith",
    condition: /* @__PURE__ */ o((c, d) => c.mock.settledResults.some(({ type: p, value: f }) => p === "fulfilled" && ce$1(d, f)), "condition"),
    action: "resolve"
  }, {
    name: ["toHaveReturnedWith", "toReturnWith"],
    condition: /* @__PURE__ */ o((c, d) => c.mock.results.some(({ type: p, value: f }) => p === "return" && ce$1(d, f)), "condition"),
    action: "return"
  }].forEach(({ name: c, condition: d, action: p }) => {
    i(c, function(f) {
      let m = a(this), h = d(m, f), b = t.flag(this, "negate");
      if (h && b || !h && !b) {
        let v = m.getMockName(), g = t.getMessage(this, [
          h,
          `expected "${v}" to ${p} with: #{exp} at least once`,
          `expected "${v}" to not ${p} with: #{exp}`,
          f
        ]), w = p === "return" ? m.mock.results : m.mock.settledResults;
        throw new r(Zoe(m, w, g, f));
      }
    });
  }), [{
    name: "toHaveLastResolvedWith",
    condition: /* @__PURE__ */ o((c, d) => {
      let p = c.mock.settledResults[c.mock.settledResults.length - 1];
      return p && p.type === "fulfilled" && ce$1(p.value, d);
    }, "condition"),
    action: "resolve"
  }, {
    name: ["toHaveLastReturnedWith", "lastReturnedWith"],
    condition: /* @__PURE__ */ o((c, d) => {
      let p = c.mock.results[c.mock.results.length - 1];
      return p && p.type === "return" && ce$1(p.value, d);
    }, "condition"),
    action: "return"
  }].forEach(({ name: c, condition: d, action: p }) => {
    i(c, function(f) {
      let m = a(this), h = p === "return" ? m.mock.results : m.mock.settledResults, b = h[h.length - 1], v = m.getMockName();
      this.assert(d(m, f), `expected last "${v}" call to ${p} #{exp}`, `expected last "${v}" call to not ${p} #{exp}`, f, b?.value);
    });
  }), [{
    name: "toHaveNthResolvedWith",
    condition: /* @__PURE__ */ o((c, d, p) => {
      let f = c.mock.settledResults[d - 1];
      return f && f.type === "fulfilled" && ce$1(f.value, p);
    }, "condition"),
    action: "resolve"
  }, {
    name: ["toHaveNthReturnedWith", "nthReturnedWith"],
    condition: /* @__PURE__ */ o((c, d, p) => {
      let f = c.mock.results[d - 1];
      return f && f.type === "return" && ce$1(f.value, p);
    }, "condition"),
    action: "return"
  }].forEach(({ name: c, condition: d, action: p }) => {
    i(c, function(f, m) {
      let h = a(this), b = h.getMockName(), g = (p === "return" ? h.mock.results : h.mock.settledResults)[f - 1], w = `${Cs(f)} call`;
      this.assert(d(h, f, m), `expected ${w} "${b}" call to ${p} #{exp}`, `expected ${w} "${b}" call to not ${p} #{exp}`, m, g?.value);
    });
  }), i("withContext", function(c) {
    for (let d in c)
      t.flag(this, d, c[d]);
    return this;
  }), t.addProperty(e.Assertion.prototype, "resolves", /* @__PURE__ */ o(function() {
    let d = new Error("resolves");
    t.flag(this, "promise", "resolves"), t.flag(this, "error", d);
    let p = t.flag(this, "vitest-test"), f = t.flag(this, "object");
    if (t.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .resolves");
    if (typeof f?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof f}'.`);
    let m = new Proxy(this, { get: /* @__PURE__ */ o((h, b, v) => {
      let g = Reflect.get(h, b, v);
      return typeof g != "function" ? g instanceof e.Assertion ? m : g : (...w) => {
        t.flag(this, "_name", b);
        let E = f.then((R) => (t.flag(this, "object", R), g.call(this, ...w)), (R) => {
          let S = new r(`promise rejected "${t.inspect(R)}" instead of resolving`, { showDiff: false });
          throw S.cause = R, S.stack = d.stack.replace(d.message, S.message), S;
        });
        return FN(p, E, LN(t, this, !!w.length), d);
      };
    }, "get") });
    return m;
  }, "__VITEST_RESOLVES__")), t.addProperty(e.Assertion.prototype, "rejects", /* @__PURE__ */ o(function() {
    let d = new Error("rejects");
    t.flag(this, "promise", "rejects"), t.flag(this, "error", d);
    let p = t.flag(this, "vitest-test"), f = t.flag(this, "object"), m = typeof f == "function" ? f() : f;
    if (t.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .rejects");
    if (typeof m?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof m}'.`);
    let h = new Proxy(this, { get: /* @__PURE__ */ o((b, v, g) => {
      let w = Reflect.get(b, v, g);
      return typeof w != "function" ? w instanceof e.Assertion ? h : w : (...E) => {
        t.flag(this, "_name", v);
        let R = m.then((S) => {
          let P = new r(`promise resolved "${t.inspect(S)}" instead of rejecting`, {
            showDiff: true,
            expected: new Error("rejected promise"),
            actual: S
          });
          throw P.stack = d.stack.replace(d.message, P.message), P;
        }, (S) => (t.flag(this, "object", S), w.call(this, ...E)));
        return FN(p, R, LN(t, this, !!E.length), d);
      };
    }, "get") });
    return h;
  }, "__VITEST_REJECTS__"));
}, "JestChaiExpect");
function Cs(e) {
  let t = e % 10, r = e % 100;
  return t === 1 && r !== 11 ? `${e}st` : t === 2 && r !== 12 ? `${e}nd` : t === 3 && r !== 13 ? `${e}rd` : `${e}th`;
}
o(Cs, "ordinalOf");
function Ux(e, t, r) {
  return e.mock.calls.length && (t += Ee.gray(`

Received: 

${e.mock.calls.map((n, i) => {
    let s = Ee.bold(`  ${Cs(i + 1)} ${e.getMockName()} call:

`);
    return r ? s += Tn(r, n, { omitAnnotationLines: true }) : s += Ye(n).split(`
`).map((a) => `    ${a}`).join(`
`), s += `
`, s;
  }).join(`
`)}`)), t += Ee.gray(`

Number of calls: ${Ee.bold(e.mock.calls.length)}
`), t;
}
o(Ux, "formatCalls");
function Zoe(e, t, r, n) {
  return t.length && (r += Ee.gray(`

Received: 

${t.map((i, s) => {
    let a = Ee.bold(`  ${Cs(s + 1)} ${e.getMockName()} call return:

`);
    return n ? a += Tn(n, i.value, { omitAnnotationLines: true }) : a += Ye(i).split(`
`).map((l) => `    ${l}`).join(`
`), a += `
`, a;
  }).join(`
`)}`)), r += Ee.gray(`

Number of calls: ${Ee.bold(e.mock.calls.length)}
`), r;
}
o(Zoe, "formatReturns");
function eie(e, t) {
  let r = e._obj, n = _t.flag(e, "negate"), i = _t.flag(e, "promise") || "", s = {
    ...HN(),
    diff: Tn,
    stringify: Ye,
    iterableEquality: qt,
    subsetEquality: Os
  };
  return {
    state: {
      ...qs(t),
      customTesters: Kx(),
      isNot: n,
      utils: s,
      promise: i,
      equals: ce$1,
      suppressedErrors: [],
      soft: _t.flag(e, "soft"),
      poll: _t.flag(e, "poll")
    },
    isNot: n,
    obj: r
  };
}
o(eie, "getMatcherState");
var iw = class iw2 extends Error {
  constructor(t, r, n) {
    super(t), this.actual = r, this.expected = n;
  }
};
o(iw, "JestExtendError");
var mp = iw;
function tie(e, t, r) {
  return (n, i) => {
    Object.entries(r).forEach(([s, a]) => {
      function l(...f) {
        let { state: m, isNot: h, obj: b } = eie(this, t), v = a.call(m, b, ...f);
        if (v && typeof v == "object" && typeof v.then == "function")
          return v.then(({ pass: P, message: _, actual: C, expected: O }) => {
            if (P && h || !P && !h)
              throw new mp(_(), C, O);
          });
        let { pass: g, message: w, actual: E, expected: R } = v;
        if (g && h || !g && !h)
          throw new mp(w(), E, R);
      }
      o(l, "expectWrapper");
      let u = YN(i, s, l);
      i.addMethod(globalThis[As].matchers, s, u), i.addMethod(e.Assertion.prototype, s, u);
      let p = class p extends Ut {
        constructor(m = false, ...h) {
          super(h, m);
        }
        asymmetricMatch(m) {
          let { pass: h } = a.call(this.getMatcherContext(t), m, ...this.sample);
          return this.inverse ? !h : h;
        }
        toString() {
          return `${this.inverse ? "not." : ""}${s}`;
        }
        getExpectedType() {
          return "any";
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((m) => Ye(m)).join(", ")}>`;
        }
      };
      o(p, "CustomMatcher");
      let c = p, d = /* @__PURE__ */ o((...f) => new c(false, ...f), "customMatcher");
      Object.defineProperty(t, s, {
        configurable: true,
        enumerable: true,
        value: d,
        writable: true
      }), Object.defineProperty(t.not, s, {
        configurable: true,
        enumerable: true,
        value: /* @__PURE__ */ o((...f) => new c(true, ...f), "value"),
        writable: true
      }), Object.defineProperty(globalThis[Vx], s, {
        configurable: true,
        enumerable: true,
        value: d,
        writable: true
      });
    });
  };
}
o(tie, "JestExtendPlugin");
var XN = /* @__PURE__ */ o((e, t) => {
  t.addMethod(e.expect, "extend", (r, n) => {
    Fr$1(tie(e, r, n));
  });
}, "JestExtend");
function rie() {
  Fr$1(XN), Fr$1(KN), Fr$1(WN);
  let e = /* @__PURE__ */ o((n, i) => {
    let { assertionCalls: s } = qs(e);
    return gp({ assertionCalls: s + 1, soft: false }, e), Lr$1(n, i);
  }, "expect");
  Object.assign(e, Lr$1), e.getState = () => qs(e), e.setState = (n) => gp(n, e), e.extend = (n) => Lr$1.extend(e, n), e.soft = (...n) => {
    let i = e(...n);
    return e.setState({
      soft: true
    }), i;
  }, e.extend($N), e.unreachable = (n) => {
    x$1.fail(`expected${n ? ` "${n}" ` : " "}not to be reached`);
  };
  function t(n) {
    let i = /* @__PURE__ */ o(() => new Error(
      `expected number of assertions to be ${n}, but got ${e.getState().assertionCalls}`
    ), "errorGen");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(i(), t), e.setState({
      expectedAssertionsNumber: n,
      expectedAssertionsNumberErrorGen: i
    });
  }
  o(t, "assertions");
  function r() {
    let n = new Error("expected any number of assertion, but got none");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(n, r), e.setState({
      isExpectingAssertions: true,
      isExpectingAssertionsError: n
    });
  }
  return o(r, "hasAssertions"), gp(
    {
      // this should also add "snapshotState" that is added conditionally
      assertionCalls: 0,
      isExpectingAssertions: false,
      isExpectingAssertionsError: null,
      expectedAssertionsNumber: null,
      expectedAssertionsNumberErrorGen: null
    },
    e
  ), _t.addMethod(e, "assertions", t), _t.addMethod(e, "hasAssertions", r), e.extend(Fx), e;
}
o(rie, "createExpect");
var sw = rie();
Object.defineProperty(globalThis, hp, {
  value: sw,
  writable: true,
  configurable: true
});
function nie(e, t, r) {
  Object.defineProperty(e, t, r);
}
o(nie, "f");
var vp = Symbol.for("tinyspy:spy");
var oie = /* @__PURE__ */ o((e) => {
  e.called = false, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, "P"), iie = /* @__PURE__ */ o((e) => (nie(e, vp, { value: { reset: /* @__PURE__ */ o(() => oie(e[vp]), "reset") } }), e[vp]), "K"), JN = /* @__PURE__ */ o(
  (e) => e[vp] || iie(e),
  "T"
);
var aw = /* @__PURE__ */ new Set();
function lw(e) {
  return aw.add(e), () => void aw.delete(e);
}
o(lw, "onMockCall");
var aie = /* @__PURE__ */ o((...e) => {
  let t = AN(...e);
  return ZN(t);
}, "spyOn");
function uw(e) {
  let t = e ? Bx(e) : Bx();
  return ZN(t);
}
o(uw, "fn");
function ZN(e) {
  let t = QN(e), r = t.mockImplementation.bind(null);
  return t.mockImplementation = (n) => QN(r(n)), t;
}
o(ZN, "reactiveMock");
function QN(e) {
  let t = JN(e), r = t.impl;
  return t.willCall(function(...n) {
    return aw.forEach((i) => i(e, n)), r?.apply(this, n);
  }), e;
}
o(QN, "listenWhenCalled");
function cw() {
  Go.forEach((e) => e.mockClear());
}
o(cw, "clearAllMocks");
function dw() {
  Go.forEach((e) => e.mockReset());
}
o(dw, "resetAllMocks");
function pw() {
  Go.forEach((e) => e.mockRestore());
}
o(pw, "restoreAllMocks");
function lie(e, t = {}) {
  return e;
}
o(lie, "mocked");
var cT = {};
st$1(cT, {
  buildQueries: () => vr$1,
  configure: () => Rye,
  createEvent: () => Oh,
  findAllByAltText: () => H$,
  findAllByDisplayValue: () => k$,
  findAllByLabelText: () => h$,
  findAllByPlaceholderText: () => R$,
  findAllByRole: () => tB,
  findAllByTestId: () => aB,
  findAllByText: () => O$,
  findAllByTitle: () => Y$,
  findByAltText: () => U$,
  findByDisplayValue: () => L$,
  findByLabelText: () => y$,
  findByPlaceholderText: () => S$,
  findByRole: () => rB,
  findByTestId: () => lB,
  findByText: () => q$,
  findByTitle: () => K$,
  fireEvent: () => ea,
  getAllByAltText: () => $$,
  getAllByDisplayValue: () => N$,
  getAllByLabelText: () => b$,
  getAllByPlaceholderText: () => w$,
  getAllByRole: () => Z$,
  getAllByTestId: () => iB,
  getAllByText: () => P$,
  getAllByTitle: () => G$,
  getByAltText: () => B$,
  getByDisplayValue: () => j$,
  getByLabelText: () => g$,
  getByPlaceholderText: () => T$,
  getByRole: () => eB,
  getByTestId: () => sB,
  getByText: () => A$,
  getByTitle: () => W$,
  getConfig: () => ie$1,
  getDefaultNormalizer: () => iT,
  getElementError: () => Nh,
  getMultipleElementsFoundError: () => jh,
  getNodeText: () => ra,
  getQueriesForElement: () => uB,
  getRoles: () => l$,
  getSuggestedQuery: () => qh,
  isInaccessible: () => Mh,
  logDOM: () => Ww,
  logRoles: () => Aye,
  makeFindQuery: () => ti,
  makeGetAllQuery: () => lT,
  makeSingleQuery: () => ei,
  prettyDOM: () => Qs,
  prettyFormat: () => ta,
  queries: () => Ih,
  queryAllByAltText: () => F$,
  queryAllByAttribute: () => Nn,
  queryAllByDisplayValue: () => I$,
  queryAllByLabelText: () => v$,
  queryAllByPlaceholderText: () => E$,
  queryAllByRole: () => J$,
  queryAllByTestId: () => nB,
  queryAllByText: () => _$,
  queryAllByTitle: () => V$,
  queryByAltText: () => D$,
  queryByAttribute: () => c$,
  queryByDisplayValue: () => M$,
  queryByLabelText: () => f$,
  queryByPlaceholderText: () => x$,
  queryByRole: () => Q$,
  queryByTestId: () => oB,
  queryByText: () => C$,
  queryByTitle: () => z$,
  queryHelpers: () => Uye,
  screen: () => bbe,
  waitFor: () => aT,
  waitForElementToBeRemoved: () => cbe,
  within: () => uB,
  wrapAllByQueryWithSuggestion: () => mt$1,
  wrapSingleQueryWithSuggestion: () => nn$1
});
var ta = Ne(dk());
var Use = Object.prototype.toString;
function pk(e) {
  return typeof e == "function" || Use.call(e) === "[object Function]";
}
o(pk, "isCallable");
function Vse(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
o(Vse, "toInteger");
var zse = Math.pow(2, 53) - 1;
function Gse(e) {
  var t = Vse(e);
  return Math.min(Math.max(t, 0), zse);
}
o(Gse, "toLength");
function xt$1(e, t) {
  var r = Array, n = Object(e);
  if (e == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof t < "u" && !pk(t))
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var i = Gse(n.length), s = pk(r) ? Object(new r(i)) : new Array(i), a = 0, l; a < i; )
    l = n[a], t ? s[a] = t(l, a) : s[a] = l, a += 1;
  return s.length = i, s;
}
o(xt$1, "arrayFrom");
function zs(e) {
  "@babel/helpers - typeof";
  return zs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zs(e);
}
o(zs, "_typeof");
function Wse(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
o(Wse, "_classCallCheck");
function fk(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, mk(n.key), n);
  }
}
o(fk, "_defineProperties");
function Yse(e, t, r) {
  return t && fk(e.prototype, t), r && fk(e, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
o(Yse, "_createClass");
function Kse(e, t, r) {
  return t = mk(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
}
o(Kse, "_defineProperty");
function mk(e) {
  var t = Xse(e, "string");
  return zs(t) === "symbol" ? t : String(t);
}
o(mk, "_toPropertyKey");
function Xse(e, t) {
  if (zs(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (zs(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
o(Xse, "_toPrimitive");
var Jse = /* @__PURE__ */ function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    Wse(this, e), Kse(this, "items", void 0), this.items = t;
  }
  return o(e, "SetLike"), Yse(e, [{
    key: "add",
    value: /* @__PURE__ */ o(function(r) {
      return this.has(r) === false && this.items.push(r), this;
    }, "add")
  }, {
    key: "clear",
    value: /* @__PURE__ */ o(function() {
      this.items = [];
    }, "clear")
  }, {
    key: "delete",
    value: /* @__PURE__ */ o(function(r) {
      var n = this.items.length;
      return this.items = this.items.filter(function(i) {
        return i !== r;
      }), n !== this.items.length;
    }, "_delete")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ o(function(r) {
      var n = this;
      this.items.forEach(function(i) {
        r(i, i, n);
      });
    }, "forEach")
  }, {
    key: "has",
    value: /* @__PURE__ */ o(function(r) {
      return this.items.indexOf(r) !== -1;
    }, "has")
  }, {
    key: "size",
    get: /* @__PURE__ */ o(function() {
      return this.items.length;
    }, "get")
  }]), e;
}(), hk = typeof Set > "u" ? Set : Jse;
function De(e) {
  var t;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (t = e.localName) !== null && t !== void 0 ? t : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      e.tagName.toLowerCase()
    )
  );
}
o(De, "getLocalName");
var Qse = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, Zse = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function eae(e, t) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(r) {
    var n;
    return e.hasAttribute(r) && !((n = Zse[t]) !== null && n !== void 0 && n.has(r));
  });
}
o(eae, "hasGlobalAriaAttributes");
function yk(e, t) {
  return eae(e, t);
}
o(yk, "ignorePresentationalRole");
function Op(e) {
  var t = rae(e);
  if (t === null || t === "presentation") {
    var r = tae(e);
    if (t !== "presentation" || yk(e, r || ""))
      return r;
  }
  return t;
}
o(Op, "getRole");
function tae(e) {
  var t = Qse[De(e)];
  if (t !== void 0)
    return t;
  switch (De(e)) {
    case "a":
    case "area":
    case "link":
      if (e.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return e.getAttribute("alt") === "" && !yk(e, "img") ? "presentation" : "img";
    case "input": {
      var r = e, n = r.type;
      switch (n) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return n;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return e.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return e.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
o(tae, "getImplicitRole");
function rae(e) {
  var t = e.getAttribute("role");
  if (t !== null) {
    var r = t.trim().split(" ")[0];
    if (r.length > 0)
      return r;
  }
  return null;
}
o(rae, "getExplicitRole");
function _e$1(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
o(_e$1, "isElement");
function Tw(e) {
  return _e$1(e) && De(e) === "caption";
}
o(Tw, "isHTMLTableCaptionElement");
function Gs(e) {
  return _e$1(e) && De(e) === "input";
}
o(Gs, "isHTMLInputElement");
function bk(e) {
  return _e$1(e) && De(e) === "optgroup";
}
o(bk, "isHTMLOptGroupElement");
function gk(e) {
  return _e$1(e) && De(e) === "select";
}
o(gk, "isHTMLSelectElement");
function vk(e) {
  return _e$1(e) && De(e) === "table";
}
o(vk, "isHTMLTableElement");
function Ek(e) {
  return _e$1(e) && De(e) === "textarea";
}
o(Ek, "isHTMLTextAreaElement");
function xk(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument, r = t.defaultView;
  if (r === null)
    throw new TypeError("no window available");
  return r;
}
o(xk, "safeWindow");
function wk(e) {
  return _e$1(e) && De(e) === "fieldset";
}
o(wk, "isHTMLFieldSetElement");
function Tk(e) {
  return _e$1(e) && De(e) === "legend";
}
o(Tk, "isHTMLLegendElement");
function Rk(e) {
  return _e$1(e) && De(e) === "slot";
}
o(Rk, "isHTMLSlotElement");
function nae(e) {
  return _e$1(e) && e.ownerSVGElement !== void 0;
}
o(nae, "isSVGElement");
function Sk(e) {
  return _e$1(e) && De(e) === "svg";
}
o(Sk, "isSVGSVGElement");
function _k(e) {
  return nae(e) && De(e) === "title";
}
o(_k, "isSVGTitleElement");
function Xo(e, t) {
  if (_e$1(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(" "), n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r.map(function(i) {
      return n.getElementById(i);
    }).filter(
      function(i) {
        return i !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
o(Xo, "queryIdRefs");
function Gt(e, t) {
  return _e$1(e) ? t.indexOf(Op(e)) !== -1 : false;
}
o(Gt, "hasAnyConcreteRoles");
function oae(e) {
  return e.trim().replace(/\s\s+/g, " ");
}
o(oae, "asFlatString");
function iae(e, t) {
  if (!_e$1(e))
    return false;
  if (e.hasAttribute("hidden") || e.getAttribute("aria-hidden") === "true")
    return true;
  var r = t(e);
  return r.getPropertyValue("display") === "none" || r.getPropertyValue("visibility") === "hidden";
}
o(iae, "isHidden");
function sae(e) {
  return Gt(e, ["button", "combobox", "listbox", "textbox"]) || Ak(e, "range");
}
o(sae, "isControl");
function Ak(e, t) {
  if (!_e$1(e))
    return false;
  switch (t) {
    case "range":
      return Gt(e, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(t, "'. This is likely a bug :("));
  }
}
o(Ak, "hasAbstractRole");
function Ck(e, t) {
  var r = xt$1(e.querySelectorAll(t));
  return Xo(e, "aria-owns").forEach(function(n) {
    r.push.apply(r, xt$1(n.querySelectorAll(t)));
  }), r;
}
o(Ck, "querySelectorAllSubtree");
function aae(e) {
  return gk(e) ? e.selectedOptions || Ck(e, "[selected]") : Ck(e, '[aria-selected="true"]');
}
o(aae, "querySelectedOptions");
function lae(e) {
  return Gt(e, ["none", "presentation"]);
}
o(lae, "isMarkedPresentational");
function uae(e) {
  return Tw(e);
}
o(uae, "isNativeHostLanguageTextAlternativeElement");
function cae(e) {
  return Gt(e, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
o(cae, "allowsNameFromContent");
function dae(e) {
  return false;
}
o(dae, "isDescendantOfNativeHostLanguageTextAlternativeElement");
function pae(e) {
  return Gs(e) || Ek(e) ? e.value : e.textContent || "";
}
o(pae, "getValueOfTextbox");
function Pk(e) {
  var t = e.getPropertyValue("content");
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : "";
}
o(Pk, "getTextualContent");
function Ok(e) {
  var t = De(e);
  return t === "button" || t === "input" && e.getAttribute("type") !== "hidden" || t === "meter" || t === "output" || t === "progress" || t === "select" || t === "textarea";
}
o(Ok, "isLabelableElement");
function qk(e) {
  if (Ok(e))
    return e;
  var t = null;
  return e.childNodes.forEach(function(r) {
    if (t === null && _e$1(r)) {
      var n = qk(r);
      n !== null && (t = n);
    }
  }), t;
}
o(qk, "findLabelableElement");
function fae(e) {
  if (e.control !== void 0)
    return e.control;
  var t = e.getAttribute("for");
  return t !== null ? e.ownerDocument.getElementById(t) : qk(e);
}
o(fae, "getControlOfLabel");
function mae(e) {
  var t = e.labels;
  if (t === null)
    return t;
  if (t !== void 0)
    return xt$1(t);
  if (!Ok(e))
    return null;
  var r = e.ownerDocument;
  return xt$1(r.querySelectorAll("label")).filter(function(n) {
    return fae(n) === e;
  });
}
o(mae, "getLabels");
function hae(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? xt$1(e.childNodes) : t;
}
o(hae, "getSlotContents");
function qp(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = new hk(), n = xk(e), i = t.compute, s = i === void 0 ? "name" : i, a = t.computedStyleSupportsPseudoElements, l = a === void 0 ? t.getComputedStyle !== void 0 : a, u = t.getComputedStyle, c = u === void 0 ? n.getComputedStyle.bind(n) : u, d = t.hidden, p = d === void 0 ? false : d;
  function f(g, w) {
    var E = "";
    if (_e$1(g) && l) {
      var R = c(g, "::before"), S = Pk(R);
      E = "".concat(S, " ").concat(E);
    }
    var P = Rk(g) ? hae(g) : xt$1(g.childNodes).concat(Xo(g, "aria-owns"));
    if (P.forEach(function(O) {
      var L = v(O, {
        isEmbeddedInLabel: w.isEmbeddedInLabel,
        isReferenced: false,
        recursion: true
      }), q = _e$1(O) ? c(O).getPropertyValue("display") : "inline", D = q !== "inline" ? " " : "";
      E += "".concat(D).concat(L).concat(D);
    }), _e$1(g) && l) {
      var _ = c(g, "::after"), C = Pk(_);
      E = "".concat(E, " ").concat(C);
    }
    return E.trim();
  }
  o(f, "computeMiscTextAlternative");
  function m(g, w) {
    var E = g.getAttributeNode(w);
    return E !== null && !r.has(E) && E.value.trim() !== "" ? (r.add(E), E.value) : null;
  }
  o(m, "useAttribute");
  function h(g) {
    return _e$1(g) ? m(g, "title") : null;
  }
  o(h, "computeTooltipAttributeValue");
  function b(g) {
    if (!_e$1(g))
      return null;
    if (wk(g)) {
      r.add(g);
      for (var w = xt$1(g.childNodes), E = 0; E < w.length; E += 1) {
        var R = w[E];
        if (Tk(R))
          return v(R, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
      }
    } else if (vk(g)) {
      r.add(g);
      for (var S = xt$1(g.childNodes), P = 0; P < S.length; P += 1) {
        var _ = S[P];
        if (Tw(_))
          return v(_, {
            isEmbeddedInLabel: false,
            isReferenced: false,
            recursion: false
          });
      }
    } else if (Sk(g)) {
      r.add(g);
      for (var C = xt$1(g.childNodes), O = 0; O < C.length; O += 1) {
        var L = C[O];
        if (_k(L))
          return L.textContent;
      }
      return null;
    } else if (De(g) === "img" || De(g) === "area") {
      var q = m(g, "alt");
      if (q !== null)
        return q;
    } else if (bk(g)) {
      var D = m(g, "label");
      if (D !== null)
        return D;
    }
    if (Gs(g) && (g.type === "button" || g.type === "submit" || g.type === "reset")) {
      var H = m(g, "value");
      if (H !== null)
        return H;
      if (g.type === "submit")
        return "Submit";
      if (g.type === "reset")
        return "Reset";
    }
    var M = mae(g);
    if (M !== null && M.length !== 0)
      return r.add(g), xt$1(M).map(function(Y) {
        return v(Y, {
          isEmbeddedInLabel: true,
          isReferenced: false,
          recursion: true
        });
      }).filter(function(Y) {
        return Y.length > 0;
      }).join(" ");
    if (Gs(g) && g.type === "image") {
      var U = m(g, "alt");
      if (U !== null)
        return U;
      var N = m(g, "title");
      return N !== null ? N : "Submit Query";
    }
    if (Gt(g, ["button"])) {
      var W = f(g, {
        isEmbeddedInLabel: false,
        isReferenced: false
      });
      if (W !== "")
        return W;
    }
    return null;
  }
  o(b, "computeElementTextAlternative");
  function v(g, w) {
    if (r.has(g))
      return "";
    if (!p && iae(g, c) && !w.isReferenced)
      return r.add(g), "";
    var E = _e$1(g) ? g.getAttributeNode("aria-labelledby") : null, R = E !== null && !r.has(E) ? Xo(g, "aria-labelledby") : [];
    if (s === "name" && !w.isReferenced && R.length > 0)
      return r.add(E), R.map(function(q) {
        return v(q, {
          isEmbeddedInLabel: w.isEmbeddedInLabel,
          isReferenced: true,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: false
        });
      }).join(" ");
    var S = w.recursion && sae(g) && s === "name";
    if (!S) {
      var P = (_e$1(g) && g.getAttribute("aria-label") || "").trim();
      if (P !== "" && s === "name")
        return r.add(g), P;
      if (!lae(g)) {
        var _ = b(g);
        if (_ !== null)
          return r.add(g), _;
      }
    }
    if (Gt(g, ["menu"]))
      return r.add(g), "";
    if (S || w.isEmbeddedInLabel || w.isReferenced) {
      if (Gt(g, ["combobox", "listbox"])) {
        r.add(g);
        var C = aae(g);
        return C.length === 0 ? Gs(g) ? g.value : "" : xt$1(C).map(function(q) {
          return v(q, {
            isEmbeddedInLabel: w.isEmbeddedInLabel,
            isReferenced: false,
            recursion: true
          });
        }).join(" ");
      }
      if (Ak(g, "range"))
        return r.add(g), g.hasAttribute("aria-valuetext") ? g.getAttribute("aria-valuetext") : g.hasAttribute("aria-valuenow") ? g.getAttribute(
          "aria-valuenow"
        ) : g.getAttribute("value") || "";
      if (Gt(g, ["textbox"]))
        return r.add(g), pae(g);
    }
    if (cae(g) || _e$1(g) && w.isReferenced || uae(g) || dae()) {
      var O = f(g, {
        isEmbeddedInLabel: w.isEmbeddedInLabel,
        isReferenced: false
      });
      if (O !== "")
        return r.add(g), O;
    }
    if (g.nodeType === g.TEXT_NODE)
      return r.add(g), g.textContent || "";
    if (w.recursion)
      return r.add(g), f(g, {
        isEmbeddedInLabel: w.isEmbeddedInLabel,
        isReferenced: false
      });
    var L = h(g);
    return L !== null ? (r.add(g), L) : (r.add(g), "");
  }
  return o(v, "computeTextAlternative"), oae(v(e, {
    isEmbeddedInLabel: false,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: s === "description",
    recursion: false
  }));
}
o(qp, "computeTextAlternative");
function Ws(e) {
  "@babel/helpers - typeof";
  return Ws = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ws(e);
}
o(Ws, "_typeof");
function Ik(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
o(Ik, "ownKeys");
function Mk(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ik(Object(r), true).forEach(function(n) {
      yae(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ik(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
o(Mk, "_objectSpread");
function yae(e, t, r) {
  return t = bae(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
}
o(yae, "_defineProperty");
function bae(e) {
  var t = gae(e, "string");
  return Ws(t) === "symbol" ? t : String(t);
}
o(bae, "_toPropertyKey");
function gae(e, t) {
  if (Ws(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (Ws(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
o(gae, "_toPrimitive");
function Ip(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = Xo(e, "aria-describedby").map(function(i) {
    return qp(i, Mk(Mk({}, t), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (r === "") {
    var n = e.getAttribute("title");
    r = n === null ? "" : n;
  }
  return r;
}
o(Ip, "computeAccessibleDescription");
function vae(e) {
  return Gt(e, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
o(vae, "prohibitsNaming");
function Ys(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return vae(e) ? "" : qp(e, t);
}
o(Ys, "computeAccessibleName");
var lt$1 = Ne(FD()), GD = Ne(DD());
function WD(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
o(WD, "escapeHTML");
var oye = /* @__PURE__ */ o((e, t, r, n, i, s, a) => {
  let l = n + r.indent, u = r.colors;
  return e.map((c) => {
    let d = t[c], p = a(d, r, l, i, s);
    return typeof d != "string" && (p.indexOf(`
`) !== -1 && (p = r.spacingOuter + l + p + r.spacingOuter + n), p = "{" + p + "}"), r.spacingInner + n + u.prop.open + c + u.prop.close + "=" + u.value.open + p + u.value.close;
  }).join("");
}, "printProps"), iye = 3, sye = /* @__PURE__ */ o((e, t, r, n, i, s) => e.map((a) => {
  let l = typeof a == "string" ? YD(a, t) : s(a, t, r, n, i);
  return l === "" && typeof a == "object" && a !== null && a.nodeType !== iye ? "" : t.spacingOuter + r + l;
}).join(""), "printChildren"), YD = /* @__PURE__ */ o((e, t) => {
  let r = t.colors.content;
  return r.open + WD(e) + r.close;
}, "printText"), aye = /* @__PURE__ */ o((e, t) => {
  let r = t.colors.comment;
  return r.open + "<!--" + WD(e) + "-->" + r.close;
}, "printComment"), lye = /* @__PURE__ */ o((e, t, r, n, i) => {
  let s = n.colors.tag;
  return s.open + "<" + e + (t && s.close + t + n.spacingOuter + i + s.open) + (r ? ">" + s.close + r + n.spacingOuter + i + s.open + "</" + e : (t && !n.min ? "" : " ") + "/") + ">" + s.close;
}, "printElement"), uye = /* @__PURE__ */ o((e, t) => {
  let r = t.colors.tag;
  return r.open + "<" + e + r.close + " " + r.open + " />" + r.close;
}, "printElementAsLeaf"), cye = 1, KD = 3, XD = 8, JD = 11, dye = /^((HTML|SVG)\w*)?Element$/, QD = /* @__PURE__ */ o((e) => {
  let {
    tagName: t
  } = e;
  return !!(typeof t == "string" && t.includes("-") || typeof e.hasAttribute == "function" && e.hasAttribute("is"));
}, "isCustomElement"), pye = /* @__PURE__ */ o((e) => {
  let t = e.constructor.name, {
    nodeType: r
  } = e;
  return r === cye && (dye.test(t) || QD(e)) || r === KD && t === "Text" || r === XD && t === "Comment" || r === JD && t === "DocumentFragment";
}, "testNode");
function fye(e) {
  return e.nodeType === KD;
}
o(fye, "nodeIsText");
function mye(e) {
  return e.nodeType === XD;
}
o(mye, "nodeIsComment");
function zw(e) {
  return e.nodeType === JD;
}
o(zw, "nodeIsFragment");
function hye(e) {
  return {
    test: /* @__PURE__ */ o((t) => {
      var r;
      return ((t == null || (r = t.constructor) == null ? void 0 : r.name) || QD(t)) && pye(t);
    }, "test"),
    serialize: /* @__PURE__ */ o((t, r, n, i, s, a) => {
      if (fye(t))
        return YD(t.data, r);
      if (mye(t))
        return aye(t.data, r);
      let l = zw(t) ? "DocumentFragment" : t.tagName.toLowerCase();
      return ++i > r.maxDepth ? uye(l, r) : lye(l, oye(zw(t) ? [] : Array.from(t.attributes).map((u) => u.name).sort(), zw(t) ? {} : Array.from(
        t.attributes
      ).reduce((u, c) => (u[c.name] = c.value, u), {}), r, n + r.indent, i, s, a), sye(Array.prototype.slice.call(t.childNodes || t.children).filter(e), r, n + r.indent, i, s, a), r, n);
    }, "serialize")
  };
}
o(hye, "createDOMElementFilter");
var ZD = null, rT = null, nT = null;
try {
  let e = module && module.require;
  rT = e.call(module, "fs").readFileSync, nT = e.call(module, "@babel/code-frame").codeFrameColumns, ZD = e.call(module, "chalk");
} catch {
}
function yye(e) {
  let t = e.indexOf("(") + 1, r = e.indexOf(")"), n = e.slice(t, r), i = n.split(":"), [s, a, l] = [i[0], parseInt(i[1], 10), parseInt(
    i[2],
    10
  )], u = "";
  try {
    u = rT(s, "utf-8");
  } catch {
    return "";
  }
  let c = nT(u, {
    start: {
      line: a,
      column: l
    }
  }, {
    highlightCode: true,
    linesBelow: 0
  });
  return ZD.dim(n) + `
` + c + `
`;
}
o(yye, "getCodeFrame");
function bye() {
  if (!rT || !nT)
    return "";
  let t = new Error().stack.split(`
`).slice(1).find((r) => !r.includes("node_modules/"));
  return yye(t);
}
o(bye, "getUserCodeFrame");
var e$ = 3;
function Gw() {
  return typeof jest < "u" && jest !== null ? (
    // legacy timers
    setTimeout._isMockFunction === true || // modern timers
    // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
    Object.prototype.hasOwnProperty.call(setTimeout, "clock")
  ) : false;
}
o(Gw, "jestFakeTimersAreEnabled");
function oT() {
  if (typeof window > "u")
    throw new Error("Could not find default container");
  return window.document;
}
o(oT, "getDocument");
function t$(e) {
  if (e.defaultView)
    return e.defaultView;
  if (e.ownerDocument && e.ownerDocument.defaultView)
    return e.ownerDocument.defaultView;
  if (e.window)
    return e.window;
  throw e.ownerDocument && e.ownerDocument.defaultView === null ? new Error("It looks like the window object is not available for the provided node.") : e.then instanceof Function ? new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?") : Array.isArray(e) ? new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?") : typeof e.debug == "function" && typeof e.logTestingPlaygroundURL == "function" ? new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?") : new Error("The given node is not an Element, the node type is: " + typeof e + ".");
}
o(t$, "getWindowFromNode");
function gr$1(e) {
  if (!e || typeof e.querySelector != "function" || typeof e.querySelectorAll != "function")
    throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + t(e) + ".");
  function t(r) {
    return typeof r == "object" ? r === null ? "null" : r.constructor.name : typeof r;
  }
  o(t, "getTypeName");
}
o(gr$1, "checkContainerType");
var gye = /* @__PURE__ */ o(() => {
  if (typeof process > "u")
    return false;
  let e;
  try {
    var t;
    let r = (t = define_process_env_default) == null ? void 0 : t.COLORS;
    r && (e = JSON.parse(r));
  } catch {
  }
  return typeof e == "boolean" ? e : process.versions !== void 0 && process.versions.node !== void 0;
}, "shouldHighlight"), {
  DOMCollection: vye
} = ta.plugins, Eye = 1, xye = 8;
function wye(e) {
  return e.nodeType !== xye && (e.nodeType !== Eye || !e.matches(ie$1().defaultIgnore));
}
o(wye, "filterCommentsAndDefaultIgnoreTagsTags");
function Qs(e, t, r) {
  if (r === void 0 && (r = {}), e || (e = oT().body), typeof t != "number" && (t = typeof process < "u" && typeof define_process_env_default < "u" && define_process_env_default.DEBUG_PRINT_LIMIT || 7e3), t === 0)
    return "";
  e.documentElement && (e = e.documentElement);
  let n = typeof e;
  if (n === "object" ? n = e.constructor.name : e = {}, !("outerHTML" in e))
    throw new TypeError("Expected an element or document but got " + n);
  let {
    filterNode: i = wye,
    ...s
  } = r, a = ta.format(e, {
    plugins: [hye(i), vye],
    printFunctionName: false,
    highlight: gye(),
    ...s
  });
  return t !== void 0 && e.outerHTML.length > t ? a.slice(0, t) + "..." : a;
}
o(Qs, "prettyDOM");
var Ww = /* @__PURE__ */ o(function() {
  let e = bye();
  console.log(e ? Qs(...arguments) + `

` + e : Qs(...arguments));
}, "logDOM"), qn = {
  testIdAttribute: "data-testid",
  asyncUtilTimeout: 1e3,
  // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
  // forcing react-testing-library to wrap all async functions would've been
  // a total nightmare (consider wrapping every findBy* query and then also
  // updating `within` so those would be wrapped too. Total nightmare).
  // so we have this config option that's really only intended for
  // react-testing-library to use. For that reason, this feature will remain
  // undocumented.
  asyncWrapper: /* @__PURE__ */ o((e) => e(), "asyncWrapper"),
  unstable_advanceTimersWrapper: /* @__PURE__ */ o((e) => e(), "unstable_advanceTimersWrapper"),
  eventWrapper: /* @__PURE__ */ o((e) => e(), "eventWrapper"),
  // default value for the `hidden` option in `ByRole` queries
  defaultHidden: false,
  // default value for the `ignore` option in `ByText` queries
  defaultIgnore: "script, style",
  // showOriginalStackTrace flag to show the full error stack traces for async errors
  showOriginalStackTrace: false,
  // throw errors w/ suggestions for better queries. Opt in so off by default.
  throwSuggestions: false,
  // called when getBy* queries fail. (message, container) => Error
  getElementError(e, t) {
    let r = Qs(t), n = new Error([e, "Ignored nodes: comments, " + qn.defaultIgnore + `
` + r].filter(Boolean).join(`

`));
    return n.name = "TestingLibraryElementError", n;
  },
  _disableExpensiveErrorDiagnostics: false,
  computedStyleSupportsPseudoElements: false
};
function Tye(e) {
  try {
    return qn._disableExpensiveErrorDiagnostics = true, e();
  } finally {
    qn._disableExpensiveErrorDiagnostics = false;
  }
}
o(Tye, "runWithExpensiveErrorDiagnosticsDisabled");
function Rye(e) {
  typeof e == "function" && (e = e(qn)), qn = {
    ...qn,
    ...e
  };
}
o(Rye, "configure");
function ie$1() {
  return qn;
}
o(ie$1, "getConfig");
var Sye = ["button", "meter", "output", "progress", "select", "textarea", "input"];
function r$(e) {
  return Sye.includes(e.nodeName.toLowerCase()) ? "" : e.nodeType === e$ ? e.textContent : Array.from(e.childNodes).map((t) => r$(t)).join("");
}
o(r$, "getTextContent");
function Yw(e) {
  let t;
  return e.tagName.toLowerCase() === "label" ? t = r$(e) : t = e.value || e.textContent, t;
}
o(Yw, "getLabelContent");
function n$(e) {
  if (e.labels !== void 0) {
    var t;
    return (t = e.labels) != null ? t : [];
  }
  if (!_ye(e)) return [];
  let r = e.ownerDocument.querySelectorAll("label");
  return Array.from(r).filter((n) => n.control === e);
}
o(n$, "getRealLabels");
function _ye(e) {
  return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(e.tagName) || e.tagName === "INPUT" && e.getAttribute("type") !== "hidden";
}
o(_ye, "isLabelable");
function o$(e, t, r) {
  let {
    selector: n = "*"
  } = r === void 0 ? {} : r, i = t.getAttribute("aria-labelledby"), s = i ? i.split(" ") : [];
  return s.length ? s.map((a) => {
    let l = e.querySelector('[id="' + a + '"]');
    return l ? {
      content: Yw(l),
      formControl: null
    } : {
      content: "",
      formControl: null
    };
  }) : Array.from(n$(t)).map((a) => {
    let l = Yw(a), c = Array.from(a.querySelectorAll("button, input, meter, output, progress, select, textarea")).filter((d) => d.matches(n))[0];
    return {
      content: l,
      formControl: c
    };
  });
}
o(o$, "getLabels");
function i$(e) {
  if (e == null)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
      "It looks like " + e + " was passed instead of a matcher. Did you do something like getByText(" + e + ")?"
    );
}
o(i$, "assertNotNullOrUndefined");
function ri(e, t, r, n) {
  if (typeof e != "string")
    return false;
  i$(r);
  let i = n(e);
  return typeof r == "string" || typeof r == "number" ? i.toLowerCase().includes(r.toString().toLowerCase()) : typeof r == "function" ? r(
    i,
    t
  ) : s$(r, i);
}
o(ri, "fuzzyMatches");
function br$1(e, t, r, n) {
  if (typeof e != "string")
    return false;
  i$(r);
  let i = n(e);
  return r instanceof Function ? r(i, t) : r instanceof RegExp ? s$(r, i) : i === String(r);
}
o(br$1, "matches");
function iT(e) {
  let {
    trim: t = true,
    collapseWhitespace: r = true
  } = e === void 0 ? {} : e;
  return (n) => {
    let i = n;
    return i = t ? i.trim() : i, i = r ? i.replace(/\s+/g, " ") : i, i;
  };
}
o(iT, "getDefaultNormalizer");
function Mn(e) {
  let {
    trim: t,
    collapseWhitespace: r,
    normalizer: n
  } = e;
  if (!n)
    return iT({
      trim: t,
      collapseWhitespace: r
    });
  if (typeof t < "u" || typeof r < "u")
    throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
  return n;
}
o(Mn, "makeNormalizer");
function s$(e, t) {
  let r = e.test(t);
  return e.global && e.lastIndex !== 0 && (console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp."), e.lastIndex = 0), r;
}
o(s$, "matchRegExp");
function ra(e) {
  return e.matches("input[type=submit], input[type=button], input[type=reset]") ? e.value : Array.from(e.childNodes).filter((t) => t.nodeType === e$ && !!t.textContent).map((t) => t.textContent).join("");
}
o(ra, "getNodeText");
var Cye = Pye(lt$1.elementRoles);
function a$(e) {
  return e.hidden === true || e.getAttribute("aria-hidden") === "true" || e.ownerDocument.defaultView.getComputedStyle(e).display === "none";
}
o(a$, "isSubtreeInaccessible");
function Mh(e, t) {
  t === void 0 && (t = {});
  let {
    isSubtreeInaccessible: r = a$
  } = t;
  if (e.ownerDocument.defaultView.getComputedStyle(e).visibility === "hidden")
    return true;
  let i = e;
  for (; i; ) {
    if (r(i))
      return true;
    i = i.parentElement;
  }
  return false;
}
o(Mh, "isInaccessible");
function sT(e) {
  for (let {
    match: t,
    roles: r
  } of Cye)
    if (t(e))
      return [...r];
  return [];
}
o(sT, "getImplicitAriaRoles");
function Pye(e) {
  function t(a) {
    let {
      name: l,
      attributes: u
    } = a;
    return "" + l + u.map((c) => {
      let {
        name: d,
        value: p,
        constraints: f = []
      } = c, m = f.indexOf("undefined") !== -1, h = f.indexOf("set") !== -1;
      return typeof p < "u" ? "[" + d + '="' + p + '"]' : m ? ":not([" + d + "])" : h ? "[" + d + "]:not([" + d + '=""])' : "[" + d + "]";
    }).join("");
  }
  o(t, "makeElementSelector");
  function r(a) {
    let {
      attributes: l = []
    } = a;
    return l.length;
  }
  o(r, "getSelectorSpecificity");
  function n(a, l) {
    let {
      specificity: u
    } = a, {
      specificity: c
    } = l;
    return c - u;
  }
  o(n, "bySelectorSpecificity");
  function i(a) {
    let {
      attributes: l = []
    } = a, u = l.findIndex((d) => d.value && d.name === "type" && d.value === "text");
    u >= 0 && (l = [...l.slice(0, u), ...l.slice(u + 1)]);
    let c = t({
      ...a,
      attributes: l
    });
    return (d) => u >= 0 && d.type !== "text" ? false : d.matches(c);
  }
  o(i, "match");
  let s = [];
  for (let [a, l] of e.entries())
    s = [...s, {
      match: i(a),
      roles: Array.from(l),
      specificity: r(a)
    }];
  return s.sort(n);
}
o(Pye, "buildElementRoleList");
function l$(e, t) {
  let {
    hidden: r = false
  } = t === void 0 ? {} : t;
  function n(i) {
    return [i, ...Array.from(i.children).reduce((s, a) => [...s, ...n(a)], [])];
  }
  return o(n, "flattenDOM"), n(e).filter((i) => r === false ? Mh(i) === false : true).reduce((i, s) => {
    let a = [];
    return s.hasAttribute("role") ? a = s.getAttribute("role").split(" ").slice(0, 1) : a = sT(s), a.reduce((l, u) => Array.isArray(l[u]) ? {
      ...l,
      [u]: [...l[u], s]
    } : {
      ...l,
      [u]: [s]
    }, i);
  }, {});
}
o(l$, "getRoles");
function u$(e, t) {
  let {
    hidden: r,
    includeDescription: n
  } = t, i = l$(e, {
    hidden: r
  });
  return Object.entries(i).filter((s) => {
    let [a] = s;
    return a !== "generic";
  }).map((s) => {
    let [a, l] = s, u = "-".repeat(50), c = l.map((d) => {
      let p = 'Name "' + Ys(d, {
        computedStyleSupportsPseudoElements: ie$1().computedStyleSupportsPseudoElements
      }) + `":
`, f = Qs(d.cloneNode(false));
      if (n) {
        let m = 'Description "' + Ip(d, {
          computedStyleSupportsPseudoElements: ie$1().computedStyleSupportsPseudoElements
        }) + `":
`;
        return "" + p + m + f;
      }
      return "" + p + f;
    }).join(`

`);
    return a + `:

` + c + `

` + u;
  }).join(`
`);
}
o(u$, "prettyRoles");
var Aye = /* @__PURE__ */ o(function(e, t) {
  let {
    hidden: r = false
  } = t === void 0 ? {} : t;
  return console.log(u$(e, {
    hidden: r
  }));
}, "logRoles");
function Oye(e) {
  return e.tagName === "OPTION" ? e.selected : na(e, "aria-selected");
}
o(Oye, "computeAriaSelected");
function qye(e) {
  return e.getAttribute("aria-busy") === "true";
}
o(qye, "computeAriaBusy");
function Iye(e) {
  if (!("indeterminate" in e && e.indeterminate))
    return "checked" in e ? e.checked : na(e, "aria-checked");
}
o(Iye, "computeAriaChecked");
function Mye(e) {
  return na(e, "aria-pressed");
}
o(Mye, "computeAriaPressed");
function Nye(e) {
  var t, r;
  return (t = (r = na(e, "aria-current")) != null ? r : e.getAttribute("aria-current")) != null ? t : false;
}
o(Nye, "computeAriaCurrent");
function jye(e) {
  return na(e, "aria-expanded");
}
o(jye, "computeAriaExpanded");
function na(e, t) {
  let r = e.getAttribute(t);
  if (r === "true")
    return true;
  if (r === "false")
    return false;
}
o(na, "checkBooleanAttribute");
function kye(e) {
  let t = {
    H1: 1,
    H2: 2,
    H3: 3,
    H4: 4,
    H5: 5,
    H6: 6
  };
  return e.getAttribute("aria-level") && Number(e.getAttribute("aria-level")) || t[e.tagName];
}
o(kye, "computeHeadingLevel");
function Lye(e) {
  let t = e.getAttribute("aria-valuenow");
  return t === null ? void 0 : +t;
}
o(Lye, "computeAriaValueNow");
function Fye(e) {
  let t = e.getAttribute("aria-valuemax");
  return t === null ? void 0 : +t;
}
o(Fye, "computeAriaValueMax");
function Dye(e) {
  let t = e.getAttribute("aria-valuemin");
  return t === null ? void 0 : +t;
}
o(Dye, "computeAriaValueMin");
function $ye(e) {
  let t = e.getAttribute("aria-valuetext");
  return t === null ? void 0 : t;
}
o($ye, "computeAriaValueText");
var $D = iT();
function Bye(e) {
  return e.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
o(Bye, "escapeRegExp");
function BD(e) {
  return new RegExp(Bye(e.toLowerCase()), "i");
}
o(BD, "getRegExpMatcher");
function tn$1(e, t, r, n) {
  let {
    variant: i,
    name: s
  } = n, a = "", l = {}, u = [["Role", "TestId"].includes(e) ? r : BD(r)];
  s && (l.name = BD(s)), e === "Role" && Mh(t) && (l.hidden = true, a = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `), Object.keys(l).length > 0 && u.push(l);
  let c = i + "By" + e;
  return {
    queryName: e,
    queryMethod: c,
    queryArgs: u,
    variant: i,
    warning: a,
    toString() {
      a && console.warn(a);
      let [d, p] = u;
      return d = typeof d == "string" ? "'" + d + "'" : d, p = p ? ", { " + Object.entries(p).map((f) => {
        let [m, h] = f;
        return m + ": " + h;
      }).join(", ") + " }" : "", c + "(" + d + p + ")";
    }
  };
}
o(tn$1, "makeSuggestion");
function rn$1(e, t, r) {
  return r && (!t || t.toLowerCase() === e.toLowerCase());
}
o(rn$1, "canSuggest");
function qh(e, t, r) {
  var n, i;
  if (t === void 0 && (t = "get"), e.matches(ie$1().defaultIgnore))
    return;
  let s = (n = e.getAttribute("role")) != null ? n : (i = sT(e)) == null ? void 0 : i[0];
  if (s !== "generic" && rn$1("Role", r, s))
    return tn$1("Role", e, s, {
      variant: t,
      name: Ys(e, {
        computedStyleSupportsPseudoElements: ie$1().computedStyleSupportsPseudoElements
      })
    });
  let a = o$(document, e).map((f) => f.content).join(" ");
  if (rn$1("LabelText", r, a))
    return tn$1("LabelText", e, a, {
      variant: t
    });
  let l = e.getAttribute("placeholder");
  if (rn$1("PlaceholderText", r, l))
    return tn$1("PlaceholderText", e, l, {
      variant: t
    });
  let u = $D(ra(e));
  if (rn$1("Text", r, u))
    return tn$1("Text", e, u, {
      variant: t
    });
  if (rn$1("DisplayValue", r, e.value))
    return tn$1("DisplayValue", e, $D(e.value), {
      variant: t
    });
  let c = e.getAttribute("alt");
  if (rn$1("AltText", r, c))
    return tn$1("AltText", e, c, {
      variant: t
    });
  let d = e.getAttribute("title");
  if (rn$1("Title", r, d))
    return tn$1("Title", e, d, {
      variant: t
    });
  let p = e.getAttribute(ie$1().testIdAttribute);
  if (rn$1("TestId", r, p))
    return tn$1("TestId", e, p, {
      variant: t
    });
}
o(qh, "getSuggestedQuery");
function Ah(e, t) {
  e.stack = t.stack.replace(t.message, e.message);
}
o(Ah, "copyStackTrace");
function Hye(e, t) {
  let {
    container: r = oT(),
    timeout: n = ie$1().asyncUtilTimeout,
    showOriginalStackTrace: i = ie$1().showOriginalStackTrace,
    stackTraceError: s,
    interval: a = 50,
    onTimeout: l = /* @__PURE__ */ o((c) => (Object.defineProperty(c, "message", {
      value: ie$1().getElementError(c.message, r).message
    }), c), "onTimeout"),
    mutationObserverOptions: u = {
      subtree: true,
      childList: true,
      attributes: true,
      characterData: true
    }
  } = t;
  if (typeof e != "function")
    throw new TypeError("Received `callback` arg must be a function");
  return new Promise(async (c, d) => {
    let p, f, m, h = false, b = "idle", v = setTimeout(S, n), g = Gw();
    if (g) {
      let {
        unstable_advanceTimersWrapper: P
      } = ie$1();
      for (R(); !h; ) {
        if (!Gw()) {
          let _ = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
          i || Ah(_, s), d(_);
          return;
        }
        if (await P(async () => {
          jest.advanceTimersByTime(a);
        }), h)
          break;
        R();
      }
    } else {
      try {
        gr$1(r);
      } catch (_) {
        d(_);
        return;
      }
      f = setInterval(E, a);
      let {
        MutationObserver: P
      } = t$(r);
      m = new P(E), m.observe(r, u), R();
    }
    function w(P, _) {
      h = true, clearTimeout(v), g || (clearInterval(f), m.disconnect()), P ? d(P) : c(_);
    }
    o(w, "onDone");
    function E() {
      if (Gw()) {
        let P = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
        return i || Ah(P, s), d(P);
      } else
        return R();
    }
    o(E, "checkRealTimersCallback");
    function R() {
      if (b !== "pending")
        try {
          let P = Tye(e);
          typeof P?.then == "function" ? (b = "pending", P.then((_) => {
            b = "resolved", w(null, _);
          }, (_) => {
            b = "rejected", p = _;
          })) : w(null, P);
        } catch (P) {
          p = P;
        }
    }
    o(R, "checkCallback");
    function S() {
      let P;
      p ? (P = p, !i && P.name === "TestingLibraryElementError" && Ah(P, s)) : (P = new Error("Timed out in waitFor."), i || Ah(P, s)), w(l(
        P
      ), null);
    }
    o(S, "handleTimeout");
  });
}
o(Hye, "waitFor");
function aT(e, t) {
  let r = new Error("STACK_TRACE_MESSAGE");
  return ie$1().asyncWrapper(() => Hye(e, {
    stackTraceError: r,
    ...t
  }));
}
o(aT, "waitForWrapper");
function Nh(e, t) {
  return ie$1().getElementError(e, t);
}
o(Nh, "getElementError");
function jh(e, t) {
  return Nh(e + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", t);
}
o(jh, "getMultipleElementsFoundError");
function Nn(e, t, r, n) {
  let {
    exact: i = true,
    collapseWhitespace: s,
    trim: a,
    normalizer: l
  } = n === void 0 ? {} : n, u = i ? br$1 : ri, c = Mn({
    collapseWhitespace: s,
    trim: a,
    normalizer: l
  });
  return Array.from(t.querySelectorAll("[" + e + "]")).filter((d) => u(d.getAttribute(e), d, r, c));
}
o(Nn, "queryAllByAttribute");
function c$(e, t, r, n) {
  let i = Nn(e, t, r, n);
  if (i.length > 1)
    throw jh("Found multiple elements by [" + e + "=" + r + "]", t);
  return i[0] || null;
}
o(c$, "queryByAttribute");
function ei(e, t) {
  return function(r) {
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      i[s - 1] = arguments[s];
    let a = e(r, ...i);
    if (a.length > 1) {
      let l = a.map((u) => Nh(null, u).message).join(`

`);
      throw jh(t(r, ...i) + `

Here are the matching elements:

` + l, r);
    }
    return a[0] || null;
  };
}
o(ei, "makeSingleQuery");
function d$(e, t) {
  return ie$1().getElementError(`A better query is available, try this:
` + e.toString() + `
`, t);
}
o(d$, "getSuggestionError");
function lT(e, t) {
  return function(r) {
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      i[s - 1] = arguments[s];
    let a = e(r, ...i);
    if (!a.length)
      throw ie$1().getElementError(t(r, ...i), r);
    return a;
  };
}
o(lT, "makeGetAllQuery");
function ti(e) {
  return (t, r, n, i) => aT(() => e(t, r, n), {
    container: t,
    ...i
  });
}
o(ti, "makeFindQuery");
var nn$1 = /* @__PURE__ */ o((e, t, r) => function(n) {
  for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
    s[a - 1] = arguments[a];
  let l = e(n, ...s), [{
    suggest: u = ie$1().throwSuggestions
  } = {}] = s.slice(-1);
  if (l && u) {
    let c = qh(l, r);
    if (c && !t.endsWith(c.queryName))
      throw d$(c.toString(), n);
  }
  return l;
}, "wrapSingleQueryWithSuggestion"), mt$1 = /* @__PURE__ */ o((e, t, r) => function(n) {
  for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
    s[a - 1] = arguments[a];
  let l = e(n, ...s), [{
    suggest: u = ie$1().throwSuggestions
  } = {}] = s.slice(-1);
  if (l.length && u) {
    let c = [...new Set(l.map((d) => {
      var p;
      return (p = qh(d, r)) == null ? void 0 : p.toString();
    }))];
    if (
      // only want to suggest if all the els have the same suggestion.
      c.length === 1 && !t.endsWith(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
        qh(l[0], r).queryName
      )
    )
      throw d$(c[0], n);
  }
  return l;
}, "wrapAllByQueryWithSuggestion");
function vr$1(e, t, r) {
  let n = nn$1(ei(e, t), e.name, "query"), i = lT(e, r), s = ei(i, t), a = nn$1(s, e.name, "get"), l = mt$1(i, e.name.replace("query", "get"), "getAll"), u = ti(mt$1(i, e.name, "findAll")), c = ti(nn$1(s, e.name, "find"));
  return [n, l, a, u, c];
}
o(vr$1, "buildQueries");
var Uye = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getElementError: Nh,
  wrapAllByQueryWithSuggestion: mt$1,
  wrapSingleQueryWithSuggestion: nn$1,
  getMultipleElementsFoundError: jh,
  queryAllByAttribute: Nn,
  queryByAttribute: c$,
  makeSingleQuery: ei,
  makeGetAllQuery: lT,
  makeFindQuery: ti,
  buildQueries: vr$1
});
function Vye(e) {
  return Array.from(e.querySelectorAll("label,input")).map((t) => ({
    node: t,
    textToMatch: Yw(t)
  })).filter((t) => {
    let {
      textToMatch: r
    } = t;
    return r !== null;
  });
}
o(Vye, "queryAllLabels");
var zye = /* @__PURE__ */ o(function(e, t, r) {
  let {
    exact: n = true,
    trim: i,
    collapseWhitespace: s,
    normalizer: a
  } = r === void 0 ? {} : r, l = n ? br$1 : ri, u = Mn({
    collapseWhitespace: s,
    trim: i,
    normalizer: a
  });
  return Vye(e).filter((d) => {
    let {
      node: p,
      textToMatch: f
    } = d;
    return l(f, p, t, u);
  }).map((d) => {
    let {
      node: p
    } = d;
    return p;
  });
}, "queryAllLabelsByText"), Zs = /* @__PURE__ */ o(function(e, t, r) {
  let {
    selector: n = "*",
    exact: i = true,
    collapseWhitespace: s,
    trim: a,
    normalizer: l
  } = r === void 0 ? {} : r;
  gr$1(e);
  let u = i ? br$1 : ri, c = Mn({
    collapseWhitespace: s,
    trim: a,
    normalizer: l
  }), d = Array.from(e.querySelectorAll("*")).filter((p) => n$(p).length || p.hasAttribute("aria-labelledby")).reduce((p, f) => {
    let m = o$(e, f, {
      selector: n
    });
    m.filter((b) => !!b.formControl).forEach((b) => {
      u(b.content, b.formControl, t, c) && b.formControl && p.push(b.formControl);
    });
    let h = m.filter((b) => !!b.content).map((b) => b.content);
    return u(h.join(" "), f, t, c) && p.push(f), h.length > 1 && h.forEach((b, v) => {
      u(b, f, t, c) && p.push(f);
      let g = [...h];
      g.splice(v, 1), g.length > 1 && u(g.join(" "), f, t, c) && p.push(f);
    }), p;
  }, []).concat(Nn("aria-label", e, t, {
    exact: i,
    normalizer: c
  }));
  return Array.from(new Set(d)).filter((p) => p.matches(n));
}, "queryAllByLabelText"), In = /* @__PURE__ */ o(function(e, t) {
  for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), i = 2; i < r; i++)
    n[i - 2] = arguments[i];
  let s = Zs(e, t, ...n);
  if (!s.length) {
    let a = zye(e, t, ...n);
    if (a.length) {
      let l = a.map((u) => Gye(e, u)).filter((u) => !!u);
      throw l.length ? ie$1().getElementError(l.map((u) => "Found a label with the text of: " + t + ", however the element associated with this label (<" + u + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + u + " />, you can use aria-label or aria-labelledby instead.").join(`

`), e) : ie$1().getElementError("Found a label with the text of: " + t + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, e);
    } else
      throw ie$1().getElementError("Unable to find a label with the text of: " + t, e);
  }
  return s;
}, "getAllByLabelText");
function Gye(e, t) {
  let r = t.getAttribute("for");
  if (!r)
    return null;
  let n = e.querySelector('[id="' + r + '"]');
  return n ? n.tagName.toLowerCase() : null;
}
o(Gye, "getTagNameOfElementAssociatedWithLabelViaFor");
var p$ = /* @__PURE__ */ o((e, t) => "Found multiple elements with the text of: " + t, "getMultipleError$7"), f$ = nn$1(ei(Zs, p$), Zs.name, "query"), m$ = ei(In, p$), h$ = ti(mt$1(In, In.name, "findAll")), y$ = ti(nn$1(m$, In.name, "find")), b$ = mt$1(In, In.name, "getAll"), g$ = nn$1(
  m$,
  In.name,
  "get"
), v$ = mt$1(Zs, Zs.name, "queryAll"), Kw = /* @__PURE__ */ o(function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return gr$1(t[0]), Nn("placeholder", ...t);
}, "queryAllByPlaceholderText"), Wye = /* @__PURE__ */ o((e, t) => "Found multiple elements with the placeholder text of: " + t, "getMultipleError$6"), Yye = /* @__PURE__ */ o((e, t) => "Unable to find an element with the placeholder text of: " + t, "getMissingError$6"), E$ = mt$1(
  Kw,
  Kw.name,
  "queryAll"
), [x$, w$, T$, R$, S$] = vr$1(Kw, Wye, Yye), Xw = /* @__PURE__ */ o(function(e, t, r) {
  let {
    selector: n = "*",
    exact: i = true,
    collapseWhitespace: s,
    trim: a,
    ignore: l = ie$1().defaultIgnore,
    normalizer: u
  } = r === void 0 ? {} : r;
  gr$1(e);
  let c = i ? br$1 : ri, d = Mn({
    collapseWhitespace: s,
    trim: a,
    normalizer: u
  }), p = [];
  return typeof e.matches == "function" && e.matches(n) && (p = [e]), [...p, ...Array.from(e.querySelectorAll(n))].filter((f) => !l || !f.matches(
    l
  )).filter((f) => c(ra(f), f, t, d));
}, "queryAllByText"), Kye = /* @__PURE__ */ o((e, t) => "Found multiple elements with the text: " + t, "getMultipleError$5"), Xye = /* @__PURE__ */ o(
  function(e, t, r) {
    r === void 0 && (r = {});
    let {
      collapseWhitespace: n,
      trim: i,
      normalizer: s,
      selector: a
    } = r, u = Mn({
      collapseWhitespace: n,
      trim: i,
      normalizer: s
    })(t.toString()), c = u !== t.toString(), d = (a ?? "*") !== "*";
    return "Unable to find an element with the text: " + (c ? u + " (normalized from '" + t + "')" : t) + (d ? ", which matches selector '" + a + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
  },
  "getMissingError$5"
), _$ = mt$1(Xw, Xw.name, "queryAll"), [C$, P$, A$, O$, q$] = vr$1(Xw, Kye, Xye), Jw = /* @__PURE__ */ o(function(e, t, r) {
  let {
    exact: n = true,
    collapseWhitespace: i,
    trim: s,
    normalizer: a
  } = r === void 0 ? {} : r;
  gr$1(e);
  let l = n ? br$1 : ri, u = Mn({
    collapseWhitespace: i,
    trim: s,
    normalizer: a
  });
  return Array.from(e.querySelectorAll("input,textarea,select")).filter((c) => c.tagName === "SELECT" ? Array.from(c.options).filter((p) => p.selected).some((p) => l(ra(p), p, t, u)) : l(c.value, c, t, u));
}, "queryAllByDisplayValue"), Jye = /* @__PURE__ */ o((e, t) => "Found multiple elements with the display value: " + t + ".", "getMultipleError$4"), Qye = /* @__PURE__ */ o((e, t) => "Unable to find an element with the display value: " + t + ".", "getMissingError$4"), I$ = mt$1(
  Jw,
  Jw.name,
  "queryAll"
), [M$, N$, j$, k$, L$] = vr$1(Jw, Jye, Qye), Zye = /^(img|input|area|.+-.+)$/i, Qw = /* @__PURE__ */ o(function(e, t, r) {
  return r === void 0 && (r = {}), gr$1(e), Nn("alt", e, t, r).filter((n) => Zye.test(n.tagName));
}, "queryAllByAltText"), ebe = /* @__PURE__ */ o((e, t) => "Found multiple elements with the alt text: " + t, "getMultipleError$3"), tbe = /* @__PURE__ */ o(
  (e, t) => "Unable to find an element with the alt text: " + t,
  "getMissingError$3"
), F$ = mt$1(Qw, Qw.name, "queryAll"), [D$, $$, B$, H$, U$] = vr$1(
  Qw,
  ebe,
  tbe
), rbe = /* @__PURE__ */ o((e) => {
  var t;
  return e.tagName.toLowerCase() === "title" && ((t = e.parentElement) == null ? void 0 : t.tagName.toLowerCase()) === "svg";
}, "isSvgTitle"), Zw = /* @__PURE__ */ o(function(e, t, r) {
  let {
    exact: n = true,
    collapseWhitespace: i,
    trim: s,
    normalizer: a
  } = r === void 0 ? {} : r;
  gr$1(e);
  let l = n ? br$1 : ri, u = Mn({
    collapseWhitespace: i,
    trim: s,
    normalizer: a
  });
  return Array.from(e.querySelectorAll("[title], svg > title")).filter((c) => l(c.getAttribute("title"), c, t, u) || rbe(c) && l(
    ra(c),
    c,
    t,
    u
  ));
}, "queryAllByTitle"), nbe = /* @__PURE__ */ o((e, t) => "Found multiple elements with the title: " + t + ".", "getMultipleError$2"), obe = /* @__PURE__ */ o(
  (e, t) => "Unable to find an element with the title: " + t + ".",
  "getMissingError$2"
), V$ = mt$1(Zw, Zw.name, "queryAll"), [z$, G$, W$, Y$, K$] = vr$1(
  Zw,
  nbe,
  obe
), eT = /* @__PURE__ */ o(function(e, t, r) {
  let {
    hidden: n = ie$1().defaultHidden,
    name: i,
    description: s,
    queryFallbacks: a = false,
    selected: l,
    busy: u,
    checked: c,
    pressed: d,
    current: p,
    level: f,
    expanded: m,
    value: {
      now: h,
      min: b,
      max: v,
      text: g
    } = {}
  } = r === void 0 ? {} : r;
  if (gr$1(e), l !== void 0) {
    var w;
    if (((w = lt$1.roles.get(t)) == null ? void 0 : w.props["aria-selected"]) === void 0)
      throw new Error('"aria-selected" is not supported on role "' + t + '".');
  }
  if (u !== void 0) {
    var E;
    if (((E = lt$1.roles.get(t)) == null ? void 0 : E.props["aria-busy"]) === void 0)
      throw new Error('"aria-busy" is not supported on role "' + t + '".');
  }
  if (c !== void 0) {
    var R;
    if (((R = lt$1.roles.get(t)) == null ? void 0 : R.props["aria-checked"]) === void 0)
      throw new Error('"aria-checked" is not supported on role "' + t + '".');
  }
  if (d !== void 0) {
    var S;
    if (((S = lt$1.roles.get(t)) == null ? void 0 : S.props["aria-pressed"]) === void 0)
      throw new Error('"aria-pressed" is not supported on role "' + t + '".');
  }
  if (p !== void 0) {
    var P;
    if (((P = lt$1.roles.get(t)) == null ? void 0 : P.props["aria-current"]) === void 0)
      throw new Error('"aria-current" is not supported on role "' + t + '".');
  }
  if (f !== void 0 && t !== "heading")
    throw new Error('Role "' + t + '" cannot have "level" property.');
  if (h !== void 0) {
    var _;
    if (((_ = lt$1.roles.get(t)) == null ? void 0 : _.props["aria-valuenow"]) === void 0)
      throw new Error('"aria-valuenow" is not supported on role "' + t + '".');
  }
  if (v !== void 0) {
    var C;
    if (((C = lt$1.roles.get(t)) == null ? void 0 : C.props["aria-valuemax"]) === void 0)
      throw new Error('"aria-valuemax" is not supported on role "' + t + '".');
  }
  if (b !== void 0) {
    var O;
    if (((O = lt$1.roles.get(t)) == null ? void 0 : O.props["aria-valuemin"]) === void 0)
      throw new Error('"aria-valuemin" is not supported on role "' + t + '".');
  }
  if (g !== void 0) {
    var L;
    if (((L = lt$1.roles.get(t)) == null ? void 0 : L.props["aria-valuetext"]) === void 0)
      throw new Error('"aria-valuetext" is not supported on role "' + t + '".');
  }
  if (m !== void 0) {
    var q;
    if (((q = lt$1.roles.get(t)) == null ? void 0 : q.props["aria-expanded"]) === void 0)
      throw new Error('"aria-expanded" is not supported on role "' + t + '".');
  }
  let D = /* @__PURE__ */ new WeakMap();
  function H(M) {
    return D.has(M) || D.set(M, a$(M)), D.get(M);
  }
  return o(H, "cachedIsSubtreeInaccessible"), Array.from(e.querySelectorAll(
    // Only query elements that can be matched by the following filters
    ibe(t)
  )).filter((M) => {
    if (M.hasAttribute("role")) {
      let W = M.getAttribute("role");
      if (a)
        return W.split(" ").filter(Boolean).some((ae) => ae === t);
      let [Y] = W.split(" ");
      return Y === t;
    }
    return sT(M).some((W) => W === t);
  }).filter((M) => {
    if (l !== void 0)
      return l === Oye(M);
    if (u !== void 0)
      return u === qye(M);
    if (c !== void 0)
      return c === Iye(M);
    if (d !== void 0)
      return d === Mye(M);
    if (p !== void 0)
      return p === Nye(M);
    if (m !== void 0)
      return m === jye(M);
    if (f !== void 0)
      return f === kye(M);
    if (h !== void 0 || v !== void 0 || b !== void 0 || g !== void 0) {
      let N = true;
      if (h !== void 0 && N && (N = h === Lye(M)), v !== void 0 && N && (N = v === Fye(M)), b !== void 0 && N && (N = b === Dye(M)), g !== void 0) {
        var U;
        N && (N = br$1((U = $ye(M)) != null ? U : null, M, g, (W) => W));
      }
      return N;
    }
    return true;
  }).filter((M) => i === void 0 ? true : br$1(Ys(M, {
    computedStyleSupportsPseudoElements: ie$1().computedStyleSupportsPseudoElements
  }), M, i, (U) => U)).filter((M) => s === void 0 ? true : br$1(Ip(M, {
    computedStyleSupportsPseudoElements: ie$1().computedStyleSupportsPseudoElements
  }), M, s, (U) => U)).filter((M) => n === false ? Mh(M, {
    isSubtreeInaccessible: H
  }) === false : true);
}, "queryAllByRole");
function ibe(e) {
  var t;
  let r = '*[role~="' + e + '"]', n = (t = lt$1.roleElements.get(e)) != null ? t : /* @__PURE__ */ new Set(), i = new Set(Array.from(n).map((s) => {
    let {
      name: a
    } = s;
    return a;
  }));
  return [r].concat(Array.from(i)).join(",");
}
o(ibe, "makeRoleSelector");
var X$ = /* @__PURE__ */ o((e) => {
  let t = "";
  return e === void 0 ? t = "" : typeof e == "string" ? t = ' and name "' + e + '"' : t = " and name `" + e + "`", t;
}, "getNameHint"), sbe = /* @__PURE__ */ o(function(e, t, r) {
  let {
    name: n
  } = r === void 0 ? {} : r;
  return 'Found multiple elements with the role "' + t + '"' + X$(n);
}, "getMultipleError$1"), abe = /* @__PURE__ */ o(function(e, t, r) {
  let {
    hidden: n = ie$1().defaultHidden,
    name: i,
    description: s
  } = r === void 0 ? {} : r;
  if (ie$1()._disableExpensiveErrorDiagnostics)
    return 'Unable to find role="' + t + '"' + X$(i);
  let a = "";
  Array.from(e.children).forEach((d) => {
    a += u$(d, {
      hidden: n,
      includeDescription: s !== void 0
    });
  });
  let l;
  a.length === 0 ? n === false ? l = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole" : l = "There are no available roles." : l = (`
Here are the ` + (n === false ? "accessible" : "available") + ` roles:

  ` + a.replace(/\n/g, `
  `).replace(/\n\s\s\n/g, `

`) + `
`).trim();
  let u = "";
  i === void 0 ? u = "" : typeof i == "string" ? u = ' and name "' + i + '"' : u = " and name `" + i + "`";
  let c = "";
  return s === void 0 ? c = "" : typeof s == "string" ? c = ' and description "' + s + '"' : c = " and description `" + s + "`", (`
Unable to find an ` + (n === false ? "accessible " : "") + 'element with the role "' + t + '"' + u + c + `

` + l).trim();
}, "getMissingError$1"), J$ = mt$1(eT, eT.name, "queryAll"), [Q$, Z$, eB, tB, rB] = vr$1(eT, sbe, abe), uT = /* @__PURE__ */ o(
  () => ie$1().testIdAttribute,
  "getTestIdAttribute"
), tT = /* @__PURE__ */ o(function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return gr$1(t[0]), Nn(uT(), ...t);
}, "queryAllByTestId"), lbe = /* @__PURE__ */ o((e, t) => "Found multiple elements by: [" + uT() + '="' + t + '"]', "getMultipleError"), ube = /* @__PURE__ */ o(
  (e, t) => "Unable to find an element by: [" + uT() + '="' + t + '"]',
  "getMissingError"
), nB = mt$1(tT, tT.name, "queryAll"), [
  oB,
  iB,
  sB,
  aB,
  lB
] = vr$1(tT, lbe, ube), Ih = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  queryAllByLabelText: v$,
  queryByLabelText: f$,
  getAllByLabelText: b$,
  getByLabelText: g$,
  findAllByLabelText: h$,
  findByLabelText: y$,
  queryByPlaceholderText: x$,
  queryAllByPlaceholderText: E$,
  getByPlaceholderText: T$,
  getAllByPlaceholderText: w$,
  findAllByPlaceholderText: R$,
  findByPlaceholderText: S$,
  queryByText: C$,
  queryAllByText: _$,
  getByText: A$,
  getAllByText: P$,
  findAllByText: O$,
  findByText: q$,
  queryByDisplayValue: M$,
  queryAllByDisplayValue: I$,
  getByDisplayValue: j$,
  getAllByDisplayValue: N$,
  findAllByDisplayValue: k$,
  findByDisplayValue: L$,
  queryByAltText: D$,
  queryAllByAltText: F$,
  getByAltText: B$,
  getAllByAltText: $$,
  findAllByAltText: H$,
  findByAltText: U$,
  queryByTitle: z$,
  queryAllByTitle: V$,
  getByTitle: W$,
  getAllByTitle: G$,
  findAllByTitle: Y$,
  findByTitle: K$,
  queryByRole: Q$,
  queryAllByRole: J$,
  getAllByRole: Z$,
  getByRole: eB,
  findAllByRole: tB,
  findByRole: rB,
  queryByTestId: oB,
  queryAllByTestId: nB,
  getByTestId: sB,
  getAllByTestId: iB,
  findAllByTestId: aB,
  findByTestId: lB
});
function uB(e, t, r) {
  return t === void 0 && (t = Ih), r === void 0 && (r = {}), Object.keys(t).reduce((n, i) => {
    let s = t[i];
    return n[i] = s.bind(null, e), n;
  }, r);
}
o(uB, "getQueriesForElement");
var cB = /* @__PURE__ */ o((e) => !e || Array.isArray(e) && !e.length, "isRemoved");
function HD(e) {
  if (cB(e))
    throw new Error("The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.");
}
o(HD, "initialCheck");
async function cbe(e, t) {
  let r = new Error("Timed out in waitForElementToBeRemoved.");
  if (typeof e != "function") {
    HD(e);
    let i = (Array.isArray(e) ? e : [e]).map((s) => {
      let a = s.parentElement;
      if (a === null) return () => null;
      for (; a.parentElement; ) a = a.parentElement;
      return () => a.contains(s) ? s : null;
    });
    e = /* @__PURE__ */ o(() => i.map((s) => s()).filter(Boolean), "callback");
  }
  return HD(e()), aT(() => {
    let n;
    try {
      n = e();
    } catch (i) {
      if (i.name === "TestingLibraryElementError")
        return;
      throw i;
    }
    if (!cB(n))
      throw r;
  }, t);
}
o(cbe, "waitForElementToBeRemoved");
var UD = {
  // Clipboard Events
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Composition Events
  compositionEnd: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  compositionStart: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  compositionUpdate: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Keyboard Events
  keyDown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      charCode: 0,
      composed: true
    }
  },
  keyPress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      charCode: 0,
      composed: true
    }
  },
  keyUp: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      charCode: 0,
      composed: true
    }
  },
  // Focus Events
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  focusIn: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  focusOut: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  // Form Events
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  invalid: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: true
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  reset: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  // Mouse Events
  click: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      button: 0,
      composed: true
    }
  },
  contextMenu: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dblClick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  drag: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dragEnd: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  dragEnter: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dragExit: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  dragLeave: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  dragOver: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dragStart: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  drop: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseDown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseEnter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mouseLeave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mouseMove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseOut: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseOver: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseUp: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Selection Events
  select: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // Touch Events
  touchCancel: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  touchEnd: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  touchMove: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  touchStart: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // UI Events
  resize: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  scroll: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  // Wheel Events
  wheel: {
    EventType: "WheelEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  // Media Events
  abort: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  canPlay: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  canPlayThrough: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  durationChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  emptied: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  encrypted: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  ended: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  loadedData: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  loadedMetadata: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  loadStart: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pause: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  play: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  playing: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  progress: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  rateChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  seeked: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  seeking: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  stalled: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  suspend: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  timeUpdate: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  volumeChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  waiting: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  // Events
  load: {
    // TODO: load events can be UIEvent or Event depending on what generated them
    // This is where this abstraction breaks down.
    // But the common targets are <img />, <script /> and window.
    // Neither of these targets receive a UIEvent
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  error: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  // Animation Events
  animationStart: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  animationEnd: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  animationIteration: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // Transition Events
  transitionCancel: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  transitionEnd: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  transitionRun: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  transitionStart: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // pointer events
  pointerOver: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerEnter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pointerDown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerMove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerUp: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerCancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  pointerOut: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerLeave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  gotPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  lostPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  // history events
  popState: {
    EventType: "PopStateEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  // window events
  offline: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  online: {
    EventType: "Event",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pageHide: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  },
  pageShow: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  }
}, VD = {
  doubleClick: "dblClick"
};
function ea(e, t) {
  return ie$1().eventWrapper(() => {
    if (!t)
      throw new Error("Unable to fire an event - please provide an event object.");
    if (!e)
      throw new Error('Unable to fire a "' + t.type + '" event - please provide a DOM element.');
    return e.dispatchEvent(t);
  });
}
o(ea, "fireEvent");
function Oh(e, t, r, n) {
  let {
    EventType: i = "Event",
    defaultInit: s = {}
  } = n === void 0 ? {} : n;
  if (!t)
    throw new Error('Unable to fire a "' + e + '" event - please provide a DOM element.');
  let a = {
    ...s,
    ...r
  }, {
    target: {
      value: l,
      files: u,
      ...c
    } = {}
  } = a;
  l !== void 0 && dbe(t, l), u !== void 0 && Object.defineProperty(t, "files", {
    configurable: true,
    enumerable: true,
    writable: true,
    value: u
  }), Object.assign(t, c);
  let d = t$(t), p = d[i] || d.Event, f;
  if (typeof p == "function")
    f = new p(e, a);
  else {
    f = d.document.createEvent(i);
    let {
      bubbles: h,
      cancelable: b,
      detail: v,
      ...g
    } = a;
    f.initEvent(e, h, b, v), Object.keys(g).forEach((w) => {
      f[w] = g[w];
    });
  }
  return ["dataTransfer", "clipboardData"].forEach((h) => {
    let b = a[h];
    typeof b == "object" && (typeof d.DataTransfer == "function" ? Object.defineProperty(f, h, {
      value: Object.getOwnPropertyNames(b).reduce((v, g) => (Object.defineProperty(v, g, {
        value: b[g]
      }), v), new d.DataTransfer())
    }) : Object.defineProperty(f, h, {
      value: b
    }));
  }), f;
}
o(Oh, "createEvent");
Object.keys(UD).forEach((e) => {
  let {
    EventType: t,
    defaultInit: r
  } = UD[e], n = e.toLowerCase();
  Oh[e] = (i, s) => Oh(n, i, s, {
    EventType: t,
    defaultInit: r
  }), ea[e] = (i, s) => ea(i, Oh[e](i, s));
});
function dbe(e, t) {
  let {
    set: r
  } = Object.getOwnPropertyDescriptor(e, "value") || {}, n = Object.getPrototypeOf(e), {
    set: i
  } = Object.getOwnPropertyDescriptor(n, "value") || {};
  if (i && r !== i)
    i.call(e, t);
  else if (r)
    r.call(e, t);
  else
    throw new Error("The given element does not have a value setter");
}
o(dbe, "setNativeValue");
Object.keys(VD).forEach((e) => {
  let t = VD[e];
  ea[e] = function() {
    return ea[t](...arguments);
  };
});
function pbe(e) {
  return e.replace(/[ \t]*[\n][ \t]*/g, `
`);
}
o(pbe, "unindent");
function fbe(e) {
  return GD.default.compressToEncodedURIComponent(pbe(e));
}
o(fbe, "encode");
function mbe(e) {
  return "https://testing-playground.com/#markup=" + fbe(e);
}
o(mbe, "getPlaygroundUrl");
var hbe = /* @__PURE__ */ o((e, t, r) => Array.isArray(e) ? e.forEach((n) => Ww(n, t, r)) : Ww(e, t, r), "debug"), ybe = /* @__PURE__ */ o(function(e) {
  if (e === void 0 && (e = oT().body), !e || !("innerHTML" in e)) {
    console.log("The element you're providing isn't a valid DOM element.");
    return;
  }
  if (!e.innerHTML) {
    console.log("The provided element doesn't have any children.");
    return;
  }
  let t = mbe(e.innerHTML);
  return console.log(`Open this URL in your browser

` + t), t;
}, "logTestingPlaygroundURL"), zD = {
  debug: hbe,
  logTestingPlaygroundURL: ybe
}, bbe = typeof document < "u" && document.body ? uB(document.body, Ih, zD) : Object.keys(Ih).reduce((e, t) => (e[t] = () => {
  throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
}, e), zD);
function X$1(e, t, r) {
  return e.namespaceURI && e.namespaceURI !== "http://www.w3.org/1999/xhtml" || (t = Array.isArray(t) ? t : [
    t
  ], !t.includes(e.tagName.toLowerCase())) ? false : r ? Object.entries(r).every(([n, i]) => e[n] === i) : true;
}
o(X$1, "isElementType");
function Ae(e) {
  var t;
  if (gbe(e) && e.defaultView)
    return e.defaultView;
  if (!((t = e.ownerDocument) === null || t === void 0) && t.defaultView)
    return e.ownerDocument.defaultView;
  throw new Error(`Could not determine window of node. Node was ${vbe(e)}`);
}
o(Ae, "getWindow");
function gbe(e) {
  return e.nodeType === 9;
}
o(gbe, "isDocument");
function vbe(e) {
  return typeof e == "function" ? `function ${e.name}` : e === null ? "null" : String(e);
}
o(vbe, "describe");
function dT(e, t) {
  return new Promise((r, n) => {
    let i = new t();
    i.onerror = n, i.onabort = n, i.onload = () => {
      r(String(i.result));
    }, i.readAsText(e);
  });
}
o(dT, "readBlobText");
function oa(e, t) {
  let r = {
    ...t,
    length: t.length,
    item: /* @__PURE__ */ o((n) => r[n], "item"),
    [Symbol.iterator]: /* @__PURE__ */ o(function* () {
      for (let i = 0; i < r.length; i++)
        yield r[i];
    }, "nextFile")
  };
  return r.constructor = e.FileList, e.FileList && Object.setPrototypeOf(r, e.FileList.prototype), Object.freeze(r), r;
}
o(oa, "createFileList");
function on$2(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = r, e;
}
o(on$2, "_define_property");
var fT = class fT2 {
  getAsFile() {
    return this.file;
  }
  getAsString(t) {
    typeof this.data == "string" && t(this.data);
  }
  /* istanbul ignore next */
  webkitGetAsEntry() {
    throw new Error("not implemented");
  }
  constructor(t, r) {
    on$2(this, "kind", void 0), on$2(this, "type", void 0), on$2(this, "file", null), on$2(this, "data", void 0), typeof t == "string" ? (this.kind = "string", this.type = String(r), this.data = t) : (this.kind = "file", this.type = t.type, this.file = t);
  }
};
o(fT, "DataTransferItemStub");
var Lh = fT, mT = class mT2 extends Array {
  add(...t) {
    let r = new Lh(t[0], t[1]);
    return this.push(r), r;
  }
  clear() {
    this.splice(0, this.length);
  }
  remove(t) {
    this.splice(t, 1);
  }
};
o(mT, "DataTransferItemListStub");
var pT = mT;
function kh(e, t) {
  let [r, n] = e.split("/"), i = !n || n === "*";
  return (s) => t ? s.type === (i ? r : e) : i ? s.type.startsWith(`${r}/`) : s.type === r;
}
o(kh, "getTypeMatcher");
function Ebe(e) {
  var t;
  return new (t = class {
    getData(n) {
      var i;
      let s = (i = this.items.find(kh(n, true))) !== null && i !== void 0 ? i : this.items.find(kh(n, false)), a = "";
      return s?.getAsString((l) => {
        a = l;
      }), a;
    }
    setData(n, i) {
      let s = this.items.findIndex(kh(n, true)), a = new Lh(i, n);
      s >= 0 ? this.items.splice(s, 1, a) : this.items.push(a);
    }
    clearData(n) {
      if (n) {
        let i = this.items.findIndex(kh(n, true));
        i >= 0 && this.items.remove(i);
      } else
        this.items.clear();
    }
    get types() {
      let n = [];
      return this.files.length && n.push("Files"), this.items.forEach((i) => n.push(i.type)), Object.freeze(n), n;
    }
    /* istanbul ignore next */
    setDragImage() {
    }
    constructor() {
      on$2(this, "dropEffect", "none"), on$2(this, "effectAllowed", "uninitialized"), on$2(this, "items", new pT()), on$2(this, "files", oa(e, []));
    }
  }, o(t, "DataTransferStub"), t)();
}
o(Ebe, "createDataTransferStub");
function ni(e, t = []) {
  let r = typeof e.DataTransfer > "u" ? Ebe(e) : (
    /* istanbul ignore next */
    new e.DataTransfer()
  );
  return Object.defineProperty(r, "files", {
    get: /* @__PURE__ */ o(() => oa(e, t), "get")
  }), r;
}
o(ni, "createDataTransfer");
async function dB(e, t) {
  return t.kind === "file" ? t.getAsFile() : new e.Blob([
    await new Promise((r) => t.getAsString(r))
  ], {
    type: t.type
  });
}
o(dB, "getBlobFromDataTransferItem");
function fB(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = r, e;
}
o(fB, "_define_property");
function mB(e, ...t) {
  var n;
  let r = Object.fromEntries(t.map((i) => [
    typeof i == "string" ? "text/plain" : i.type,
    Promise.resolve(i)
  ]));
  return typeof e.ClipboardItem < "u" ? new e.ClipboardItem(r) : new (n = class {
    get types() {
      return Array.from(Object.keys(this.data));
    }
    async getType(s) {
      let a = await this.data[s];
      if (!a)
        throw new Error(`${s} is not one of the available MIME types on this item.`);
      return a instanceof e.Blob ? a : new e.Blob([
        a
      ], {
        type: s
      });
    }
    constructor(s) {
      fB(this, "data", void 0), this.data = s;
    }
  }, o(n, "ClipboardItem"), n)(r);
}
o(mB, "createClipboardItem");
var oi = Symbol("Manage ClipboardSub");
function pB(e, t) {
  var r;
  return Object.assign(new (r = class extends e.EventTarget {
    async read() {
      return Array.from(this.items);
    }
    async readText() {
      let i = "";
      for (let s of this.items) {
        let a = s.types.includes("text/plain") ? "text/plain" : s.types.find((l) => l.startsWith("text/"));
        a && (i += await s.getType(a).then((l) => dT(l, e.FileReader)));
      }
      return i;
    }
    async write(i) {
      this.items = i;
    }
    async writeText(i) {
      this.items = [
        mB(e, i)
      ];
    }
    constructor(...i) {
      super(...i), fB(this, "items", []);
    }
  }, o(r, "Clipboard"), r)(), {
    [oi]: t
  });
}
o(pB, "createClipboardStub");
function hT(e) {
  return !!e?.[oi];
}
o(hT, "isClipboardStub");
function hB(e) {
  if (hT(e.navigator.clipboard))
    return e.navigator.clipboard[oi];
  let t = Object.getOwnPropertyDescriptor(e.navigator, "clipboard"), r, n = {
    resetClipboardStub: /* @__PURE__ */ o(() => {
      r = pB(e, n);
    }, "resetClipboardStub"),
    detachClipboardStub: /* @__PURE__ */ o(() => {
      t ? Object.defineProperty(e.navigator, "clipboard", t) : Object.defineProperty(e.navigator, "clipboard", {
        value: void 0,
        configurable: true
      });
    }, "detachClipboardStub")
  };
  return r = pB(e, n), Object.defineProperty(e.navigator, "clipboard", {
    get: /* @__PURE__ */ o(() => r, "get"),
    configurable: true
  }), r[oi];
}
o(hB, "attachClipboardStubToView");
function xbe(e) {
  hT(e.navigator.clipboard) && e.navigator.clipboard[oi].resetClipboardStub();
}
o(xbe, "resetClipboardStubOnView");
function wbe(e) {
  hT(e.navigator.clipboard) && e.navigator.clipboard[oi].detachClipboardStub();
}
o(wbe, "detachClipboardStubFromView");
async function yB(e) {
  let t = e.defaultView, r = t?.navigator.clipboard, n = r && await r.read();
  if (!n)
    throw new Error("The Clipboard API is unavailable.");
  let i = ni(t);
  for (let s of n)
    for (let a of s.types)
      i.setData(a, await s.getType(a).then((l) => dT(l, t.FileReader)));
  return i;
}
o(yB, "readDataTransferFromClipboard");
async function Dh(e, t) {
  let r = Ae(e), n = r.navigator.clipboard, i = [];
  for (let a = 0; a < t.items.length; a++) {
    let l = t.items[a], u = await dB(r, l);
    i.push(mB(r, u));
  }
  if (!(n && await n.write(i).then(
    () => true,
    // Can happen with other implementations that e.g. require permissions
    /* istanbul ignore next */
    () => false
  )))
    throw new Error("The Clipboard API is unavailable.");
}
o(Dh, "writeDataTransferToClipboard");
var Fh = globalThis;
typeof Fh.afterEach == "function" && Fh.afterEach(() => {
  typeof globalThis.window < "u" && xbe(globalThis.window);
});
typeof Fh.afterAll == "function" && Fh.afterAll(() => {
  typeof globalThis.window < "u" && wbe(globalThis.window);
});
var $h = [
  "input:not([type=hidden]):not([disabled])",
  "button:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  '[contenteditable=""]',
  '[contenteditable="true"]',
  "a[href]",
  "[tabindex]:not([disabled])"
].join(", ");
function ia$1(e) {
  return e.matches($h);
}
o(ia$1, "isFocusable");
function bB(e) {
  return new e.constructor(e.type, e);
}
o(bB, "cloneEvent");
function rt(e) {
  for (let r = e; r; r = r.parentElement)
    if (X$1(r, [
      "button",
      "input",
      "select",
      "textarea",
      "optgroup",
      "option"
    ])) {
      if (r.hasAttribute("disabled"))
        return true;
    } else if (X$1(r, "fieldset")) {
      var t;
      if (r.hasAttribute("disabled") && !(!((t = r.querySelector(":scope > legend")) === null || t === void 0) && t.contains(e)))
        return true;
    } else if (r.tagName.includes("-") && r.constructor.formAssociated && r.hasAttribute("disabled"))
      return true;
  return false;
}
o(rt, "isDisabled");
function jn(e) {
  let t = e.activeElement;
  return t?.shadowRoot ? jn(t.shadowRoot) : rt(t) ? e.ownerDocument ? (
    /* istanbul ignore next */
    e.ownerDocument.body
  ) : e.body : t;
}
o(jn, "getActiveElement");
function Bh(e) {
  var t;
  return (t = jn(e)) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  );
}
o(Bh, "getActiveElementOrBody");
function gB(e, t) {
  let r = e;
  do {
    if (t(r))
      return r;
    r = r.parentElement;
  } while (r && r !== e.ownerDocument.body);
}
o(gB, "findClosest");
function wt$1(e) {
  return e.hasAttribute("contenteditable") && (e.getAttribute("contenteditable") == "true" || e.getAttribute("contenteditable") == "");
}
o(wt$1, "isContentEditable");
function sn$1(e) {
  let t = Tbe(e);
  return t && (t.closest('[contenteditable=""]') || t.closest('[contenteditable="true"]'));
}
o(sn$1, "getContentEditable");
function Tbe(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
o(Tbe, "getElement");
var vB = /* @__PURE__ */ function(e) {
  return e.button = "button", e.color = "color", e.file = "file", e.image = "image", e.reset = "reset", e.submit = "submit", e.checkbox = "checkbox", e.radio = "radio", e;
}(vB || {});
function Hh(e) {
  return X$1(e, "button") || X$1(e, "input") && e.type in vB;
}
o(Hh, "isClickableInput");
function Wt(e) {
  return yT(e) && !e.readOnly || wt$1(e);
}
o(Wt, "isEditable");
var EB = /* @__PURE__ */ function(e) {
  return e.text = "text", e.date = "date", e["datetime-local"] = "datetime-local", e.email = "email", e.month = "month", e.number = "number", e.password = "password", e.search = "search", e.tel = "tel", e.time = "time", e.url = "url", e.week = "week", e;
}(EB || {});
function yT(e) {
  return X$1(e, "textarea") || X$1(e, "input") && e.type in EB;
}
o(yT, "isEditableInputOrTextArea");
function $e$1(e) {
  return wB(e) && yT(e);
}
o($e$1, "hasOwnSelection");
function xB(e) {
  return wB(e) && Hh(e);
}
o(xB, "hasNoSelection");
function wB(e) {
  return e.nodeType === 1;
}
o(wB, "isElement");
function TB(e) {
  let t = e.ownerDocument.getSelection();
  if (t?.focusNode && $e$1(e)) {
    let n = sn$1(t.focusNode);
    if (n) {
      if (!t.isCollapsed) {
        var r;
        let i = ((r = n.firstChild) === null || r === void 0 ? void 0 : r.nodeType) === 3 ? n.firstChild : n;
        t.setBaseAndExtent(i, 0, i, 0);
      }
    } else
      t.setBaseAndExtent(e, 0, e, 0);
  }
}
o(TB, "updateSelectionOnFocus");
function an$1(e, t) {
  return ie$1().eventWrapper(e);
}
o(an$1, "wrapEvent");
function ht$1(e) {
  let t = gB(e, ia$1), r = jn(e.ownerDocument);
  (t ?? e.ownerDocument.body) !== r && (t ? an$1(() => t.focus()) : an$1(() => r?.blur()), TB(t ?? e.ownerDocument.body));
}
o(ht$1, "focusElement");
function RB(e) {
  !ia$1(e) || !(jn(e.ownerDocument) === e) || an$1(() => e.blur());
}
o(RB, "blurElement");
var ut$1 = {};
ut$1.click = (e, t, r) => {
  let n = t.closest("button,input,label,select,textarea"), i = n && X$1(n, "label") && n.control;
  if (i && i !== t)
    return () => {
      ia$1(i) && (ht$1(i), r.dispatchEvent(i, bB(e)));
    };
  if (X$1(t, "input", {
    type: "file"
  }))
    return () => {
      RB(t), t.dispatchEvent(new (Ae(t)).Event("fileDialog")), ht$1(t);
    };
};
var ii = Symbol("Displayed value in UI"), Er$1 = Symbol("Displayed selection in UI"), Uh = Symbol("Initial value to compare on blur");
function SB(e) {
  return typeof e == "object" && ii in e;
}
o(SB, "isUIValue");
function _B(e) {
  return !!e && typeof e == "object" && Er$1 in e;
}
o(_B, "isUISelectionStart");
function CB(e, t) {
  e[Uh] === void 0 && (e[Uh] = e.value), e[ii] = t, e.value = Object.assign(new String(t), {
    [ii]: true
  });
}
o(CB, "setUIValue");
function Ge(e) {
  return e[ii] === void 0 ? e.value : String(e[ii]);
}
o(Ge, "getUIValue");
function sa(e) {
  e[ii] = void 0;
}
o(sa, "setUIValueClean");
function Vh(e) {
  e[Uh] = void 0;
}
o(Vh, "clearInitialValue");
function PB(e) {
  return e[Uh];
}
o(PB, "getInitialValue");
function AB(e, t) {
  e[Er$1] = t;
}
o(AB, "setUISelectionRaw");
function Yt(e, { focusOffset: t, anchorOffset: r = t }, n = "replace") {
  let i = Ge(e).length, s = /* @__PURE__ */ o((p) => Math.max(0, Math.min(i, p)), "sanitizeOffset"), a = n === "replace" || e[Er$1] === void 0 ? s(r) : e[Er$1].anchorOffset, l = s(t), u = Math.min(a, l), c = Math.max(a, l);
  if (e[Er$1] = {
    anchorOffset: a,
    focusOffset: l
  }, e.selectionStart === u && e.selectionEnd === c)
    return;
  let d = Object.assign(new Number(u), {
    [Er$1]: true
  });
  try {
    e.setSelectionRange(d, c);
  } catch {
  }
}
o(Yt, "setUISelection");
function xr$1(e) {
  var t, r, n;
  let i = (n = e[Er$1]) !== null && n !== void 0 ? n : {
    anchorOffset: (t = e.selectionStart) !== null && t !== void 0 ? t : 0,
    focusOffset: (r = e.selectionEnd) !== null && r !== void 0 ? r : 0
  };
  return {
    ...i,
    startOffset: Math.min(i.anchorOffset, i.focusOffset),
    endOffset: Math.max(i.anchorOffset, i.focusOffset)
  };
}
o(xr$1, "getUISelection");
function OB(e) {
  return !!e[Er$1];
}
o(OB, "hasUISelection");
function aa$1(e) {
  e[Er$1] = void 0;
}
o(aa$1, "setUISelectionClean");
var zh = globalThis.parseInt;
function IB(e) {
  let t = e.replace(/\D/g, "");
  if (t.length < 2)
    return e;
  let r = zh(t[0], 10), n = zh(t[1], 10);
  if (r >= 3 || r === 2 && n >= 4) {
    let i;
    return r >= 3 ? i = 1 : i = 2, qB(t, i);
  }
  return e.length === 2 ? e : qB(t, 2);
}
o(IB, "buildTimeValue");
function qB(e, t) {
  let r = e.slice(0, t), n = Math.min(zh(r, 10), 23), i = e.slice(t), s = zh(i, 10), a = Math.min(s, 59);
  return `${n.toString().padStart(2, "0")}:${a.toString().padStart(2, "0")}`;
}
o(qB, "build");
function bT(e, t) {
  let r = e.cloneNode();
  return r.value = t, r.value === t;
}
o(bT, "isValidDateOrTimeValue");
var MB = /* @__PURE__ */ function(e) {
  return e.email = "email", e.password = "password", e.search = "search", e.telephone = "telephone", e.text = "text", e.url = "url", e;
}(MB || {});
function NB(e) {
  var t;
  let r = (t = e.getAttribute("maxlength")) !== null && t !== void 0 ? t : "";
  return /^\d+$/.test(r) && Number(r) >= 0 ? Number(r) : void 0;
}
o(NB, "getMaxLength");
function jB(e) {
  return X$1(e, "textarea") || X$1(e, "input") && e.type in MB;
}
o(jB, "supportsMaxLength");
function Yh(e, t, r, n) {
  if (Wh(e) && t + r >= 0 && t + r <= e.nodeValue.length)
    return {
      node: e,
      offset: t + r
    };
  let i = kB(e, t, r);
  if (i) {
    if (Wh(i))
      return {
        node: i,
        offset: r > 0 ? Math.min(1, i.nodeValue.length) : Math.max(i.nodeValue.length - 1, 0)
      };
    if (X$1(i, "br")) {
      let s = kB(i, void 0, r);
      return s ? Wh(s) ? {
        node: s,
        offset: r > 0 ? 0 : s.nodeValue.length
      } : r < 0 && X$1(s, "br") ? {
        node: i.parentNode,
        offset: Gh(i)
      } : {
        node: s.parentNode,
        offset: Gh(s) + (r > 0 ? 0 : 1)
      } : r < 0 && n === "deleteContentBackward" ? {
        node: i.parentNode,
        offset: Gh(i)
      } : void 0;
    } else
      return {
        node: i.parentNode,
        offset: Gh(i) + (r > 0 ? 1 : 0)
      };
  }
}
o(Yh, "getNextCursorPosition");
function kB(e, t, r) {
  let n = Number(t) + (r < 0 ? -1 : 0);
  return t !== void 0 && gT(e) && n >= 0 && n < e.children.length && (e = e.children[n]), Sbe(e, r === 1 ? "next" : "previous", Rbe);
}
o(kB, "getNextCharacterContentNode");
function Rbe(e) {
  if (Wh(e))
    return true;
  if (gT(e)) {
    if (X$1(e, [
      "input",
      "textarea"
    ]))
      return e.type !== "hidden";
    if (X$1(e, "br"))
      return true;
  }
  return false;
}
o(Rbe, "isTreatedAsCharacterContent");
function Gh(e) {
  let t = 0;
  for (; e.previousSibling; )
    t++, e = e.previousSibling;
  return t;
}
o(Gh, "getOffset");
function gT(e) {
  return e.nodeType === 1;
}
o(gT, "isElement");
function Wh(e) {
  return e.nodeType === 3;
}
o(Wh, "isTextNode");
function Sbe(e, t, r) {
  for (; ; ) {
    var n;
    let i = e[`${t}Sibling`];
    if (i) {
      if (e = _be(i, t === "next" ? "first" : "last"), r(e))
        return e;
    } else if (e.parentNode && (!gT(e.parentNode) || !wt$1(e.parentNode) && e.parentNode !== ((n = e.ownerDocument) === null || n === void 0 ? void 0 : n.body)))
      e = e.parentNode;
    else
      break;
  }
}
o(Sbe, "walkNodes");
function _be(e, t) {
  for (; e.hasChildNodes(); )
    e = e[`${t}Child`];
  return e;
}
o(_be, "getDescendant");
var la = Symbol("Track programmatic changes for React workaround");
function Cbe(e) {
  return Object.getOwnPropertyNames(e).some((t) => t.startsWith("__react")) && Ae(e).REACT_VERSION === 17;
}
o(Cbe, "isReact17Element");
function LB(e) {
  Cbe(e) && (e[la] = {
    previousValue: String(e.value),
    tracked: []
  });
}
o(LB, "startTrackValue");
function FB(e, t) {
  var r, n;
  (n = e[la]) === null || n === void 0 || (r = n.tracked) === null || r === void 0 || r.push(t), e[la] || (sa(e), Yt(e, {
    focusOffset: t.length
  }));
}
o(FB, "trackOrSetValue");
function DB(e, t) {
  var r;
  let n = e[la];
  if (e[la] = void 0, !(!(n == null || (r = n.tracked) === null || r === void 0) && r.length))
    return;
  let i = n.tracked.length === 2 && n.tracked[0] === n.previousValue && n.tracked[1] === e.value;
  i || sa(e), OB(e) && Yt(e, {
    focusOffset: i ? t : e.value.length
  });
}
o(DB, "commitValueAfterInput");
function Kh(e) {
  let t = Pbe(e);
  if (t && $e$1(t))
    return {
      type: "input",
      selection: xr$1(t)
    };
  let r = t?.ownerDocument.getSelection();
  return {
    type: sn$1(e) && r?.anchorNode && sn$1(r.anchorNode) ? "contenteditable" : "default",
    selection: r
  };
}
o(Kh, "getTargetTypeAndSelection");
function Pbe(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
o(Pbe, "getElement");
function $B(e) {
  let t = Kh(e);
  if (t.type === "input")
    return t.selection;
  if (t.type === "contenteditable") {
    var r;
    return (r = t.selection) === null || r === void 0 ? void 0 : r.getRangeAt(0);
  }
}
o($B, "getInputRange");
function Kt({ focusNode: e, focusOffset: t, anchorNode: r = e, anchorOffset: n = t }) {
  var i, s;
  if (Kh(e).type === "input")
    return Yt(e, {
      anchorOffset: n,
      focusOffset: t
    });
  (s = r.ownerDocument) === null || s === void 0 || (i = s.getSelection()) === null || i === void 0 || i.setBaseAndExtent(r, n, e, t);
}
o(Kt, "setSelection");
function HB(e) {
  return X$1(e, "input") && [
    "date",
    "time"
  ].includes(e.type);
}
o(HB, "isDateOrTime");
function Xt(e, t, r, n = "insertText") {
  let i = $B(t);
  i && (!HB(t) && !e.dispatchUIEvent(t, "beforeinput", {
    inputType: n,
    data: r
  }) || ("startContainer" in i ? Abe(e, t, i, r, n) : Obe(e, t, i, r, n)));
}
o(Xt, "input");
function Abe(e, t, r, n, i) {
  let s = false;
  if (!r.collapsed)
    s = true, r.deleteContents();
  else if ([
    "deleteContentBackward",
    "deleteContentForward"
  ].includes(i)) {
    let a = Yh(r.startContainer, r.startOffset, i === "deleteContentBackward" ? -1 : 1, i);
    if (a) {
      s = true;
      let l = r.cloneRange();
      l.comparePoint(a.node, a.offset) < 0 ? l.setStart(a.node, a.offset) : l.setEnd(a.node, a.offset), l.deleteContents();
    }
  }
  if (n)
    if (r.endContainer.nodeType === 3) {
      let a = r.endOffset;
      r.endContainer.insertData(a, n), r.setStart(r.endContainer, a + n.length), r.setEnd(r.endContainer, a + n.length);
    } else {
      let a = t.ownerDocument.createTextNode(n);
      r.insertNode(a), r.setStart(a, n.length), r.setEnd(a, n.length);
    }
  (s || n) && e.dispatchUIEvent(t, "input", {
    inputType: i
  });
}
o(Abe, "editContenteditable");
function Obe(e, t, r, n, i) {
  let s = n;
  if (jB(t)) {
    let c = NB(t);
    if (c !== void 0 && n.length > 0) {
      let d = c - t.value.length;
      if (d > 0)
        s = n.substring(0, d);
      else
        return;
    }
  }
  let { newValue: a, newOffset: l, oldValue: u } = qbe(s, t, r, i);
  a === u && l === r.startOffset && l === r.endOffset || X$1(t, "input", {
    type: "number"
  }) && !Ibe(a) || (CB(t, a), Kt({
    focusNode: t,
    anchorOffset: l,
    focusOffset: l
  }), HB(t) ? bT(t, a) && (BB(e, t, l, {}), e.dispatchUIEvent(t, "change"), Vh(t)) : BB(e, t, l, {
    data: n,
    inputType: i
  }));
}
o(Obe, "editInputElement");
function qbe(e, t, { startOffset: r, endOffset: n }, i) {
  let s = Ge(t), a = Math.max(0, r === n && i === "deleteContentBackward" ? r - 1 : r), l = s.substring(0, a), u = Math.min(s.length, r === n && i === "deleteContentForward" ? r + 1 : n), c = s.substring(u, s.length), d = `${l}${e}${c}`, p = a + e.length;
  if (X$1(t, "input", {
    type: "time"
  })) {
    let f = IB(d);
    f !== "" && bT(t, f) && (d = f, p = f.length);
  }
  return {
    oldValue: s,
    newValue: d,
    newOffset: p
  };
}
o(qbe, "calculateNewValue");
function BB(e, t, r, n) {
  e.dispatchUIEvent(t, "input", n), DB(t, r);
}
o(BB, "commitInput");
function Ibe(e) {
  var t, r;
  let n = e.split("e", 2);
  return !(/[^\d.\-e]/.test(e) || Number((t = e.match(/-/g)) === null || t === void 0 ? void 0 : t.length) > 2 || Number((r = e.match(/\./g)) === null || r === void 0 ? void 0 : r.length) > 1 || n[1] && !/^-?\d*$/.test(n[1]));
}
o(Ibe, "isValidNumberInput");
ut$1.cut = (e, t, r) => () => {
  Wt(t) && Xt(r, t, "", "deleteByCut");
};
function UB(e) {
  return e ? wt$1(e) ? e.textContent : Ge(e) : null;
}
o(UB, "getValueOrTextContent");
function VB(e) {
  let t = Ae(e);
  for (let r = e; r?.ownerDocument; r = r.parentElement) {
    let { display: n, visibility: i } = t.getComputedStyle(r);
    if (n === "none" || i === "hidden")
      return false;
  }
  return true;
}
o(VB, "isVisible");
function zB(e, t) {
  let r = e.ownerDocument, n = r.querySelectorAll($h), i = Array.from(n).filter((u) => u === e || !(Number(u.getAttribute("tabindex")) < 0 || rt(u)));
  Number(e.getAttribute("tabindex")) >= 0 && i.sort((u, c) => {
    let d = Number(u.getAttribute("tabindex")), p = Number(c.getAttribute("tabindex"));
    return d === p ? 0 : d === 0 ? 1 : p === 0 ? -1 : d - p;
  });
  let s = {}, a = [
    r.body
  ], l = X$1(e, "input", {
    type: "radio"
  }) ? e.name : void 0;
  i.forEach((u) => {
    let c = u;
    if (X$1(c, "input", {
      type: "radio"
    }) && c.name) {
      if (c === e) {
        a.push(c);
        return;
      } else if (c.name === l)
        return;
      if (c.checked) {
        a = a.filter((d) => !X$1(d, "input", {
          type: "radio",
          name: c.name
        })), a.push(c), s[c.name] = c;
        return;
      }
      if (typeof s[c.name] < "u")
        return;
    }
    a.push(c);
  });
  for (let u = a.findIndex((c) => c === e); ; )
    if (u += t ? -1 : 1, u === a.length ? u = 0 : u === -1 && (u = a.length - 1), a[u] === e || a[u] === r.body || VB(a[u]))
      return a[u];
}
o(zB, "getTabDestination");
function vT(e, t) {
  if ($e$1(e)) {
    let r = xr$1(e);
    Kt({
      focusNode: e,
      focusOffset: r.startOffset === r.endOffset ? r.focusOffset + t : t < 0 ? r.startOffset : r.endOffset
    });
  } else {
    let r = e.ownerDocument.getSelection();
    if (!r?.focusNode)
      return;
    if (r.isCollapsed) {
      let n = Yh(r.focusNode, r.focusOffset, t);
      n && Kt({
        focusNode: n.node,
        focusOffset: n.offset
      });
    } else
      r[t < 0 ? "collapseToStart" : "collapseToEnd"]();
  }
}
o(vT, "moveSelection");
function Xh(e) {
  if ($e$1(e))
    return Kt({
      focusNode: e,
      anchorOffset: 0,
      focusOffset: Ge(e).length
    });
  var t;
  let r = (t = sn$1(e)) !== null && t !== void 0 ? t : e.ownerDocument.body;
  Kt({
    focusNode: r,
    anchorOffset: 0,
    focusOffset: r.childNodes.length
  });
}
o(Xh, "selectAll");
function GB(e) {
  if ($e$1(e))
    return xr$1(e).startOffset === 0 && xr$1(e).endOffset === Ge(e).length;
  var t;
  let r = (t = sn$1(e)) !== null && t !== void 0 ? t : e.ownerDocument.body, n = e.ownerDocument.getSelection();
  return n?.anchorNode === r && n.focusNode === r && n.anchorOffset === 0 && n.focusOffset === r.childNodes.length;
}
o(GB, "isAllSelected");
function kn(e, t, r) {
  var n;
  if ($e$1(e))
    return Kt({
      focusNode: e,
      anchorOffset: t,
      focusOffset: r
    });
  if (wt$1(e) && ((n = e.firstChild) === null || n === void 0 ? void 0 : n.nodeType) === 3)
    return Kt({
      focusNode: e.firstChild,
      anchorOffset: t,
      focusOffset: r
    });
  throw new Error("Not implemented. The result of this interaction is unreliable.");
}
o(kn, "setSelectionRange");
function ua(e, t, r) {
  let n = Ae(t), i = Array.from(t.ownerDocument.querySelectorAll(t.name ? `input[type="radio"][name="${n.CSS.escape(t.name)}"]` : 'input[type="radio"][name=""], input[type="radio"]:not([name])'));
  for (let s = i.findIndex((a) => a === t) + r; ; s += r) {
    if (i[s] || (s = r > 0 ? 0 : i.length - 1), i[s] === t)
      return;
    if (!rt(i[s])) {
      ht$1(i[s]), e.dispatchUIEvent(i[s], "click");
      return;
    }
  }
}
o(ua, "walkRadio");
ut$1.keydown = (e, t, r) => {
  var n, i;
  return (i = (n = WB[e.key]) === null || n === void 0 ? void 0 : n.call(WB, e, t, r)) !== null && i !== void 0 ? i : Mbe(e, t, r);
};
var WB = {
  ArrowDown: /* @__PURE__ */ o((e, t, r) => {
    if (X$1(t, "input", {
      type: "radio"
    }))
      return () => ua(r, t, 1);
  }, "ArrowDown"),
  ArrowLeft: /* @__PURE__ */ o((e, t, r) => X$1(t, "input", {
    type: "radio"
  }) ? () => ua(r, t, -1) : () => vT(t, -1), "ArrowLeft"),
  ArrowRight: /* @__PURE__ */ o((e, t, r) => X$1(t, "input", {
    type: "radio"
  }) ? () => ua(r, t, 1) : () => vT(t, 1), "ArrowRight"),
  ArrowUp: /* @__PURE__ */ o((e, t, r) => {
    if (X$1(t, "input", {
      type: "radio"
    }))
      return () => ua(r, t, -1);
  }, "ArrowUp"),
  Backspace: /* @__PURE__ */ o((e, t, r) => {
    if (Wt(t))
      return () => {
        Xt(r, t, "", "deleteContentBackward");
      };
  }, "Backspace"),
  Delete: /* @__PURE__ */ o((e, t, r) => {
    if (Wt(t))
      return () => {
        Xt(r, t, "", "deleteContentForward");
      };
  }, "Delete"),
  End: /* @__PURE__ */ o((e, t) => {
    if (X$1(t, [
      "input",
      "textarea"
    ]) || wt$1(t))
      return () => {
        var r, n;
        let i = (n = (r = UB(t)) === null || r === void 0 ? void 0 : r.length) !== null && n !== void 0 ? n : (
          /* istanbul ignore next */
          0
        );
        kn(t, i, i);
      };
  }, "End"),
  Home: /* @__PURE__ */ o((e, t) => {
    if (X$1(t, [
      "input",
      "textarea"
    ]) || wt$1(t))
      return () => {
        kn(t, 0, 0);
      };
  }, "Home"),
  PageDown: /* @__PURE__ */ o((e, t) => {
    if (X$1(t, [
      "input"
    ]))
      return () => {
        let r = Ge(t).length;
        kn(t, r, r);
      };
  }, "PageDown"),
  PageUp: /* @__PURE__ */ o((e, t) => {
    if (X$1(t, [
      "input"
    ]))
      return () => {
        kn(t, 0, 0);
      };
  }, "PageUp"),
  Tab: /* @__PURE__ */ o((e, t, r) => () => {
    let n = zB(t, r.system.keyboard.modifiers.Shift);
    ht$1(n), $e$1(n) && Yt(n, {
      anchorOffset: 0,
      focusOffset: n.value.length
    });
  }, "Tab")
}, Mbe = /* @__PURE__ */ o((e, t, r) => {
  if (e.code === "KeyA" && r.system.keyboard.modifiers.Control)
    return () => Xh(t);
}, "combinationBehavior");
ut$1.keypress = (e, t, r) => {
  if (e.key === "Enter") {
    if (X$1(t, "button") || X$1(t, "input") && Nbe.includes(t.type) || X$1(t, "a") && t.href)
      return () => {
        r.dispatchUIEvent(t, "click");
      };
    if (X$1(t, "input")) {
      let n = t.form, i = n?.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      return i ? () => r.dispatchUIEvent(i, "click") : n && jbe.includes(t.type) && n.querySelectorAll("input").length === 1 ? () => r.dispatchUIEvent(
        n,
        "submit"
      ) : void 0;
    }
  }
  if (Wt(t)) {
    let n = e.key === "Enter" ? wt$1(t) && !r.system.keyboard.modifiers.Shift ? "insertParagraph" : "insertLineBreak" : "insertText", i = e.key === "Enter" ? `
` : e.key;
    return () => Xt(r, t, i, n);
  }
};
var Nbe = [
  "button",
  "color",
  "file",
  "image",
  "reset",
  "submit"
], jbe = [
  "email",
  "month",
  "password",
  "search",
  "tel",
  "text",
  "url",
  "week"
];
ut$1.keyup = (e, t, r) => {
  var n;
  return (n = YB[e.key]) === null || n === void 0 ? void 0 : n.call(YB, e, t, r);
};
var YB = {
  " ": /* @__PURE__ */ o((e, t, r) => {
    if (Hh(t))
      return () => r.dispatchUIEvent(t, "click");
  }, " ")
};
ut$1.paste = (e, t, r) => {
  if (Wt(t))
    return () => {
      var n;
      let i = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.getData("text");
      i && Xt(r, t, i, "insertFromPaste");
    };
};
var ET = {
  auxclick: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  beforeinput: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  click: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  contextmenu: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: false
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  dblclick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  focusin: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  focusout: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  keydown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  keypress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  keyup: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  mousedown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseenter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mouseleave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false,
      composed: true
    }
  },
  mousemove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseout: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseover: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  mouseup: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerover: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerenter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  pointerdown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointermove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerup: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointercancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: false,
      composed: true
    }
  },
  pointerout: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: true,
      cancelable: true,
      composed: true
    }
  },
  pointerleave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: false,
      cancelable: false
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: true,
      cancelable: true
    }
  }
};
function KB(e) {
  return ET[e].EventType;
}
o(KB, "getEventClass");
var kbe = [
  "MouseEvent",
  "PointerEvent"
];
function XB(e) {
  return kbe.includes(KB(e));
}
o(XB, "isMouseEvent");
function JB(e) {
  return KB(e) === "KeyboardEvent";
}
o(JB, "isKeyboardEvent");
var Lbe = {
  ClipboardEvent: [
    Dbe
  ],
  Event: [],
  FocusEvent: [
    ca,
    $be
  ],
  InputEvent: [
    ca,
    Bbe
  ],
  MouseEvent: [
    ca,
    xT,
    QB
  ],
  PointerEvent: [
    ca,
    xT,
    QB,
    Ube
  ],
  KeyboardEvent: [
    ca,
    xT,
    Hbe
  ]
};
function wT(e, t, r) {
  let n = Ae(t), { EventType: i, defaultInit: s } = ET[e], a = new (Fbe(n))[i](e, s);
  return Lbe[i].forEach((l) => l(a, r ?? {})), a;
}
o(wT, "createEvent");
function Fbe(e) {
  var U, N, W, Y, ae, pe, Oe, F, j, K, G, Z, ve, qe, Qe;
  var t;
  let r = (t = e.Event) !== null && t !== void 0 ? t : (U = class {
  }, o(U, "Event"), U);
  var n;
  let i = (n = e.AnimationEvent) !== null && n !== void 0 ? n : (N = class extends r {
  }, o(N, "AnimationEvent"), N);
  var s;
  let a = (s = e.ClipboardEvent) !== null && s !== void 0 ? s : (W = class extends r {
  }, o(W, "ClipboardEvent"), W);
  var l;
  let u = (l = e.PopStateEvent) !== null && l !== void 0 ? l : (Y = class extends r {
  }, o(Y, "PopStateEvent"), Y);
  var c;
  let d = (c = e.ProgressEvent) !== null && c !== void 0 ? c : (ae = class extends r {
  }, o(ae, "ProgressEvent"), ae);
  var p;
  let f = (p = e.TransitionEvent) !== null && p !== void 0 ? p : (pe = class extends r {
  }, o(pe, "TransitionEvent"), pe);
  var m;
  let h = (m = e.UIEvent) !== null && m !== void 0 ? m : (Oe = class extends r {
  }, o(Oe, "UIEvent"), Oe);
  var b;
  let v = (b = e.CompositionEvent) !== null && b !== void 0 ? b : (F = class extends h {
  }, o(F, "CompositionEvent"), F);
  var g;
  let w = (g = e.FocusEvent) !== null && g !== void 0 ? g : (j = class extends h {
  }, o(j, "FocusEvent"), j);
  var E;
  let R = (E = e.InputEvent) !== null && E !== void 0 ? E : (K = class extends h {
  }, o(K, "InputEvent"), K);
  var S;
  let P = (S = e.KeyboardEvent) !== null && S !== void 0 ? S : (G = class extends h {
  }, o(G, "KeyboardEvent"), G);
  var _;
  let C = (_ = e.MouseEvent) !== null && _ !== void 0 ? _ : (Z = class extends h {
  }, o(Z, "MouseEvent"), Z);
  var O;
  let L = (O = e.DragEvent) !== null && O !== void 0 ? O : (ve = class extends C {
  }, o(ve, "DragEvent"), ve);
  var q;
  let D = (q = e.PointerEvent) !== null && q !== void 0 ? q : (qe = class extends C {
  }, o(qe, "PointerEvent"), qe);
  var H;
  let M = (H = e.TouchEvent) !== null && H !== void 0 ? H : (Qe = class extends h {
  }, o(Qe, "TouchEvent"), Qe);
  return {
    Event: r,
    AnimationEvent: i,
    ClipboardEvent: a,
    PopStateEvent: u,
    ProgressEvent: d,
    TransitionEvent: f,
    UIEvent: h,
    CompositionEvent: v,
    FocusEvent: w,
    InputEvent: R,
    KeyboardEvent: P,
    MouseEvent: C,
    DragEvent: L,
    PointerEvent: D,
    TouchEvent: M
  };
}
o(Fbe, "getEventConstructors");
function ln$1(e, t) {
  for (let [r, n] of Object.entries(t))
    Object.defineProperty(e, r, {
      get: /* @__PURE__ */ o(() => n ?? null, "get")
    });
}
o(ln$1, "assignProps");
function Me(e) {
  return Number(e ?? 0);
}
o(Me, "sanitizeNumber");
function Dbe(e, { clipboardData: t }) {
  ln$1(e, {
    clipboardData: t
  });
}
o(Dbe, "initClipboardEvent");
function $be(e, { relatedTarget: t }) {
  ln$1(e, {
    relatedTarget: t
  });
}
o($be, "initFocusEvent");
function Bbe(e, { data: t, inputType: r, isComposing: n }) {
  ln$1(e, {
    data: t,
    isComposing: !!n,
    inputType: String(r)
  });
}
o(Bbe, "initInputEvent");
function ca(e, { view: t, detail: r }) {
  ln$1(e, {
    view: t,
    detail: Me(r ?? 0)
  });
}
o(ca, "initUIEvent");
function xT(e, {
  altKey: t,
  ctrlKey: r,
  metaKey: n,
  shiftKey: i,
  modifierAltGraph: s,
  modifierCapsLock: a,
  modifierFn: l,
  modifierFnLock: u,
  modifierNumLock: c,
  modifierScrollLock: d,
  modifierSymbol: p,
  modifierSymbolLock: f
}) {
  ln$1(e, {
    altKey: !!t,
    ctrlKey: !!r,
    metaKey: !!n,
    shiftKey: !!i,
    getModifierState(m) {
      return !!{
        Alt: t,
        AltGraph: s,
        CapsLock: a,
        Control: r,
        Fn: l,
        FnLock: u,
        Meta: n,
        NumLock: c,
        ScrollLock: d,
        Shift: i,
        Symbol: p,
        SymbolLock: f
      }[m];
    }
  });
}
o(xT, "initUIEventModifiers");
function Hbe(e, { key: t, code: r, location: n, repeat: i, isComposing: s, charCode: a }) {
  ln$1(e, {
    key: String(t),
    code: String(r),
    location: Me(n),
    repeat: !!i,
    isComposing: !!s,
    charCode: a
  });
}
o(Hbe, "initKeyboardEvent");
function QB(e, {
  x: t,
  y: r,
  screenX: n,
  screenY: i,
  clientX: s = t,
  clientY: a = r,
  button: l,
  buttons: u,
  relatedTarget: c,
  offsetX: d,
  offsetY: p,
  pageX: f,
  pageY: m
}) {
  ln$1(e, {
    screenX: Me(n),
    screenY: Me(i),
    clientX: Me(s),
    x: Me(s),
    clientY: Me(a),
    y: Me(a),
    button: Me(l),
    buttons: Me(u),
    relatedTarget: c,
    offsetX: Me(d),
    offsetY: Me(p),
    pageX: Me(f),
    pageY: Me(m)
  });
}
o(QB, "initMouseEvent");
function Ube(e, { pointerId: t, width: r, height: n, pressure: i, tangentialPressure: s, tiltX: a, tiltY: l, twist: u, pointerType: c, isPrimary: d }) {
  ln$1(e, {
    pointerId: Me(t),
    width: Me(r ?? 1),
    height: Me(n ?? 1),
    pressure: Me(i),
    tangentialPressure: Me(s),
    tiltX: Me(a),
    tiltY: Me(l),
    twist: Me(u),
    pointerType: String(c),
    isPrimary: !!d
  });
}
o(Ube, "initPointerEvent");
function ZB(e, t, r, n = false) {
  (XB(t) || JB(t)) && (r = {
    ...r,
    ...this.system.getUIEventModifiers()
  });
  let i = wT(t, e, r);
  return TT.call(this, e, i, n);
}
o(ZB, "dispatchUIEvent");
function TT(e, t, r = false) {
  var n;
  let i = t.type, s = r ? () => {
  } : (n = ut$1[i]) === null || n === void 0 ? void 0 : n.call(ut$1, t, e, this);
  if (s) {
    t.preventDefault();
    let a = false;
    return Object.defineProperty(t, "defaultPrevented", {
      get: /* @__PURE__ */ o(() => a, "get")
    }), Object.defineProperty(t, "preventDefault", {
      value: /* @__PURE__ */ o(() => {
        a = t.cancelable;
      }, "value")
    }), an$1(() => e.dispatchEvent(t)), a || s(), !a;
  }
  return an$1(() => e.dispatchEvent(t));
}
o(TT, "dispatchEvent");
function wr$1(e, t, r) {
  let n = wT(t, e, r);
  an$1(() => e.dispatchEvent(n));
}
o(wr$1, "dispatchDOMEvent");
var e2 = Symbol("patched focus/blur methods");
function RT(e) {
  if (e.prototype[e2])
    return;
  let { focus: t, blur: r } = e.prototype;
  Object.defineProperties(e.prototype, {
    focus: {
      configurable: true,
      get: /* @__PURE__ */ o(() => i, "get")
    },
    blur: {
      configurable: true,
      get: /* @__PURE__ */ o(() => s, "get")
    },
    [e2]: {
      configurable: true,
      get: /* @__PURE__ */ o(() => ({
        focus: t,
        blur: r
      }), "get")
    }
  });
  let n;
  function i(a) {
    if (this.ownerDocument.visibilityState !== "hidden")
      return t.call(this, a);
    let l = t2(this.ownerDocument);
    if (l === this)
      return;
    let u = Symbol("focus call");
    n = u, l && (r.call(l), wr$1(l, "blur", {
      relatedTarget: this
    }), wr$1(l, "focusout", {
      relatedTarget: n === u ? this : null
    })), n === u && (t.call(this, a), wr$1(this, "focus", {
      relatedTarget: l
    })), n === u && wr$1(this, "focusin", {
      relatedTarget: l
    });
  }
  o(i, "patchedFocus");
  function s() {
    if (this.ownerDocument.visibilityState !== "hidden")
      return r.call(this);
    let a = t2(this.ownerDocument);
    if (a !== this)
      return;
    n = Symbol("blur call"), r.call(this), wr$1(a, "blur", {
      relatedTarget: null
    }), wr$1(a, "focusout", {
      relatedTarget: null
    });
  }
  o(s, "patchedBlur");
}
o(RT, "patchFocus");
function t2(e) {
  let t = jn(e);
  return t?.tagName === "BODY" ? null : t;
}
o(t2, "getActiveTarget");
var ST = Symbol("Interceptor for programmatical calls");
function si(e, t, r) {
  let n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), i = Object.getOwnPropertyDescriptor(e, t), s = n?.set ? "set" : "value";
  if (typeof n?.[s] != "function" || n[s][ST])
    throw new Error(`Element ${e.tagName} does not implement "${String(t)}".`);
  function a(...l) {
    let { applyNative: u = false, realArgs: c, then: d } = r.call(this, ...l), p = (!u && i || n)[s];
    s === "set" ? p.call(this, c) : p.call(this, ...c), d?.();
  }
  o(a, "intercept"), a[ST] = ST, Object.defineProperty(e, t, {
    ...i ?? n,
    [s]: a
  });
}
o(si, "prepareInterceptor");
function r2(e) {
  si(e, "value", /* @__PURE__ */ o(function(r) {
    let n = SB(r);
    return n && LB(this), {
      applyNative: !!n,
      realArgs: Vbe(this, r),
      then: n ? void 0 : () => FB(this, String(r))
    };
  }, "interceptorImpl"));
}
o(r2, "prepareValueInterceptor");
function Vbe(e, t) {
  return X$1(e, "input", {
    type: "number"
  }) && String(t) !== "" && !Number.isNaN(Number(t)) ? String(Number(t)) : String(t);
}
o(Vbe, "sanitizeValue");
function n2(e) {
  si(e, "setSelectionRange", /* @__PURE__ */ o(function(r, ...n) {
    let i = _B(r);
    return {
      applyNative: !!i,
      realArgs: [
        Number(r),
        ...n
      ],
      then: /* @__PURE__ */ o(() => i ? void 0 : aa$1(e), "then")
    };
  }, "interceptorImpl")), si(e, "selectionStart", /* @__PURE__ */ o(function(r) {
    return {
      realArgs: r,
      then: /* @__PURE__ */ o(() => aa$1(e), "then")
    };
  }, "interceptorImpl")), si(e, "selectionEnd", /* @__PURE__ */ o(function(r) {
    return {
      realArgs: r,
      then: /* @__PURE__ */ o(() => aa$1(e), "then")
    };
  }, "interceptorImpl")), si(e, "select", /* @__PURE__ */ o(function() {
    return {
      realArgs: [],
      then: /* @__PURE__ */ o(() => AB(e, {
        anchorOffset: 0,
        focusOffset: Ge(e).length
      }), "then")
    };
  }, "interceptorImpl"));
}
o(n2, "prepareSelectionInterceptor");
function o2(e) {
  si(e, "setRangeText", /* @__PURE__ */ o(function(...r) {
    return {
      realArgs: r,
      then: /* @__PURE__ */ o(() => {
        sa(e), aa$1(e);
      }, "then")
    };
  }, "interceptorImpl"));
}
o(o2, "prepareRangeTextInterceptor");
var ai = Symbol("Node prepared with document state workarounds");
function _T(e) {
  e[ai] || (e.addEventListener("focus", (t) => {
    let r = t.target;
    i2(r);
  }, {
    capture: true,
    passive: true
  }), e.activeElement && i2(e.activeElement), e.addEventListener("blur", (t) => {
    let r = t.target, n = PB(r);
    n !== void 0 && (r.value !== n && wr$1(r, "change"), Vh(r));
  }, {
    capture: true,
    passive: true
  }), e[ai] = ai);
}
o(_T, "prepareDocument");
function i2(e) {
  e[ai] || (X$1(e, [
    "input",
    "textarea"
  ]) && (r2(e), n2(e), o2(e)), e[ai] = ai);
}
o(i2, "prepareElement");
function s2(e) {
  return zbe(e) ? e : e.ownerDocument;
}
o(s2, "getDocumentFromNode");
function zbe(e) {
  return e.nodeType === 9;
}
o(zbe, "isDocument");
var nt = /* @__PURE__ */ function(e) {
  return e[e.Trigger = 2] = "Trigger", e[e.Call = 1] = "Call", e;
}({});
function Ln(e, t) {
  e.levelRefs[t] = {};
}
o(Ln, "setLevelRef");
function da(e, t) {
  return e.levelRefs[t];
}
o(da, "getLevelRef");
function ir(e) {
  let t = e.delay;
  if (typeof t == "number")
    return Promise.all([
      new Promise((r) => globalThis.setTimeout(() => r(), t)),
      e.advanceTimers(t)
    ]);
}
o(ir, "wait");
var Fn = /* @__PURE__ */ function(e) {
  return e[e.EachTrigger = 4] = "EachTrigger", e[e.EachApiCall = 2] = "EachApiCall", e[e.EachTarget = 1] = "EachTarget", e[e.Never = 0] = "Never", e;
}({});
function Dn(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = r, e;
}
o(Dn, "_define_property");
var Jt$1 = /* @__PURE__ */ function(e) {
  return e[e.STANDARD = 0] = "STANDARD", e[e.LEFT = 1] = "LEFT", e[e.RIGHT = 2] = "RIGHT", e[e.NUMPAD = 3] = "NUMPAD", e;
}({}), Gbe = [
  "Alt",
  "AltGraph",
  "Control",
  "Fn",
  "Meta",
  "Shift",
  "Symbol"
];
function a2(e) {
  return Gbe.includes(e);
}
o(a2, "isModifierKey");
var Wbe = [
  "CapsLock",
  "FnLock",
  "NumLock",
  "ScrollLock",
  "SymbolLock"
];
function l2(e) {
  return Wbe.includes(e);
}
o(l2, "isModifierLock");
var CT = class CT2 {
  isKeyPressed(t) {
    return this.pressed.has(String(t.code));
  }
  getPressedKeys() {
    return this.pressed.values().map((t) => t.keyDef);
  }
  /** Press a key */
  async keydown(t, r) {
    let n = String(r.key), i = String(r.code), s = Bh(t.config.document);
    this.setKeydownTarget(s), this.pressed.add(i, r), a2(n) && (this.modifiers[n] = true);
    let a = t.dispatchUIEvent(s, "keydown", {
      key: n,
      code: i
    });
    l2(n) && !this.modifiers[n] && (this.modifiers[n] = true, this.modifierLockStart[n] = true), a && this.pressed.setUnprevented(i), a && this.hasKeyPress(n) && t.dispatchUIEvent(Bh(t.config.document), "keypress", {
      key: n,
      code: i,
      charCode: r.key === "Enter" ? 13 : String(r.key).charCodeAt(0)
    });
  }
  /** Release a key */
  async keyup(t, r) {
    let n = String(r.key), i = String(r.code), s = this.pressed.isUnprevented(i);
    this.pressed.delete(i), a2(n) && !this.pressed.values().find((a) => a.keyDef.key === n) && (this.modifiers[n] = false), t.dispatchUIEvent(Bh(
      t.config.document
    ), "keyup", {
      key: n,
      code: i
    }, !s), l2(n) && this.modifiers[n] && (this.modifierLockStart[n] ? this.modifierLockStart[n] = false : this.modifiers[n] = false);
  }
  setKeydownTarget(t) {
    t !== this.lastKeydownTarget && (this.carryChar = ""), this.lastKeydownTarget = t;
  }
  hasKeyPress(t) {
    return (t.length === 1 || t === "Enter") && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(t) {
    Dn(this, "system", void 0), Dn(this, "modifiers", {
      Alt: false,
      AltGraph: false,
      CapsLock: false,
      Control: false,
      Fn: false,
      FnLock: false,
      Meta: false,
      NumLock: false,
      ScrollLock: false,
      Shift: false,
      Symbol: false,
      SymbolLock: false
    }), Dn(this, "pressed", new class {
      add(r, n) {
        var i, s, a;
        (a = (i = this.registry)[s = r]) !== null && a !== void 0 || (i[s] = {
          keyDef: n,
          unpreventedDefault: false
        });
      }
      has(r) {
        return !!this.registry[r];
      }
      setUnprevented(r) {
        let n = this.registry[r];
        n && (n.unpreventedDefault = true);
      }
      isUnprevented(r) {
        var n;
        return !!(!((n = this.registry[r]) === null || n === void 0) && n.unpreventedDefault);
      }
      delete(r) {
        delete this.registry[r];
      }
      values() {
        return Object.values(this.registry);
      }
      constructor() {
        Dn(this, "registry", {});
      }
    }()), Dn(this, "carryChar", ""), Dn(this, "lastKeydownTarget", void 0), Dn(this, "modifierLockStart", {}), this.system = t;
  }
};
o(CT, "KeyboardHost");
var Jh = CT;
var u2 = [
  // alphanumeric block - writing system
  ..."0123456789".split("").map((e) => ({
    code: `Digit${e}`,
    key: e
  })),
  ...")!@#$%^&*(".split("").map((e, t) => ({
    code: `Digit${t}`,
    key: e,
    shiftKey: true
  })),
  ..."abcdefghijklmnopqrstuvwxyz".split("").map((e) => ({
    code: `Key${e.toUpperCase()}`,
    key: e
  })),
  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").map((e) => ({
    code: `Key${e}`,
    key: e,
    shiftKey: true
  })),
  {
    code: "BracketLeft",
    key: "["
  },
  {
    code: "BracketLeft",
    key: "{",
    shiftKey: true
  },
  {
    code: "BracketRight",
    key: "]"
  },
  {
    code: "BracketRight",
    key: "}",
    shiftKey: true
  },
  // alphanumeric block - functional
  {
    code: "Space",
    key: " "
  },
  {
    code: "AltLeft",
    key: "Alt",
    location: Jt$1.LEFT
  },
  {
    code: "AltRight",
    key: "Alt",
    location: Jt$1.RIGHT
  },
  {
    code: "ShiftLeft",
    key: "Shift",
    location: Jt$1.LEFT
  },
  {
    code: "ShiftRight",
    key: "Shift",
    location: Jt$1.RIGHT
  },
  {
    code: "ControlLeft",
    key: "Control",
    location: Jt$1.LEFT
  },
  {
    code: "ControlRight",
    key: "Control",
    location: Jt$1.RIGHT
  },
  {
    code: "MetaLeft",
    key: "Meta",
    location: Jt$1.LEFT
  },
  {
    code: "MetaRight",
    key: "Meta",
    location: Jt$1.RIGHT
  },
  {
    code: "OSLeft",
    key: "OS",
    location: Jt$1.LEFT
  },
  {
    code: "OSRight",
    key: "OS",
    location: Jt$1.RIGHT
  },
  {
    code: "ContextMenu",
    key: "ContextMenu"
  },
  {
    code: "Tab",
    key: "Tab"
  },
  {
    code: "CapsLock",
    key: "CapsLock"
  },
  {
    code: "Backspace",
    key: "Backspace"
  },
  {
    code: "Enter",
    key: "Enter"
  },
  // function
  {
    code: "Escape",
    key: "Escape"
  },
  // arrows
  {
    code: "ArrowUp",
    key: "ArrowUp"
  },
  {
    code: "ArrowDown",
    key: "ArrowDown"
  },
  {
    code: "ArrowLeft",
    key: "ArrowLeft"
  },
  {
    code: "ArrowRight",
    key: "ArrowRight"
  },
  // control pad
  {
    code: "Home",
    key: "Home"
  },
  {
    code: "End",
    key: "End"
  },
  {
    code: "Delete",
    key: "Delete"
  },
  {
    code: "PageUp",
    key: "PageUp"
  },
  {
    code: "PageDown",
    key: "PageDown"
  },
  // Special keys that are not part of a default US-layout but included for specific behavior
  {
    code: "Fn",
    key: "Fn"
  },
  {
    code: "Symbol",
    key: "Symbol"
  },
  {
    code: "AltRight",
    key: "AltGraph"
  }
];
var c2 = [
  {
    name: "MouseLeft",
    pointerType: "mouse",
    button: "primary"
  },
  {
    name: "MouseRight",
    pointerType: "mouse",
    button: "secondary"
  },
  {
    name: "MouseMiddle",
    pointerType: "mouse",
    button: "auxiliary"
  },
  {
    name: "TouchA",
    pointerType: "touch"
  },
  {
    name: "TouchB",
    pointerType: "touch"
  },
  {
    name: "TouchC",
    pointerType: "touch"
  }
];
function Ybe(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = r, e;
}
o(Ybe, "_define_property");
var AT = class AT2 {
  getButtons() {
    let t = 0;
    for (let r of Object.keys(this.pressed))
      t |= 2 ** Number(r);
    return t;
  }
  down(t) {
    let r = PT(t.button);
    if (r in this.pressed) {
      this.pressed[r].push(t);
      return;
    }
    return this.pressed[r] = [
      t
    ], r;
  }
  up(t) {
    let r = PT(t.button);
    if (r in this.pressed && (this.pressed[r] = this.pressed[r].filter((n) => n.name !== t.name), this.pressed[r].length === 0))
      return delete this.pressed[r], r;
  }
  constructor() {
    Ybe(this, "pressed", {});
  }
};
o(AT, "Buttons");
var li = AT, d2 = {
  primary: 0,
  secondary: 1,
  auxiliary: 2,
  back: 3,
  X1: 3,
  forward: 4,
  X2: 4
};
function PT(e = 0) {
  return e in d2 ? d2[e] : Number(e);
}
o(PT, "getMouseButtonId");
var p2 = {
  1: 2,
  2: 1
};
function pa(e) {
  return e = PT(e), e in p2 ? p2[e] : e;
}
o(pa, "getMouseEventButton");
function Kbe(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = r, e;
}
o(Kbe, "_define_property");
var OT = class OT2 {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(t) {
    return this.pressedKeys.has(t.name);
  }
  addPressed(t) {
    return this.pressedKeys.add(t.name);
  }
  removePressed(t) {
    return this.pressedKeys.delete(t.name);
  }
  constructor() {
    Kbe(this, "pressedKeys", /* @__PURE__ */ new Set());
  }
};
o(OT, "Device");
var Qh = OT;
function $n(e, t) {
  let r = [];
  for (let s = e; s; s = s.parentElement)
    r.push(s);
  let n = [];
  for (let s = t; s; s = s.parentElement)
    n.push(s);
  let i = 0;
  for (; !(i >= r.length || i >= n.length || r[r.length - 1 - i] !== n[n.length - 1 - i]); i++)
    ;
  return [
    r.slice(0, r.length - i),
    n.slice(0, n.length - i),
    n.slice(n.length - i)
  ];
}
o($n, "getTreeDiff");
function fa({ target: e, node: t, offset: r }) {
  return $e$1(e) ? {
    node: e,
    offset: r ?? Ge(e).length
  } : t ? {
    node: t,
    offset: r ?? (t.nodeType === 3 ? t.nodeValue.length : t.childNodes.length)
  } : f2(e, r);
}
o(fa, "resolveCaretPosition");
function f2(e, t, r = true) {
  let n = t === void 0 ? e.childNodes.length - 1 : 0, i = t === void 0 ? -1 : 1;
  for (; t === void 0 ? n >= (r ? Math.max(e.childNodes.length - 1, 0) : 0) : n <= e.childNodes.length; ) {
    if (t && n === e.childNodes.length)
      throw new Error("The given offset is out of bounds.");
    let s = e.childNodes.item(n), a = String(s.textContent);
    if (a.length)
      if (t !== void 0 && a.length < t)
        t -= a.length;
      else {
        if (s.nodeType === 1)
          return f2(s, t, false);
        if (s.nodeType === 3)
          return {
            node: s,
            offset: t ?? s.nodeValue.length
          };
      }
    n += i;
  }
  return {
    node: e,
    offset: e.childNodes.length
  };
}
o(f2, "findNodeAtTextOffset");
function m2({ document: e, target: t, clickCount: r, node: n, offset: i }) {
  if (xB(t))
    return;
  let s = $e$1(t), a = String(s ? Ge(t) : t.textContent), [l, u] = n ? (
    // which elements might be considered in the same line of text.
    // TODO: support expanding initial range on multiple clicks if node is given
    [
      i,
      i
    ]
  ) : Xbe(a, i, r);
  if (s)
    return Yt(t, {
      anchorOffset: l ?? a.length,
      focusOffset: u ?? a.length
    }), {
      node: t,
      start: l ?? 0,
      end: u ?? a.length
    };
  {
    let { node: c, offset: d } = fa({
      target: t,
      node: n,
      offset: l
    }), { node: p, offset: f } = fa({
      target: t,
      node: n,
      offset: u
    }), m = t.ownerDocument.createRange();
    try {
      m.setStart(c, d), m.setEnd(p, f);
    } catch {
      throw new Error("The given offset is out of bounds.");
    }
    let h = e.getSelection();
    return h?.removeAllRanges(), h?.addRange(m.cloneRange()), m;
  }
}
o(m2, "setSelectionPerMouseDown");
function Xbe(e, t, r) {
  if (r % 3 === 1 || e.length === 0)
    return [
      t,
      t
    ];
  let n = t ?? e.length;
  return r % 3 === 2 ? [
    n - e.substr(0, t).match(/(\w+|\s+|\W)?$/)[0].length,
    t === void 0 ? t : t + e.substr(t).match(/^(\w+|\s+|\W)?/)[0].length
  ] : [
    n - e.substr(0, t).match(/[^\r\n]*$/)[0].length,
    t === void 0 ? t : t + e.substr(t).match(/^[^\r\n]*/)[0].length
  ];
}
o(Xbe, "getTextRange");
function h2(e, { document: t, target: r, node: n, offset: i }) {
  let s = fa({
    target: r,
    node: n,
    offset: i
  });
  if ("node" in e) {
    if (s.node === e.node) {
      let a = s.offset < e.start ? e.end : e.start, l = s.offset > e.end || s.offset < e.start ? s.offset : e.end;
      Yt(e.node, {
        anchorOffset: a,
        focusOffset: l
      });
    }
  } else {
    let a = e.cloneRange(), l = a.comparePoint(s.node, s.offset);
    l < 0 ? a.setStart(s.node, s.offset) : l > 0 && a.setEnd(s.node, s.offset);
    let u = t.getSelection();
    u?.removeAllRanges(), u?.addRange(a.cloneRange());
  }
}
o(h2, "modifySelectionPerMouseMove");
function Zh(e, t) {
  var r, n, i, s, a, l, u, c, d, p, f, m, h, b, v, g, w, E, R, S, P, _, C, O;
  return e.target !== t.target || ((r = e.coords) === null || r === void 0 ? void 0 : r.x) !== ((n = t.coords) === null || n === void 0 ? void 0 : n.x) || ((i = e.coords) === null || i === void 0 ? void 0 : i.y) !== ((s = t.coords) === null || s === void 0 ? void 0 : s.y) || ((a = e.coords) === null || a === void 0 ? void 0 : a.clientX) !== ((l = t.coords) === null || l === void 0 ? void 0 : l.clientX) || ((u = e.coords) === null || u === void 0 ? void 0 : u.clientY) !== ((c = t.coords) === null || c === void 0 ? void 0 : c.clientY) || ((d = e.coords) === null || d === void 0 ? void 0 : d.offsetX) !== ((p = t.coords) === null || p === void 0 ? void 0 : p.offsetX) || ((f = e.coords) === null || f === void 0 ? void 0 : f.offsetY) !== ((m = t.coords) === null || m === void 0 ? void 0 : m.offsetY) || ((h = e.coords) === null || h === void 0 ? void 0 : h.pageX) !== ((b = t.coords) === null || b === void 0 ? void 0 : b.pageX) || ((v = e.coords) === null || v === void 0 ? void 0 : v.pageY) !== ((g = t.coords) === null || g === void 0 ? void 0 : g.pageY) || ((w = e.coords) === null || w === void 0 ? void 0 : w.screenX) !== ((E = t.coords) === null || E === void 0 ? void 0 : E.screenX) || ((R = e.coords) === null || R === void 0 ? void 0 : R.screenY) !== ((S = t.coords) === null || S === void 0 ? void 0 : S.screenY) || ((P = e.caret) === null || P === void 0 ? void 0 : P.node) !== ((_ = t.caret) === null || _ === void 0 ? void 0 : _.node) || ((C = e.caret) === null || C === void 0 ? void 0 : C.offset) !== ((O = t.caret) === null || O === void 0 ? void 0 : O.offset);
}
o(Zh, "isDifferentPointerPosition");
function Bn(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = r, e;
}
o(Bn, "_define_property");
var qT = class qT2 {
  move(t, r, n) {
    let i = this.position, s = this.getTarget(t);
    if (this.position = r, !Zh(i, r))
      return;
    let a = this.getTarget(t), l = this.getEventInit("mousemove"), [u, c] = $n(s, a);
    return {
      leave: /* @__PURE__ */ o(() => {
        s !== a && (t.dispatchUIEvent(s, "mouseout", l), u.forEach((d) => t.dispatchUIEvent(d, "mouseleave", l)));
      }, "leave"),
      enter: /* @__PURE__ */ o(() => {
        s !== a && (t.dispatchUIEvent(a, "mouseover", l), c.forEach((d) => t.dispatchUIEvent(d, "mouseenter", l)));
      }, "enter"),
      move: /* @__PURE__ */ o(() => {
        n || (t.dispatchUIEvent(a, "mousemove", l), this.modifySelecting(t));
      }, "move")
    };
  }
  down(t, r, n) {
    let i = this.buttons.down(r);
    if (i === void 0)
      return;
    let s = this.getTarget(t);
    this.buttonDownTarget[i] = s;
    let a = this.getEventInit("mousedown", r.button), l = rt(s);
    !n && (l || t.dispatchUIEvent(s, "mousedown", a)) && (this.startSelecting(t, a.detail), ht$1(s)), !l && pa(r.button) === 2 && t.dispatchUIEvent(
      s,
      "contextmenu",
      this.getEventInit("contextmenu", r.button)
    );
  }
  up(t, r, n) {
    let i = this.buttons.up(r);
    if (i === void 0)
      return;
    let s = this.getTarget(t);
    if (!rt(s)) {
      if (!n) {
        let l = this.getEventInit("mouseup", r.button);
        t.dispatchUIEvent(s, "mouseup", l), this.endSelecting();
      }
      let a = $n(this.buttonDownTarget[i], s)[2][0];
      if (a) {
        let l = this.getEventInit("click", r.button);
        l.detail && (t.dispatchUIEvent(a, l.button === 0 ? "click" : "auxclick", l), l.button === 0 && l.detail === 2 && t.dispatchUIEvent(
          a,
          "dblclick",
          {
            ...this.getEventInit("dblclick", r.button),
            detail: l.detail
          }
        ));
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(t, r) {
    let n = {
      ...this.position.coords
    };
    return n.button = pa(r), n.buttons = this.buttons.getButtons(), t === "mousedown" ? n.detail = this.clickCount.getOnDown(n.button) : t === "mouseup" ? n.detail = this.clickCount.getOnUp(n.button) : (t === "click" || t === "auxclick") && (n.detail = this.clickCount.incOnClick(
      n.button
    )), n;
  }
  getTarget(t) {
    var r;
    return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  startSelecting(t, r) {
    var n, i;
    this.selecting = m2({
      document: t.config.document,
      target: this.getTarget(t),
      node: (n = this.position.caret) === null || n === void 0 ? void 0 : n.node,
      offset: (i = this.position.caret) === null || i === void 0 ? void 0 : i.offset,
      clickCount: r
    });
  }
  modifySelecting(t) {
    var r, n;
    this.selecting && h2(this.selecting, {
      document: t.config.document,
      target: this.getTarget(t),
      node: (r = this.position.caret) === null || r === void 0 ? void 0 : r.node,
      offset: (n = this.position.caret) === null || n === void 0 ? void 0 : n.offset
    });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    Bn(this, "position", {}), Bn(this, "buttons", new li()), Bn(this, "selecting", void 0), Bn(this, "buttonDownTarget", {}), Bn(this, "clickCount", new class {
      incOnClick(t) {
        let r = this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
        return this.count = this.count[t] === void 0 ? {} : {
          [t]: Number(this.count[t]) + 1
        }, r;
      }
      getOnDown(t) {
        var r;
        this.down = {
          [t]: (r = this.count[t]) !== null && r !== void 0 ? r : 0
        };
        var n;
        return this.count = {
          [t]: (n = this.count[t]) !== null && n !== void 0 ? n : 0
        }, Number(this.count[t]) + 1;
      }
      getOnUp(t) {
        return this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
      }
      reset() {
        this.count = {};
      }
      constructor() {
        Bn(this, "down", {}), Bn(this, "count", {});
      }
    }());
  }
};
o(qT, "Mouse");
var ey = qT;
function ui(e, t) {
  var r;
  return ((r = g2(e, t)) === null || r === void 0 ? void 0 : r.pointerEvents) !== "none";
}
o(ui, "hasPointerEvents");
function Jbe(e) {
  let t = Ae(e);
  for (let r = e, n = []; r?.ownerDocument; r = r.parentElement) {
    n.push(r);
    let i = t.getComputedStyle(r).pointerEvents;
    if (i && ![
      "inherit",
      "unset"
    ].includes(i))
      return {
        pointerEvents: i,
        tree: n
      };
  }
}
o(Jbe, "closestPointerEventsDeclaration");
var y2 = Symbol("Last check for pointer-events");
function g2(e, t) {
  let r = t[y2];
  if (!(e.config.pointerEventsCheck !== Fn.Never && (!r || b2(e.config.pointerEventsCheck, Fn.EachApiCall) && r[nt.Call] !== da(e, nt.Call) || b2(e.config.pointerEventsCheck, Fn.EachTrigger) && r[nt.Trigger] !== da(e, nt.Trigger))))
    return r?.result;
  let i = Jbe(t);
  return t[y2] = {
    [nt.Call]: da(e, nt.Call),
    [nt.Trigger]: da(e, nt.Trigger),
    result: i
  }, i;
}
o(g2, "checkPointerEvents");
function Hn(e, t) {
  let r = g2(e, t);
  if (r?.pointerEvents === "none")
    throw new Error([
      `Unable to perform pointer interaction as the element ${r.tree.length > 1 ? "inherits" : "has"} \`pointer-events: none\`:`,
      "",
      Qbe(r.tree)
    ].join(`
`));
}
o(Hn, "assertPointerEvents");
function Qbe(e) {
  return e.reverse().map((t, r) => [
    "".padEnd(r),
    t.tagName,
    t.id && `#${t.id}`,
    t.hasAttribute("data-testid") && `(testId=${t.getAttribute("data-testid")})`,
    Zbe(t),
    e.length > 1 && r === 0 && "  <-- This element declared `pointer-events: none`",
    e.length > 1 && r === e.length - 1 && "  <-- Asserted pointer events here"
  ].filter(Boolean).join("")).join(`
`);
}
o(Qbe, "printTree");
function Zbe(e) {
  var t;
  let r;
  if (e.hasAttribute("aria-label"))
    r = e.getAttribute("aria-label");
  else if (e.hasAttribute("aria-labelledby")) {
    var n, i;
    r = (i = e.ownerDocument.getElementById(e.getAttribute("aria-labelledby"))) === null || i === void 0 || (n = i.textContent) === null || n === void 0 ? void 0 : n.trim();
  } else if (X$1(e, [
    "button",
    "input",
    "meter",
    "output",
    "progress",
    "select",
    "textarea"
  ]) && (!((t = e.labels) === null || t === void 0) && t.length))
    r = Array.from(e.labels).map((a) => {
      var l;
      return (l = a.textContent) === null || l === void 0 ? void 0 : l.trim();
    }).join("|");
  else if (X$1(e, "button")) {
    var s;
    r = (s = e.textContent) === null || s === void 0 ? void 0 : s.trim();
  }
  return r = r?.replace(/\n/g, "  "), Number(r?.length) > 30 && (r = `${r?.substring(0, 29)}`), r ? `(label=${r})` : "";
}
o(Zbe, "getLabelDescr");
function b2(e, t) {
  return (e & t) > 0;
}
o(b2, "hasBitFlag");
function Tr$1(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = r, e;
}
o(Tr$1, "_define_property");
var IT = class IT2 {
  init(t) {
    let r = this.getTarget(t), [, n] = $n(null, r), i = this.getEventInit();
    return Hn(t, r), t.dispatchUIEvent(r, "pointerover", i), n.forEach((s) => t.dispatchUIEvent(s, "pointerenter", i)), this;
  }
  move(t, r) {
    let n = this.position, i = this.getTarget(t);
    if (this.position = r, !Zh(n, r))
      return;
    let s = this.getTarget(t), a = this.getEventInit(-1), [l, u] = $n(i, s);
    return {
      leave: /* @__PURE__ */ o(() => {
        ui(t, i) && i !== s && (t.dispatchUIEvent(i, "pointerout", a), l.forEach((c) => t.dispatchUIEvent(c, "pointerleave", a)));
      }, "leave"),
      enter: /* @__PURE__ */ o(() => {
        Hn(t, s), i !== s && (t.dispatchUIEvent(s, "pointerover", a), u.forEach((c) => t.dispatchUIEvent(c, "pointerenter", a)));
      }, "enter"),
      move: /* @__PURE__ */ o(() => {
        t.dispatchUIEvent(s, "pointermove", a);
      }, "move")
    };
  }
  down(t, r = 0) {
    if (this.isDown)
      return;
    let n = this.getTarget(t);
    Hn(t, n), this.isDown = true, this.isPrevented = !t.dispatchUIEvent(n, "pointerdown", this.getEventInit(r));
  }
  up(t, r = 0) {
    if (!this.isDown)
      return;
    let n = this.getTarget(t);
    Hn(t, n), this.isPrevented = false, this.isDown = false, t.dispatchUIEvent(n, "pointerup", this.getEventInit(r));
  }
  release(t) {
    let r = this.getTarget(t), [n] = $n(r, null), i = this.getEventInit();
    ui(t, r) && (t.dispatchUIEvent(r, "pointerout", i), n.forEach((s) => t.dispatchUIEvent(s, "pointerleave", i))), this.isCancelled = true;
  }
  getTarget(t) {
    var r;
    return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  getEventInit(t) {
    return {
      ...this.position.coords,
      pointerId: this.pointerId,
      pointerType: this.pointerType,
      isPrimary: this.isPrimary,
      button: pa(t),
      buttons: this.buttons.getButtons()
    };
  }
  constructor({ pointerId: t, pointerType: r, isPrimary: n }, i) {
    Tr$1(this, "pointerId", void 0), Tr$1(this, "pointerType", void 0), Tr$1(this, "isPrimary", void 0), Tr$1(this, "buttons", void 0), Tr$1(this, "isMultitouch", false), Tr$1(this, "isCancelled", false), Tr$1(this, "isDown", false), Tr$1(this, "isPrevented", false), Tr$1(this, "position", {}), this.pointerId = t, this.pointerType = r, this.isPrimary = n, this.isMultitouch = !n, this.buttons = i;
  }
};
o(IT, "Pointer");
var ty = IT;
function un$1(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = r, e;
}
o(un$1, "_define_property");
var MT = class MT2 {
  isKeyPressed(t) {
    return this.devices.get(t.pointerType).isPressed(t);
  }
  async press(t, r, n) {
    this.devices.get(r.pointerType).addPressed(r), this.buttons.down(r);
    let i = this.getPointerName(r), s = r.pointerType === "touch" ? this.pointers.new(i, r.pointerType, this.buttons) : this.pointers.get(i);
    s.position = n, s.pointerType !== "touch" && (this.mouse.position = n), s.pointerType === "touch" && s.init(t), s.down(t, r.button), s.pointerType !== "touch" && this.mouse.down(t, r, s.isPrevented);
  }
  async move(t, r, n) {
    let i = this.pointers.get(r), s = i.move(t, n), a = i.pointerType === "touch" ? void 0 : this.mouse.move(t, n, i.isPrevented);
    s?.leave(), a?.leave(), s?.enter(), a?.enter(), s?.move(), a?.move();
  }
  async release(t, r, n) {
    let i = this.devices.get(r.pointerType);
    i.removePressed(r), this.buttons.up(r);
    let s = this.pointers.get(this.getPointerName(r)), a = s.isPrevented;
    if (s.position = n, s.pointerType !== "touch" && (this.mouse.position = n), i.countPressed === 0 && s.up(t, r.button), s.pointerType === "touch" && s.release(t), s.pointerType === "touch" && !s.isMultitouch) {
      let l = this.mouse.move(t, n, a);
      l?.leave(), l?.enter(), l?.move(), this.mouse.down(t, r, a);
    }
    if (!s.isMultitouch) {
      let l = this.mouse.move(t, n, a);
      l?.leave(), l?.enter(), l?.move(), this.mouse.up(t, r, a);
    }
  }
  getPointerName(t) {
    return t.pointerType === "touch" ? t.name : t.pointerType;
  }
  getPreviousPosition(t) {
    return this.pointers.has(t) ? this.pointers.get(t).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(t) {
    var r;
    return (r = this.mouse.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  setMousePosition(t) {
    this.mouse.position = t, this.pointers.get("mouse").position = t;
  }
  constructor(t) {
    un$1(this, "system", void 0), un$1(this, "mouse", void 0), un$1(this, "buttons", void 0), un$1(this, "devices", new class {
      get(r) {
        var n, i, s;
        return (s = (n = this.registry)[i = r]) !== null && s !== void 0 ? s : n[i] = new Qh();
      }
      constructor() {
        un$1(this, "registry", {});
      }
    }()), un$1(this, "pointers", new class {
      new(r, n, i) {
        let s = n !== "touch" || !Object.values(this.registry).some((a) => a.pointerType === "touch" && !a.isCancelled);
        return s || Object.values(this.registry).forEach((a) => {
          a.pointerType === n && !a.isCancelled && (a.isMultitouch = true);
        }), this.registry[r] = new ty({
          pointerId: this.nextId++,
          pointerType: n,
          isPrimary: s
        }, i), this.registry[r];
      }
      get(r) {
        if (!this.has(r))
          throw new Error(`Trying to access pointer "${r}" which does not exist.`);
        return this.registry[r];
      }
      has(r) {
        return r in this.registry;
      }
      constructor() {
        un$1(this, "registry", {}), un$1(this, "nextId", 1);
      }
    }()), this.system = t, this.buttons = new li(), this.mouse = new ey(), this.pointers.new("mouse", "mouse", this.buttons);
  }
};
o(MT, "PointerHost");
var ry = MT;
function v2(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = r, e;
}
o(v2, "_define_property");
var NT = class NT2 {
  getUIEventModifiers() {
    return {
      altKey: this.keyboard.modifiers.Alt,
      ctrlKey: this.keyboard.modifiers.Control,
      metaKey: this.keyboard.modifiers.Meta,
      shiftKey: this.keyboard.modifiers.Shift,
      modifierAltGraph: this.keyboard.modifiers.AltGraph,
      modifierCapsLock: this.keyboard.modifiers.CapsLock,
      modifierFn: this.keyboard.modifiers.Fn,
      modifierFnLock: this.keyboard.modifiers.FnLock,
      modifierNumLock: this.keyboard.modifiers.NumLock,
      modifierScrollLock: this.keyboard.modifiers.ScrollLock,
      modifierSymbol: this.keyboard.modifiers.Symbol,
      modifierSymbolLock: this.keyboard.modifiers.SymbolLock
    };
  }
  constructor() {
    v2(this, "keyboard", new Jh(this)), v2(this, "pointer", new ry(this));
  }
};
o(NT, "System");
var ma = NT;
async function E2(e) {
  let t = [];
  return this.config.skipHover || t.push({
    target: e
  }), t.push({
    keys: "[MouseLeft]",
    target: e
  }), this.pointer(t);
}
o(E2, "click");
async function x2(e) {
  return this.pointer([
    {
      target: e
    },
    "[MouseLeft][MouseLeft]"
  ]);
}
o(x2, "dblClick");
async function w2(e) {
  return this.pointer([
    {
      target: e
    },
    "[MouseLeft][MouseLeft][MouseLeft]"
  ]);
}
o(w2, "tripleClick");
async function T2(e) {
  return this.pointer({
    target: e
  });
}
o(T2, "hover");
async function R2(e) {
  return Hn(this, this.system.pointer.getMouseTarget(this)), this.pointer({
    target: e.ownerDocument.body
  });
}
o(R2, "unhover");
async function S2({ shift: e } = {}) {
  return this.keyboard(e === true ? "{Shift>}{Tab}{/Shift}" : e === false ? "[/ShiftLeft][/ShiftRight]{Tab}" : "{Tab}");
}
o(S2, "tab");
var jT = /* @__PURE__ */ function(e) {
  return e["{"] = "}", e["["] = "]", e;
}(jT || {});
function ny(e, t) {
  let r = 0, n = e[r] in jT ? e[r] : "";
  r += n.length;
  let s = new RegExp(`^\\${n}{2}`).test(e) ? "" : n;
  return {
    type: s,
    ...s === "" ? ege(e, r, t) : tge(e, r, s, t)
  };
}
o(ny, "readNextDescriptor");
function ege(e, t, r) {
  let n = e[t];
  return _2(n, e, t, r), t += n.length, {
    consumedLength: t,
    descriptor: n,
    releasePrevious: false,
    releaseSelf: true,
    repeat: 1
  };
}
o(ege, "readPrintableChar");
function tge(e, t, r, n) {
  var i, s;
  let a = e[t] === "/" ? "/" : "";
  t += a.length;
  let l = r === "{" && e[t] === "\\";
  t += Number(l);
  let u = l ? e[t] : (i = e.slice(t).match(r === "{" ? /^\w+|^[^}>/]/ : /^\w+/)) === null || i === void 0 ? void 0 : i[0];
  _2(u, e, t, n), t += u.length;
  var c;
  let d = (c = (s = e.slice(t).match(/^>\d+/)) === null || s === void 0 ? void 0 : s[0]) !== null && c !== void 0 ? c : "";
  t += d.length;
  let p = e[t] === "/" || !d && e[t] === ">" ? e[t] : "";
  t += p.length;
  let f = jT[r], m = e[t] === f ? f : "";
  if (!m)
    throw new Error(C2([
      !d && "repeat modifier",
      !p && "release modifier",
      `"${f}"`
    ].filter(Boolean).join(" or "), e[t], e, n));
  return t += m.length, {
    consumedLength: t,
    descriptor: u,
    releasePrevious: !!a,
    repeat: d ? Math.max(Number(d.substr(1)), 1) : 1,
    releaseSelf: rge(p, d)
  };
}
o(tge, "readTag");
function _2(e, t, r, n) {
  if (!e)
    throw new Error(C2("key descriptor", t[r], t, n));
}
o(_2, "assertDescriptor");
function rge(e, t) {
  if (e)
    return e === "/";
  if (t)
    return false;
}
o(rge, "hasReleaseSelf");
function C2(e, t, r, n) {
  return `Expected ${e} but found "${t ?? ""}" in "${r}"
    See ${n === "pointer" ? "https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen" : "https://testing-library.com/docs/user-event/keyboard"}
    for more information about how userEvent parses your input.`;
}
o(C2, "getErrorMessage");
function P2(e, t) {
  let r = [];
  do {
    let { type: i, descriptor: s, consumedLength: a, releasePrevious: l, releaseSelf: u = true, repeat: c } = ny(t, "keyboard");
    var n;
    let d = (n = e.find((p) => {
      if (i === "[") {
        var f;
        return ((f = p.code) === null || f === void 0 ? void 0 : f.toLowerCase()) === s.toLowerCase();
      } else if (i === "{") {
        var m;
        return ((m = p.key) === null || m === void 0 ? void 0 : m.toLowerCase()) === s.toLowerCase();
      }
      return p.key === s;
    })) !== null && n !== void 0 ? n : {
      key: "Unknown",
      code: "Unknown",
      [i === "[" ? "code" : "key"]: s
    };
    r.push({
      keyDef: d,
      releasePrevious: l,
      releaseSelf: u,
      repeat: c
    }), t = t.slice(a);
  } while (t);
  return r;
}
o(P2, "parseKeyDef");
async function A2(e) {
  let t = P2(this.config.keyboardMap, e);
  for (let r = 0; r < t.length; r++)
    await ir(this.config), await nge(this, t[r]);
}
o(A2, "keyboard");
async function nge(e, { keyDef: t, releasePrevious: r, releaseSelf: n, repeat: i }) {
  let { system: s } = e;
  if (s.keyboard.isKeyPressed(t) && await s.keyboard.keyup(e, t), !r) {
    for (let a = 1; a <= i; a++)
      await s.keyboard.keydown(e, t), a < i && await ir(e.config);
    n && await s.keyboard.keyup(e, t);
  }
}
o(nge, "keyboardAction");
async function O2(e) {
  for (let t of e.system.keyboard.getPressedKeys())
    await e.system.keyboard.keyup(e, t);
}
o(O2, "releaseAllKeys");
function oy(e) {
  let t = $e$1(e) ? {
    "text/plain": oge(e)
  } : {
    "text/plain": String(e.ownerDocument.getSelection())
  }, r = ni(Ae(e));
  for (let n in t)
    t[n] && r.setData(n, t[n]);
  return r;
}
o(oy, "copySelection");
function oge(e) {
  let t = xr$1(e);
  return Ge(e).substring(t.startOffset, t.endOffset);
}
o(oge, "readSelectedValueFromInput");
async function q2() {
  let e = this.config.document;
  var t;
  let r = (t = e.activeElement) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  ), n = oy(r);
  if (n.items.length !== 0)
    return this.dispatchUIEvent(r, "copy", {
      clipboardData: n
    }) && this.config.writeToClipboard && await Dh(e, n), n;
}
o(q2, "copy");
async function I2() {
  let e = this.config.document;
  var t;
  let r = (t = e.activeElement) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  ), n = oy(r);
  if (n.items.length !== 0)
    return this.dispatchUIEvent(r, "cut", {
      clipboardData: n
    }) && this.config.writeToClipboard && await Dh(r.ownerDocument, n), n;
}
o(I2, "cut");
async function M2(e) {
  let t = this.config.document;
  var r;
  let n = (r = t.activeElement) !== null && r !== void 0 ? r : (
    /* istanbul ignore next */
    t.body
  );
  var i;
  let s = (i = typeof e == "string" ? ige(t, e) : e) !== null && i !== void 0 ? i : await yB(t).catch(() => {
    throw new Error("`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.");
  });
  this.dispatchUIEvent(n, "paste", {
    clipboardData: s
  });
}
o(M2, "paste");
function ige(e, t) {
  let r = ni(Ae(e));
  return r.setData("text", t), r;
}
o(ige, "getClipboardDataFromString");
function kT(e, t) {
  let r = [];
  do {
    let { descriptor: n, consumedLength: i, releasePrevious: s, releaseSelf: a = true } = ny(t, "pointer"), l = e.find((u) => u.name === n);
    l && r.push({
      keyDef: l,
      releasePrevious: s,
      releaseSelf: a
    }), t = t.slice(i);
  } while (t);
  return r;
}
o(kT, "parseKeyDef");
async function j2(e) {
  let { pointerMap: t } = this.config, r = [];
  (Array.isArray(e) ? e : [
    e
  ]).forEach((n) => {
    typeof n == "string" ? r.push(...kT(t, n)) : "keys" in n ? r.push(...kT(t, n.keys).map((i) => ({
      ...n,
      ...i
    }))) : r.push(n);
  });
  for (let n = 0; n < r.length; n++)
    await ir(this.config), await sge(this, r[n]);
  this.system.pointer.resetClickCount();
}
o(j2, "pointer");
async function sge(e, t) {
  var r, n;
  let i = "pointerName" in t && t.pointerName ? t.pointerName : "keyDef" in t ? e.system.pointer.getPointerName(t.keyDef) : "mouse", s = e.system.pointer.getPreviousPosition(i);
  var a, l, u, c;
  let d = {
    target: (a = t.target) !== null && a !== void 0 ? a : age(e, s),
    coords: (l = t.coords) !== null && l !== void 0 ? l : s?.coords,
    caret: {
      node: (u = t.node) !== null && u !== void 0 ? u : N2(t) || s == null || (r = s.caret) === null || r === void 0 ? void 0 : r.node,
      offset: (c = t.offset) !== null && c !== void 0 ? c : N2(t) || s == null || (n = s.caret) === null || n === void 0 ? void 0 : n.offset
    }
  };
  "keyDef" in t ? (e.system.pointer.isKeyPressed(t.keyDef) && (Ln(e, nt.Trigger), await e.system.pointer.release(e, t.keyDef, d)), t.releasePrevious || (Ln(e, nt.Trigger), await e.system.pointer.press(e, t.keyDef, d), t.releaseSelf && (Ln(e, nt.Trigger), await e.system.pointer.release(e, t.keyDef, d)))) : (Ln(e, nt.Trigger), await e.system.pointer.move(e, i, d));
}
o(sge, "pointerAction");
function N2(e) {
  var t, r;
  return !!((r = (t = e.target) !== null && t !== void 0 ? t : e.node) !== null && r !== void 0 ? r : e.offset !== void 0);
}
o(N2, "hasCaretPosition");
function age(e, t) {
  if (!t)
    throw new Error("This pointer has no previous position. Provide a target property!");
  var r;
  return (r = t.target) !== null && r !== void 0 ? r : e.config.document.body;
}
o(age, "getPrevTarget");
async function k2(e) {
  if (!Wt(e) || rt(e))
    throw new Error("clear()` is only supported on editable elements.");
  if (ht$1(e), e.ownerDocument.activeElement !== e)
    throw new Error("The element to be cleared could not be focused.");
  if (Xh(e), !GB(e))
    throw new Error("The element content to be cleared could not be selected.");
  Xt(this, e, "", "deleteContentBackward");
}
o(k2, "clear");
async function L2(e, t) {
  return D2.call(this, true, e, t);
}
o(L2, "selectOptions");
async function F2(e, t) {
  return D2.call(this, false, e, t);
}
o(F2, "deselectOptions");
async function D2(e, t, r) {
  if (!e && !t.multiple)
    throw ie$1().getElementError("Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.", t);
  let n = Array.isArray(r) ? r : [
    r
  ], i = Array.from(t.querySelectorAll('option, [role="option"]')), s = n.map((l) => {
    if (typeof l != "string" && i.includes(l))
      return l;
    {
      let u = i.find((c) => c.value === l || c.innerHTML === l);
      if (u)
        return u;
      throw ie$1().getElementError(`Value "${String(l)}" not found in options`, t);
    }
  }).filter((l) => !rt(l));
  if (rt(t) || !s.length) return;
  let a = /* @__PURE__ */ o((l) => {
    l.selected = e, this.dispatchUIEvent(t, "input", {
      bubbles: true,
      cancelable: false,
      composed: true
    }), this.dispatchUIEvent(t, "change");
  }, "selectOption");
  if (X$1(t, "select"))
    if (t.multiple)
      for (let l of s) {
        let u = this.config.pointerEventsCheck === 0 ? true : ui(this, l);
        u && (this.dispatchUIEvent(l, "pointerover"), this.dispatchUIEvent(t, "pointerenter"), this.dispatchUIEvent(l, "mouseover"), this.dispatchUIEvent(
          t,
          "mouseenter"
        ), this.dispatchUIEvent(l, "pointermove"), this.dispatchUIEvent(l, "mousemove"), this.dispatchUIEvent(l, "pointerdown"), this.dispatchUIEvent(l, "mousedown")), ht$1(t), u && (this.dispatchUIEvent(l, "pointerup"), this.dispatchUIEvent(l, "mouseup")), a(l), u && this.dispatchUIEvent(l, "click"), await ir(this.config);
      }
    else if (s.length === 1) {
      let l = this.config.pointerEventsCheck === 0 ? true : ui(this, t);
      l ? await this.click(t) : ht$1(t), a(s[0]), l && (this.dispatchUIEvent(t, "pointerover"), this.dispatchUIEvent(t, "pointerenter"), this.dispatchUIEvent(t, "mouseover"), this.dispatchUIEvent(t, "mouseenter"), this.dispatchUIEvent(t, "pointerup"), this.dispatchUIEvent(t, "mouseup"), this.dispatchUIEvent(t, "click")), await ir(this.config);
    } else
      throw ie$1().getElementError("Cannot select multiple options on a non-multiple select", t);
  else if (t.getAttribute("role") === "listbox")
    for (let l of s)
      await this.click(l), await this.unhover(l);
  else
    throw ie$1().getElementError("Cannot select options on elements that are neither select nor listbox elements", t);
}
o(D2, "selectOptionsBase");
async function $2(e, t, { skipClick: r = this.config.skipClick, skipAutoClose: n = this.config.skipAutoClose, initialSelectionStart: i, initialSelectionEnd: s } = {}) {
  e.disabled || (r || await this.click(e), i !== void 0 && kn(e, i, s ?? i), await this.keyboard(t), n || await O2(this));
}
o($2, "type");
var B2 = Symbol("files and value properties are mocked");
function LT(e, t, r) {
  r ? Object.defineProperty(e, t, r) : delete e[t];
}
o(LT, "restoreProperty");
function H2(e, t) {
  var r;
  (r = e[B2]) === null || r === void 0 || r.restore();
  let n = Object.getOwnPropertyDescriptor(e, "type"), i = Object.getOwnPropertyDescriptor(e, "value"), s = Object.getOwnPropertyDescriptor(
    e,
    "files"
  );
  function a() {
    LT(e, "type", n), LT(e, "value", i), LT(e, "files", s);
  }
  o(a, "restore"), e[B2] = {
    restore: a
  }, Object.defineProperties(e, {
    files: {
      configurable: true,
      get: /* @__PURE__ */ o(() => t, "get")
    },
    value: {
      configurable: true,
      get: /* @__PURE__ */ o(() => t.length ? `C:\\fakepath\\${t[0].name}` : "", "get"),
      set(l) {
        if (l === "")
          a();
        else {
          var u;
          i == null || (u = i.set) === null || u === void 0 || u.call(e, l);
        }
      }
    },
    type: {
      configurable: true,
      get: /* @__PURE__ */ o(() => "file", "get"),
      set(l) {
        l !== "file" && (a(), e.type = l);
      }
    }
  });
}
o(H2, "setFiles");
async function U2(e, t) {
  let r = X$1(e, "label") ? e.control : e;
  if (!r || !X$1(r, "input", {
    type: "file"
  }))
    throw new TypeError(`The ${r === e ? "given" : "associated"} ${r?.tagName} element does not accept file uploads`);
  if (rt(e)) return;
  let n = (Array.isArray(t) ? t : [
    t
  ]).filter((s) => !this.config.applyAccept || lge(s, r.accept)).slice(0, r.multiple ? void 0 : 1), i = /* @__PURE__ */ o(() => {
    var s;
    n.length === ((s = r.files) === null || s === void 0 ? void 0 : s.length) && n.every((a, l) => {
      var u;
      return a === ((u = r.files) === null || u === void 0 ? void 0 : u.item(l));
    }) || (H2(r, oa(Ae(e), n)), this.dispatchUIEvent(r, "input"), this.dispatchUIEvent(r, "change"));
  }, "fileDialog");
  r.addEventListener("fileDialog", i), await this.click(e), r.removeEventListener("fileDialog", i);
}
o(U2, "upload");
function iy(e) {
  return e.toLowerCase().replace(/(\.|\/)jpg\b/g, "$1jpeg");
}
o(iy, "normalize");
function lge(e, t) {
  if (!t)
    return true;
  let r = [
    "audio/*",
    "image/*",
    "video/*"
  ];
  return iy(t).trim().split(/\s*,\s*/).some((n) => n.startsWith(".") ? iy(e.name).endsWith(n) : r.includes(n) ? iy(e.type).startsWith(n.replace(
    "*",
    ""
  )) : iy(e.type) === n);
}
o(lge, "isAcceptableFile");
var FT = {
  click: E2,
  dblClick: x2,
  tripleClick: w2,
  hover: T2,
  unhover: R2,
  tab: S2,
  keyboard: A2,
  copy: q2,
  cut: I2,
  paste: M2,
  pointer: j2,
  clear: k2,
  deselectOptions: F2,
  selectOptions: L2,
  type: $2,
  upload: U2
};
function V2(e) {
  return ie$1().asyncWrapper(e);
}
o(V2, "wrapAsync");
var z2 = {
  applyAccept: true,
  autoModify: true,
  delay: 0,
  document: globalThis.document,
  keyboardMap: u2,
  pointerMap: c2,
  pointerEventsCheck: Fn.EachApiCall,
  skipAutoClose: false,
  skipClick: false,
  skipHover: false,
  writeToClipboard: false,
  advanceTimers: /* @__PURE__ */ o(() => Promise.resolve(), "advanceTimers")
}, uge = {
  ...z2,
  writeToClipboard: true
};
function G2(e = {}, t = uge, r) {
  let n = pge(e, r, t);
  return {
    ...t,
    ...e,
    document: n
  };
}
o(G2, "createConfig");
function W2(e = {}) {
  let t = G2(e);
  _T(t.document), RT(Ae(t.document).HTMLElement);
  var r;
  let n = (r = t.document.defaultView) !== null && r !== void 0 ? r : (
    /* istanbul ignore next */
    globalThis.window
  );
  return hB(n), DT(t).api;
}
o(W2, "setupMain");
function Je({ keyboardState: e, pointerState: t, ...r } = {}, n) {
  let i = G2(r, z2, n);
  _T(i.document), RT(Ae(i.document).HTMLElement);
  var s;
  let a = (s = t ?? e) !== null && s !== void 0 ? s : new ma();
  return {
    api: DT(i, a).api,
    system: a
  };
}
o(Je, "setupDirect");
function cge(e) {
  return DT({
    ...this.config,
    ...e
  }, this.system).api;
}
o(cge, "setupSub");
function dge(e, t) {
  function r(...n) {
    return Ln(e, nt.Call), V2(() => t.apply(e, n).then(async (i) => (await ir(e.config), i)));
  }
  return o(r, "method"), Object.defineProperty(r, "name", {
    get: /* @__PURE__ */ o(() => t.name, "get")
  }), r;
}
o(dge, "wrapAndBindImpl");
function DT(e, t = new ma()) {
  let r = {};
  return Object.assign(r, {
    config: e,
    dispatchEvent: TT.bind(r),
    dispatchUIEvent: ZB.bind(r),
    system: t,
    levelRefs: {},
    ...FT
  }), {
    instance: r,
    api: {
      ...Object.fromEntries(Object.entries(FT).map(([n, i]) => [
        n,
        dge(r, i)
      ])),
      setup: cge.bind(r)
    }
  };
}
o(DT, "createInstance");
function pge(e, t, r) {
  var n, i;
  return (i = (n = e.document) !== null && n !== void 0 ? n : t && s2(t)) !== null && i !== void 0 ? i : r.document;
}
o(pge, "getDocument");
var $T = {};
st$1($T, {
  clear: () => fge,
  click: () => mge,
  copy: () => hge,
  cut: () => yge,
  dblClick: () => bge,
  deselectOptions: () => gge,
  hover: () => vge,
  keyboard: () => Ege,
  paste: () => wge,
  pointer: () => xge,
  selectOptions: () => Tge,
  tab: () => Pge,
  tripleClick: () => Rge,
  type: () => Sge,
  unhover: () => _ge,
  upload: () => Cge
});
function fge(e) {
  return Je().api.clear(e);
}
o(fge, "clear");
function mge(e, t = {}) {
  return Je(t, e).api.click(e);
}
o(mge, "click");
function hge(e = {}) {
  return Je(e).api.copy();
}
o(hge, "copy");
function yge(e = {}) {
  return Je(e).api.cut();
}
o(yge, "cut");
function bge(e, t = {}) {
  return Je(t).api.dblClick(e);
}
o(bge, "dblClick");
function gge(e, t, r = {}) {
  return Je(r).api.deselectOptions(e, t);
}
o(gge, "deselectOptions");
function vge(e, t = {}) {
  return Je(t).api.hover(e);
}
o(vge, "hover");
async function Ege(e, t = {}) {
  let { api: r, system: n } = Je(t);
  return r.keyboard(e).then(() => n);
}
o(Ege, "keyboard");
async function xge(e, t = {}) {
  let { api: r, system: n } = Je(t);
  return r.pointer(e).then(() => n);
}
o(xge, "pointer");
function wge(e, t) {
  return Je(t).api.paste(e);
}
o(wge, "paste");
function Tge(e, t, r = {}) {
  return Je(r).api.selectOptions(e, t);
}
o(Tge, "selectOptions");
function Rge(e, t = {}) {
  return Je(t).api.tripleClick(e);
}
o(Rge, "tripleClick");
function Sge(e, t, r = {}) {
  return Je(r, e).api.type(e, t, r);
}
o(Sge, "type");
function _ge(e, t = {}) {
  let { api: r, system: n } = Je(t);
  return n.pointer.setMousePosition({
    target: e
  }), r.unhover(e);
}
o(_ge, "unhover");
function Cge(e, t, r = {}) {
  return Je(r).api.upload(e, t);
}
o(Cge, "upload");
function Pge(e = {}) {
  return Je().api.tab(e);
}
o(Pge, "tab");
var ha = {
  ...$T,
  setup: W2
};
var BT = rr(
  { ...cT },
  {
    intercept: /* @__PURE__ */ o((e, t) => t[0] === "fireEvent" || e.startsWith("find") || e.startsWith("waitFor"), "intercept")
  }
);
BT.screen = new Proxy(BT.screen, {
  get(e, t, r) {
    return be.warn(mS`
          You are using Testing Library's \`screen\` object. Use \`within(canvasElement)\` instead.
          More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error
        `), Reflect.get(e, t, r);
  }
});
var {
  buildQueries: Oge,
  configure: qge,
  createEvent: Ige,
  fireEvent: Mge,
  findAllByAltText: Nge,
  findAllByDisplayValue: jge,
  findAllByLabelText: kge,
  findAllByPlaceholderText: Lge,
  findAllByRole: Fge,
  findAllByTestId: Dge,
  findAllByText: $ge,
  findAllByTitle: Bge,
  findByAltText: Hge,
  findByDisplayValue: Uge,
  findByLabelText: Vge,
  findByPlaceholderText: zge,
  findByRole: Gge,
  findByTestId: Wge,
  findByText: Yge,
  findByTitle: Kge,
  getAllByAltText: Xge,
  getAllByDisplayValue: Jge,
  getAllByLabelText: Qge,
  getAllByPlaceholderText: Zge,
  getAllByRole: eve,
  getAllByTestId: tve,
  getAllByText: rve,
  getAllByTitle: nve,
  getByAltText: ove,
  getByDisplayValue: ive,
  getByLabelText: sve,
  getByPlaceholderText: ave,
  getByRole: lve,
  getByTestId: uve,
  getByText: cve,
  getByTitle: dve,
  getConfig: pve,
  getDefaultNormalizer: fve,
  getElementError: mve,
  getNodeText: hve,
  getQueriesForElement: yve,
  getRoles: bve,
  getSuggestedQuery: gve,
  isInaccessible: vve,
  logDOM: Eve,
  logRoles: xve,
  prettyDOM: wve,
  queries: Tve,
  queryAllByAltText: Rve,
  queryAllByAttribute: Sve,
  queryAllByDisplayValue: _ve,
  queryAllByLabelText: Cve,
  queryAllByPlaceholderText: Pve,
  queryAllByRole: Ave,
  queryAllByTestId: Ove,
  queryAllByText: qve,
  queryAllByTitle: Ive,
  queryByAltText: Mve,
  queryByAttribute: Nve,
  queryByDisplayValue: jve,
  queryByLabelText: kve,
  queryByPlaceholderText: Lve,
  queryByRole: Fve,
  queryByTestId: Dve,
  queryByText: $ve,
  queryByTitle: Bve,
  queryHelpers: Hve,
  screen: Uve,
  waitFor: Vve,
  waitForElementToBeRemoved: zve,
  within: HT,
  prettyFormat: Gve
} = BT, UT = ha, { userEvent: Wve } = rr(
  { userEvent: ha },
  { intercept: true }
);
var { expect: Yve } = rr(
  { expect: sw },
  {
    getKeys: /* @__PURE__ */ o((e, t) => {
      if ("constructor" in e && e.constructor === T$1) {
        let r = ["assert", "__methods", "__flags", "_obj"], n = Object.keys(Object.getPrototypeOf(e)).filter(
          (i) => !r.includes(i)
        );
        return t > 2 ? n : [...n, "not"];
      }
      return "any" in e ? Object.keys(e).filter((r) => r !== "any") : Object.keys(e);
    }, "getKeys"),
    mutate: true,
    intercept: /* @__PURE__ */ o((e) => e !== "expect", "intercept")
  }
), Kve = {
  mock: /* @__PURE__ */ o(() => {
  }, "mock")
};
var Y2 = false, Xve = /* @__PURE__ */ o((e) => {
  let { parameters: t } = e;
  t?.actions?.disable || Y2 || (lw((r, n) => {
    let i = r.getMockName();
    i !== "spy" && (!/^next\/.*::/.test(i) || [
      "next/router::useRouter()",
      "next/navigation::useRouter()",
      "next/navigation::redirect",
      "next/cache::",
      "next/headers::cookies().set",
      "next/headers::cookies().delete",
      "next/headers::headers().set",
      "next/headers::headers().delete"
    ].some((s) => i.startsWith(s))) && Ir(i)(n);
  }), Y2 = true);
}, "logActionsWhenMockCalled"), Jve = [Xve];
var GT = /* @__PURE__ */ o(() => ({
  ...bg,
  ...zT
}), "default");
var ci = "backgrounds";
var K2 = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
};
var { document: Qt } = globalThis, X2 = /* @__PURE__ */ o(() => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : false, "isReduceMotionEnabled"), WT = /* @__PURE__ */ o((e) => {
  (Array.isArray(e) ? e : [e]).forEach(Zve);
}, "clearStyles"), Zve = /* @__PURE__ */ o((e) => {
  if (!Qt)
    return;
  let t = Qt.getElementById(e);
  t && t.parentElement && t.parentElement.removeChild(t);
}, "clearStyle"), J22 = /* @__PURE__ */ o((e, t) => {
  if (!Qt)
    return;
  let r = Qt.getElementById(e);
  if (r)
    r.innerHTML !== t && (r.innerHTML = t);
  else {
    let n = Qt.createElement("style");
    n.setAttribute("id", e), n.innerHTML = t, Qt.head.appendChild(n);
  }
}, "addGridStyle"), Q2 = /* @__PURE__ */ o((e, t, r) => {
  if (!Qt)
    return;
  let n = Qt.getElementById(e);
  if (n)
    n.innerHTML !== t && (n.innerHTML = t);
  else {
    let i = Qt.createElement("style");
    i.setAttribute("id", e), i.innerHTML = t;
    let s = `addon-backgrounds-grid${r ? `-docs-${r}` : ""}`, a = Qt.getElementById(s);
    a ? a.parentElement?.insertBefore(i, a) : Qt.head.appendChild(i);
  }
}, "addBackgroundStyle");
var eEe = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
}, Z2 = "addon-backgrounds", eH = "addon-backgrounds-grid", tEe = X2() ? "" : "transition: background-color 0.3s;", tH = /* @__PURE__ */ o((e, t) => {
  let { globals: r = {}, parameters: n = {}, viewMode: i, id: s } = t, {
    options: a = K2,
    disable: l,
    grid: u = eEe
  } = n[ci] || {}, c = r[ci] || {}, d = typeof c == "string" ? c : c?.value, p = d ? a[d] : void 0, f = typeof p == "string" ? p : p?.value || "transparent", m = typeof c == "string" ? false : c.grid || false, h = !!p && !l, b = i === "docs" ? `#anchor--${s} .docs-story` : ".sb-show-main", v = i === "docs" ? `#anchor--${s} .docs-story` : ".sb-show-main", g = n.layout === void 0 || n.layout === "padded", w = i === "docs" ? 20 : g ? 16 : 0, { cellAmount: E, cellSize: R, opacity: S, offsetX: P = w, offsetY: _ = w } = u, C = i === "docs" ? `${Z2}-docs-${s}` : `${Z2}-color`, O = i === "docs" ? s : null;
  kt$1(() => {
    let q = `
    ${b} {
      background: ${f} !important;
      ${tEe}
      }`;
    if (!h) {
      WT(C);
      return;
    }
    Q2(C, q, O);
  }, [b, C, O, h, f]);
  let L = i === "docs" ? `${eH}-docs-${s}` : `${eH}`;
  return kt$1(() => {
    if (!m) {
      WT(L);
      return;
    }
    let q = [
      `${R * E}px ${R * E}px`,
      `${R * E}px ${R * E}px`,
      `${R}px ${R}px`,
      `${R}px ${R}px`
    ].join(", "), D = `
        ${v} {
          background-size: ${q} !important;
          background-position: ${P}px ${_}px, ${P}px ${_}px, ${P}px ${_}px, ${P}px ${_}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${S}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${S}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${S / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${S / 2}) 1px, transparent 1px) !important;
        }
      `;
    J22(L, D);
  }, [E, R, v, L, m, P, _, S]), e();
}, "withBackgroundAndGrid");
var rEe = globalThis.FEATURES?.backgrounds ? [tH] : [], nEe = {
  [ci]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: false
  }
}, oEe = {
  [ci]: { value: void 0, grid: false }
}, YT = /* @__PURE__ */ o(() => ({
  decorators: rEe,
  parameters: nEe,
  initialGlobals: oEe
}), "default");
var { step: iEe } = rr(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: /* @__PURE__ */ o(async (e, t, r) => t(r), "step")
  },
  { intercept: true }
), KT = /* @__PURE__ */ o(() => ({
  parameters: {
    throwPlayFunctionExceptions: false
  },
  runStep: iEe
}), "default");
var sy = "storybook/highlight", rH = `${sy}/add`, nH = `${sy}/remove`, oH = `${sy}/reset`, iH = `${sy}/scroll-into-view`, XT = 2147483647, sr = 28;
var JT = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
};
var sEe = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(","), Le$1 = /* @__PURE__ */ o((e, t = {}, r) => {
  let n = sEe.includes(e) ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e);
  return Object.entries(t).forEach(([i, s]) => {
    /[A-Z]/.test(i) ? (i === "onClick" && (n.addEventListener("click", s), n.addEventListener("keydown", (a) => {
      (a.key === "Enter" || a.key === " ") && (a.preventDefault(), s());
    })), i === "onMouseEnter" && n.addEventListener("mouseenter", s), i === "onMouseLeave" && n.addEventListener("mouseleave", s)) : n.setAttribute(
      i,
      s
    );
  }), r?.forEach((i) => {
    if (!(i == null || i === false))
      try {
        n.appendChild(i);
      } catch {
        n.appendChild(document.createTextNode(String(i)));
      }
  }), n;
}, "createElement"), ba = /* @__PURE__ */ o((e) => JT[e] && Le$1(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  JT[e].map(
    (t) => Le$1("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: t
    })
  )
), "createIcon"), sH = /* @__PURE__ */ o((e) => {
  if ("elements" in e) {
    let { elements: n, color: i, style: s } = e;
    return {
      id: void 0,
      priority: 0,
      selectors: n,
      styles: {
        outline: `2px ${s} ${i}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  let { menu: t, ...r } = e;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...r,
    menu: Array.isArray(t) ? t.every(Array.isArray) ? t : [t] : void 0
  };
}, "normalizeOptions"), aEe = /* @__PURE__ */ o((e) => e instanceof Function, "isFunction"), ya$1 = /* @__PURE__ */ new Map(), Un = /* @__PURE__ */ new Map(), ay = /* @__PURE__ */ new Map(), ar = /* @__PURE__ */ o((e) => {
  let t = Symbol();
  return Un.set(t, []), ya$1.set(t, e), { get: /* @__PURE__ */ o(() => ya$1.get(t), "get"), set: /* @__PURE__ */ o((a) => {
    let l = ya$1.get(t), u = aEe(a) ? a(l) : a;
    u !== l && (ya$1.set(t, u), Un.get(t)?.forEach((c) => {
      ay.get(c)?.(), ay.set(c, c(u));
    }));
  }, "set"), subscribe: /* @__PURE__ */ o((a) => (Un.get(t)?.push(a), () => {
    let l = Un.get(t);
    l && Un.set(
      t,
      l.filter((u) => u !== a)
    );
  }), "subscribe"), teardown: /* @__PURE__ */ o(() => {
    Un.get(t)?.forEach((a) => {
      ay.get(a)?.(), ay.delete(a);
    }), Un.delete(t), ya$1.delete(t);
  }, "teardown") };
}, "useStore"), QT = /* @__PURE__ */ o((e) => {
  let t = document.getElementById("storybook-root"), r = /* @__PURE__ */ new Map();
  for (let n of e) {
    let { priority: i = 0 } = n;
    for (let s of n.selectors) {
      let a = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${s}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...t?.querySelectorAll(s) || []
      ];
      for (let l of a) {
        let u = r.get(l);
        (!u || u.priority <= i) && r.set(l, {
          ...n,
          priority: i,
          selectors: Array.from(new Set((u?.selectors || []).concat(s)))
        });
      }
    }
  }
  return r;
}, "mapElements"), aH = /* @__PURE__ */ o((e) => Array.from(e.entries()).map(([t, {
  selectors: r,
  styles: n,
  hoverStyles: i,
  focusStyles: s,
  menu: a
}]) => {
  let { top: l, left: u, width: c, height: d } = t.getBoundingClientRect(), { position: p } = getComputedStyle(t);
  return {
    element: t,
    selectors: r,
    styles: n,
    hoverStyles: i,
    focusStyles: s,
    menu: a,
    top: p === "fixed" ? l : l + window.scrollY,
    left: p === "fixed" ? u : u + window.scrollX,
    width: c,
    height: d
  };
}).sort((t, r) => r.width * r.height - t.width * t.height), "mapBoxes"), ZT = /* @__PURE__ */ o((e, t) => {
  let r = e.getBoundingClientRect(), { x: n, y: i } = t;
  return r?.top && r?.left && n >= r.left && n <= r.left + r.width && i >= r.top && i <= r.top + r.height;
}, "isOverMenu"), eR = /* @__PURE__ */ o((e, t, r) => {
  if (!t || !r)
    return false;
  let { left: n, top: i, width: s, height: a } = e;
  a < sr && (i = i - Math.round((sr - a) / 2), a = sr), s < sr && (n = n - Math.round((sr - s) / 2), s = sr), t.style.position === "fixed" && (n += window.scrollX, i += window.scrollY);
  let { x: l, y: u } = r;
  return l >= n && l <= n + s && u >= i && u <= i + a;
}, "isTargeted"), lH = /* @__PURE__ */ o((e, t, r = {}) => {
  let { x: n, y: i } = t, { margin: s = 5, topOffset: a = 0, centered: l = false } = r, { scrollX: u, scrollY: c, innerHeight: d, innerWidth: p } = window, f = Math.min(
    e.style.position === "fixed" ? i - c : i,
    d - e.clientHeight - s - a + c
  ), m = l ? e.clientWidth / 2 : 0, h = e.style.position === "fixed" ? Math.max(Math.min(n - u, p - m - s), m + s) : Math.max(
    Math.min(n, p - m - s + u),
    m + s + u
  );
  Object.assign(e.style, {
    ...h !== n && { left: `${h}px` },
    ...f !== i && { top: `${f}px` }
  });
}, "keepInViewport"), tR = /* @__PURE__ */ o((e) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && e.showPopover();
}, "showPopover"), uH = /* @__PURE__ */ o((e) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && e.hidePopover();
}, "hidePopover"), cH = /* @__PURE__ */ o((e) => ({
  top: e.top,
  left: e.left,
  width: e.width,
  height: e.height,
  selectors: e.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(e.element.attributes).map((t) => [t.name, t.value])
    ),
    localName: e.element.localName,
    tagName: e.element.tagName,
    outerHTML: e.element.outerHTML
  }
}), "getEventDetails");
var Ce$1 = "storybook-highlights-menu", dH = "storybook-highlights-root", lEe = "storybook-root", pH = /* @__PURE__ */ o((e) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
    return;
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = true;
  let { document: t } = globalThis, r = ar([]), n = ar(/* @__PURE__ */ new Map()), i = ar([]), s = ar(), a = ar(), l = ar([]), u = ar([]), c = ar(), d = ar(), p = t.getElementById(dH);
  r.subscribe(() => {
    p || (p = Le$1("div", { id: dH }), t.body.appendChild(p));
  }), r.subscribe((_) => {
    let C = t.getElementById(lEe);
    if (!C)
      return;
    n.set(QT(_));
    let O = new MutationObserver(() => n.set(QT(_)));
    return O.observe(C, { subtree: true, childList: true }), () => {
      O.disconnect();
    };
  }), n.subscribe((_) => {
    let C = /* @__PURE__ */ o(() => requestAnimationFrame(() => i.set(aH(_))), "updateBoxes"), O = new ResizeObserver(C);
    O.observe(t.body), Array.from(_.keys()).forEach((q) => O.observe(q));
    let L = Array.from(t.body.querySelectorAll("*")).filter((q) => {
      let { overflow: D, overflowX: H, overflowY: M } = window.getComputedStyle(q);
      return ["auto", "scroll"].some((U) => [D, H, M].includes(U));
    });
    return L.forEach((q) => q.addEventListener("scroll", C)), () => {
      O.disconnect(), L.forEach((q) => q.removeEventListener("scroll", C));
    };
  }), n.subscribe((_) => {
    let C = Array.from(_.keys()).filter(({ style: L }) => L.position === "sticky"), O = /* @__PURE__ */ o(() => requestAnimationFrame(() => {
      i.set(
        (L) => L.map((q) => {
          if (C.includes(q.element)) {
            let { top: D, left: H } = q.element.getBoundingClientRect();
            return { ...q, top: D + window.scrollY, left: H + window.scrollX };
          }
          return q;
        })
      );
    }), "updateBoxes");
    return t.addEventListener("scroll", O), () => t.removeEventListener("scroll", O);
  }), n.subscribe((_) => {
    l.set((C) => C.filter(({ element: O }) => _.has(O)));
  }), l.subscribe((_) => {
    _.length ? (d.set((C) => _.some((O) => O.element === C?.element) ? C : void 0), c.set((C) => _.some((O) => O.element === C?.element) ? C : void 0)) : (d.set(void 0), c.set(void 0), s.set(void 0));
  });
  let f = new Map(/* @__PURE__ */ new Map());
  r.subscribe((_) => {
    _.forEach(({ keyframes: C }) => {
      if (C) {
        let O = f.get(C);
        O || (O = t.createElement("style"), O.setAttribute("data-highlight", "keyframes"), f.set(C, O), t.head.appendChild(O)), O.innerHTML = C;
      }
    }), f.forEach((C, O) => {
      _.some((L) => L.keyframes === O) || (C.remove(), f.delete(O));
    });
  });
  let m = new Map(/* @__PURE__ */ new Map());
  i.subscribe((_) => {
    _.forEach((C) => {
      let O = m.get(C.element);
      if (p && !O) {
        let L = {
          popover: "manual",
          "data-highlight-dimensions": `w${C.width.toFixed(0)}h${C.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${C.left.toFixed(0)}y${C.top.toFixed(0)}`
        };
        O = p.appendChild(
          Le$1("div", L, [Le$1("div")])
        ), m.set(C.element, O);
      }
    }), m.forEach((C, O) => {
      _.some(({ element: L }) => L === O) || (C.remove(), m.delete(O));
    });
  }), i.subscribe((_) => {
    let C = _.filter((L) => L.menu);
    if (!C.length)
      return;
    let O = /* @__PURE__ */ o((L) => {
      requestAnimationFrame(() => {
        let q = t.getElementById(Ce$1), D = { x: L.pageX, y: L.pageY };
        if (q && !ZT(q, D)) {
          let H = C.filter((M) => {
            let U = m.get(M.element);
            return eR(M, U, D);
          });
          s.set(H.length ? D : void 0), l.set(H);
        }
      });
    }, "onClick");
    return t.addEventListener("click", O), () => t.removeEventListener("click", O);
  });
  let h = /* @__PURE__ */ o(() => {
    let _ = t.getElementById(Ce$1), C = a.get();
    !C || _ && ZT(_, C) || u.set((O) => {
      let L = i.get().filter((M) => {
        let U = m.get(M.element);
        return eR(M, U, C);
      }), q = O.filter((M) => L.includes(M)), D = L.filter((M) => !O.includes(M)), H = O.length - q.length;
      return D.length || H ? [...q, ...D] : O;
    });
  }, "updateHovered");
  a.subscribe(h), i.subscribe(h);
  let b = /* @__PURE__ */ o(() => {
    let _ = d.get(), C = _ ? [_] : l.get(), O = C.length === 1 ? C[0] : c.get(), L = s.get() !== void 0;
    i.get().forEach((q) => {
      let D = m.get(q.element);
      if (D) {
        let H = O === q, M = L ? O ? H : C.includes(q) : u.get()?.includes(q);
        Object.assign(D.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...q.styles,
          ...M ? q.hoverStyles : {},
          ...H ? q.focusStyles : {},
          position: getComputedStyle(q.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: XT - 10,
          top: `${q.top}px`,
          left: `${q.left}px`,
          width: `${q.width}px`,
          height: `${q.height}px`,
          margin: 0,
          padding: 0,
          cursor: q.menu && M ? "pointer" : "default",
          pointerEvents: q.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        }), Object.assign(D.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${sr}px`,
          minWidth: `${sr}px`,
          boxSizing: "content-box",
          padding: D.style.outlineWidth || "0px"
        }), tR(D);
      }
    });
  }, "updateBoxStyles");
  i.subscribe(b), l.subscribe(b), u.subscribe(b), c.subscribe(b), d.subscribe(b);
  let v = /* @__PURE__ */ o(() => {
    if (!p)
      return;
    let _ = t.getElementById(Ce$1);
    if (_)
      _.innerHTML = "";
    else {
      let q = { id: Ce$1, popover: "manual" };
      _ = p.appendChild(Le$1("div", q)), p.appendChild(
        Le$1("style", {}, [
          `
            #${Ce$1} {
              position: absolute;
              z-index: ${XT};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${Ce$1} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${Ce$1} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${Ce$1} li {
              padding: 0 4px;
              margin: 0;
            }
            #${Ce$1} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${Ce$1} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${Ce$1} button:focus-visible {
              outline-color: #029CFD;
            }
            #${Ce$1} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${Ce$1} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${Ce$1} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${Ce$1} li > button:hover svg, #${Ce$1} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${Ce$1} .element-list li svg {
              display: none;
            }
            #${Ce$1} li.selectable svg, #${Ce$1} li.selected svg {
              display: block;
            }
            #${Ce$1} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${Ce$1} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${Ce$1} .menu-items, #${Ce$1} .menu-items li {
              padding: 0;
            }
            #${Ce$1} .menu-item {
              display: flex;
            }
            #${Ce$1} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    let C = d.get(), O = C ? [C] : l.get();
    if (O.length && (_.style.position = getComputedStyle(O[0].element).position === "fixed" ? "fixed" : "absolute", _.appendChild(
      Le$1(
        "ul",
        { class: "element-list" },
        O.map((q) => {
          let D = O.length > 1 && !!q.menu?.some(
            (U) => U.some(
              (N) => !N.selectors || N.selectors.some((W) => q.selectors.includes(W))
            )
          ), H = D ? {
            class: "selectable",
            onClick: /* @__PURE__ */ o(() => d.set(q), "onClick"),
            onMouseEnter: /* @__PURE__ */ o(() => c.set(q), "onMouseEnter"),
            onMouseLeave: /* @__PURE__ */ o(() => c.set(void 0), "onMouseLeave")
          } : C ? { class: "selected", onClick: /* @__PURE__ */ o(() => d.set(void 0), "onClick") } : {}, M = D || C;
          return Le$1("li", H, [
            Le$1(M ? "button" : "div", M ? { type: "button" } : {}, [
              C ? ba("chevronLeft") : null,
              Le$1("code", {}, [q.element.outerHTML]),
              D ? ba("chevronRight") : null
            ])
          ]);
        })
      )
    )), d.get() || l.get().length === 1) {
      let q = d.get() || l.get()[0], D = q.menu?.filter(
        (H) => H.some(
          (M) => !M.selectors || M.selectors.some((U) => q.selectors.includes(U))
        )
      );
      D?.length && _.appendChild(
        Le$1(
          "ul",
          { class: "menu-list" },
          D.map(
            (H) => Le$1("li", {}, [
              Le$1(
                "ul",
                { class: "menu-items" },
                H.map(
                  ({ id: M, title: U, description: N, iconLeft: W, iconRight: Y, clickEvent: ae }) => {
                    let pe = ae && (() => e.emit(ae, M, cH(q)));
                    return Le$1("li", {}, [
                      Le$1(
                        pe ? "button" : "div",
                        pe ? { class: "menu-item", type: "button", onClick: pe } : { class: "menu-item" },
                        [
                          W ? ba(W) : null,
                          Le$1("div", { class: "menu-item-content" }, [
                            Le$1(N ? "strong" : "span", {}, [U]),
                            N && Le$1("span", {}, [N])
                          ]),
                          Y ? ba(Y) : null
                        ]
                      )
                    ]);
                  }
                )
              )
            ])
          )
        )
      );
    }
    let L = s.get();
    L ? (Object.assign(_.style, {
      display: "block",
      left: `${_.style.position === "fixed" ? L.x - window.scrollX : L.x}px`,
      top: `${_.style.position === "fixed" ? L.y - window.scrollY : L.y}px`
    }), tR(_), requestAnimationFrame(() => lH(_, L, { topOffset: 15, centered: true }))) : (uH(_), Object.assign(_.style, { display: "none" }));
  }, "renderMenu");
  l.subscribe(v), d.subscribe(v);
  let g = /* @__PURE__ */ o((_) => {
    let C = sH(_);
    r.set((O) => {
      let L = C.id ? O.filter((q) => q.id !== C.id) : O;
      return C.selectors?.length ? [...L, C] : L;
    });
  }, "addHighlight"), w = /* @__PURE__ */ o((_) => {
    _ && r.set((C) => C.filter((O) => O.id !== _));
  }, "removeHighlight"), E = /* @__PURE__ */ o(() => {
    r.set([]), n.set(/* @__PURE__ */ new Map()), i.set([]), s.set(void 0), a.set(void 0), l.set([]), u.set([]), c.set(void 0), d.set(void 0);
  }, "resetState"), R, S = /* @__PURE__ */ o((_, C) => {
    let O = "scrollIntoView-highlight";
    clearTimeout(R), w(O);
    let L = t.querySelector(_);
    if (!L) {
      console.warn(`Cannot scroll into view: ${_} not found`);
      return;
    }
    L.scrollIntoView({ behavior: "smooth", block: "center", ...C });
    let q = `kf-${Math.random().toString(36).substring(2, 15)}`;
    r.set((D) => [
      ...D,
      {
        id: O,
        priority: 1e3,
        selectors: [_],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${q} 3s linear forwards`
        },
        keyframes: `@keyframes ${q} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]), R = setTimeout(() => w(O), 3500);
  }, "scrollIntoView"), P = /* @__PURE__ */ o((_) => {
    requestAnimationFrame(() => a.set({ x: _.pageX, y: _.pageY }));
  }, "onMouseMove");
  t.body.addEventListener("mousemove", P), e.on(rH, g), e.on(nH, w), e.on(oH, E), e.on(iH, S), e.on(jt, ({ newPhase: _ }) => {
    _ === "loading" && E();
  });
}, "useHighlights");
globalThis?.FEATURES?.highlight && He?.ready && He.ready().then(pH);
var rR = /* @__PURE__ */ o(() => ({}), "default");
var fH = "measureEnabled";
function mH() {
  let e = k.document.documentElement, t = Math.max(e.scrollHeight, e.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
o(mH, "getDocumentWidthAndHeight");
function uEe() {
  let e = k.document.createElement("canvas");
  e.id = "storybook-addon-measure";
  let t = e.getContext("2d");
  gt$1(t != null);
  let { width: r, height: n } = mH();
  return nR(e, t, { width: r, height: n }), e.style.position = "absolute", e.style.left = "0", e.style.top = "0", e.style.zIndex = "2147483647", e.style.pointerEvents = "none", k.document.body.appendChild(e), { canvas: e, context: t, width: r, height: n };
}
o(uEe, "createCanvas");
function nR(e, t, { width: r, height: n }) {
  e.style.width = `${r}px`, e.style.height = `${n}px`;
  let i = k.window.devicePixelRatio;
  e.width = Math.floor(r * i), e.height = Math.floor(n * i), t.scale(i, i);
}
o(nR, "setCanvasWidthAndHeight");
var Be$1 = {};
function hH() {
  Be$1.canvas || (Be$1 = uEe());
}
o(hH, "init");
function yH() {
  Be$1.context && Be$1.context.clearRect(0, 0, Be$1.width ?? 0, Be$1.height ?? 0);
}
o(yH, "clear");
function bH(e) {
  yH(), e(Be$1.context);
}
o(bH, "draw");
function gH() {
  gt$1(Be$1.canvas), gt$1(Be$1.context), nR(Be$1.canvas, Be$1.context, {
    width: 0,
    height: 0
  });
  let { width: e, height: t } = mH();
  nR(Be$1.canvas, Be$1.context, { width: e, height: t }), Be$1.width = e, Be$1.height = t;
}
o(gH, "rescale");
function vH() {
  Be$1.canvas && (yH(), Be$1.canvas.parentNode?.removeChild(Be$1.canvas), Be$1 = {});
}
o(vH, "destroy");
var di = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
}, Rr$1 = 6;
function EH(e, { x: t, y: r, w: n, h: i, r: s }) {
  t = t - n / 2, r = r - i / 2, n < 2 * s && (s = n / 2), i < 2 * s && (s = i / 2), e.beginPath(), e.moveTo(t + s, r), e.arcTo(t + n, r, t + n, r + i, s), e.arcTo(t + n, r + i, t, r + i, s), e.arcTo(t, r + i, t, r, s), e.arcTo(t, r, t + n, r, s), e.closePath();
}
o(EH, "roundedRect");
function cEe(e, { padding: t, border: r, width: n, height: i, top: s, left: a }) {
  let l = n - r.left - r.right - t.left - t.right, u = i - t.top - t.bottom - r.top - r.bottom, c = a + r.left + t.left, d = s + r.top + t.top;
  return e === "top" ? c += l / 2 : e === "right" ? (c += l, d += u / 2) : e === "bottom" ? (c += l / 2, d += u) : e === "left" ? d += u / 2 : e === "center" && (c += l / 2, d += u / 2), { x: c, y: d };
}
o(cEe, "positionCoordinate");
function dEe(e, t, { margin: r, border: n, padding: i }, s, a) {
  let l = /* @__PURE__ */ o((f) => 0, "shift"), u = 0, c = 0, d = a ? 1 : 0.5, p = a ? s * 2 : 0;
  return e === "padding" ? l = /* @__PURE__ */ o((f) => i[f] * d + p, "shift") : e === "border" ? l = /* @__PURE__ */ o((f) => i[f] + n[f] * d + p, "shift") : e === "margin" && (l = /* @__PURE__ */ o((f) => i[f] + n[f] + r[f] * d + p, "shift")), t === "top" ? c = -l("top") : t === "right" ? u = l("right") : t === "bottom" ? c = l("bottom") : t === "left" && (u = -l("left")), { offsetX: u, offsetY: c };
}
o(dEe, "offset");
function pEe(e, t) {
  return Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2;
}
o(pEe, "collide");
function fEe(e, t, r) {
  return e === "top" ? t.y = r.y - r.h - Rr$1 : e === "right" ? t.x = r.x + r.w / 2 + Rr$1 + t.w / 2 : e === "bottom" ? t.y = r.y + r.h + Rr$1 : e === "left" && (t.x = r.x - r.w / 2 - Rr$1 - t.w / 2), { x: t.x, y: t.y };
}
o(fEe, "overlapAdjustment");
function xH(e, t, { x: r, y: n, w: i, h: s }, a) {
  return EH(e, { x: r, y: n, w: i, h: s, r: 3 }), e.fillStyle = `${di[t]}dd`, e.fill(), e.strokeStyle = di[t], e.stroke(), e.fillStyle = di.text, e.fillText(a, r, n), EH(e, { x: r, y: n, w: i, h: s, r: 3 }), e.fillStyle = `${di[t]}dd`, e.fill(), e.strokeStyle = di[t], e.stroke(), e.fillStyle = di.text, e.fillText(a, r, n), { x: r, y: n, w: i, h: s };
}
o(xH, "textWithRect");
function wH(e, t) {
  e.font = "600 12px monospace", e.textBaseline = "middle", e.textAlign = "center";
  let r = e.measureText(t), n = r.actualBoundingBoxAscent + r.actualBoundingBoxDescent, i = r.width + Rr$1 * 2, s = n + Rr$1 * 2;
  return { w: i, h: s };
}
o(wH, "configureText");
function mEe(e, t, { type: r, position: n = "center", text: i }, s, a = false) {
  let { x: l, y: u } = cEe(n, t), { offsetX: c, offsetY: d } = dEe(r, n, t, Rr$1 + 1, a);
  l += c, u += d;
  let { w: p, h: f } = wH(e, i);
  if (s && pEe({ x: l, y: u, w: p, h: f }, s)) {
    let m = fEe(n, { x: l, y: u, w: p, h: f }, s);
    l = m.x, u = m.y;
  }
  return xH(e, r, { x: l, y: u, w: p, h: f }, i);
}
o(mEe, "drawLabel");
function hEe(e, { w: t, h: r }) {
  let n = t * 0.5 + Rr$1, i = r * 0.5 + Rr$1;
  return {
    offsetX: (e.x === "left" ? -1 : 1) * n,
    offsetY: (e.y === "top" ? -1 : 1) * i
  };
}
o(hEe, "floatingOffset");
function yEe(e, t, { type: r, text: n }) {
  let { floatingAlignment: i, extremities: s } = t, a = s[i.x], l = s[i.y], { w: u, h: c } = wH(e, n), { offsetX: d, offsetY: p } = hEe(i, {
    w: u,
    h: c
  });
  return a += d, l += p, xH(e, r, { x: a, y: l, w: u, h: c }, n);
}
o(yEe, "drawFloatingLabel");
function ga(e, t, r, n) {
  let i = [];
  r.forEach((s, a) => {
    let l = n && s.position === "center" ? yEe(e, t, s) : mEe(e, t, s, i[a - 1], n);
    i[a] = l;
  });
}
o(ga, "drawStack");
function TH(e, t, r, n) {
  let i = r.reduce((s, a) => (Object.prototype.hasOwnProperty.call(s, a.position) || (s[a.position] = []), s[a.position]?.push(a), s), {});
  i.top && ga(e, t, i.top, n), i.right && ga(e, t, i.right, n), i.bottom && ga(e, t, i.bottom, n), i.left && ga(e, t, i.left, n), i.center && ga(e, t, i.center, n);
}
o(TH, "labelStacks");
var uy = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
}, RH = 30;
function Nt$1(e) {
  return parseInt(e.replace("px", ""), 10);
}
o(Nt$1, "pxToNumber");
function pi(e) {
  return Number.isInteger(e) ? e : e.toFixed(2);
}
o(pi, "round");
function oR(e) {
  return e.filter((t) => t.text !== 0 && t.text !== "0");
}
o(oR, "filterZeroValues");
function bEe(e) {
  let t = {
    top: k.window.scrollY,
    bottom: k.window.scrollY + k.window.innerHeight,
    left: k.window.scrollX,
    right: k.window.scrollX + k.window.innerWidth
  }, r = {
    top: Math.abs(t.top - e.top),
    bottom: Math.abs(t.bottom - e.bottom),
    left: Math.abs(t.left - e.left),
    right: Math.abs(t.right - e.right)
  };
  return {
    x: r.left > r.right ? "left" : "right",
    y: r.top > r.bottom ? "top" : "bottom"
  };
}
o(bEe, "floatingAlignment");
function gEe(e) {
  let t = k.getComputedStyle(e), { top: r, left: n, right: i, bottom: s, width: a, height: l } = e.getBoundingClientRect(), {
    marginTop: u,
    marginBottom: c,
    marginLeft: d,
    marginRight: p,
    paddingTop: f,
    paddingBottom: m,
    paddingLeft: h,
    paddingRight: b,
    borderBottomWidth: v,
    borderTopWidth: g,
    borderLeftWidth: w,
    borderRightWidth: E
  } = t;
  r = r + k.window.scrollY, n = n + k.window.scrollX, s = s + k.window.scrollY, i = i + k.window.scrollX;
  let R = {
    top: Nt$1(u),
    bottom: Nt$1(c),
    left: Nt$1(d),
    right: Nt$1(p)
  }, S = {
    top: Nt$1(f),
    bottom: Nt$1(m),
    left: Nt$1(h),
    right: Nt$1(b)
  }, P = {
    top: Nt$1(g),
    bottom: Nt$1(v),
    left: Nt$1(w),
    right: Nt$1(E)
  }, _ = {
    top: r - R.top,
    bottom: s + R.bottom,
    left: n - R.left,
    right: i + R.right
  };
  return {
    margin: R,
    padding: S,
    border: P,
    top: r,
    left: n,
    bottom: s,
    right: i,
    width: a,
    height: l,
    extremities: _,
    floatingAlignment: bEe(_)
  };
}
o(gEe, "measureElement");
function vEe(e, { margin: t, width: r, height: n, top: i, left: s, bottom: a, right: l }) {
  let u = n + t.bottom + t.top;
  e.fillStyle = uy.margin, e.fillRect(s, i - t.top, r, t.top), e.fillRect(l, i - t.top, t.right, u), e.fillRect(s, a, r, t.bottom), e.fillRect(
    s - t.left,
    i - t.top,
    t.left,
    u
  );
  let c = [
    {
      type: "margin",
      text: pi(t.top),
      position: "top"
    },
    {
      type: "margin",
      text: pi(t.right),
      position: "right"
    },
    {
      type: "margin",
      text: pi(t.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: pi(t.left),
      position: "left"
    }
  ];
  return oR(c);
}
o(vEe, "drawMargin");
function EEe(e, { padding: t, border: r, width: n, height: i, top: s, left: a, bottom: l, right: u }) {
  let c = n - r.left - r.right, d = i - t.top - t.bottom - r.top - r.bottom;
  e.fillStyle = uy.padding, e.fillRect(a + r.left, s + r.top, c, t.top), e.fillRect(
    u - t.right - r.right,
    s + t.top + r.top,
    t.right,
    d
  ), e.fillRect(
    a + r.left,
    l - t.bottom - r.bottom,
    c,
    t.bottom
  ), e.fillRect(a + r.left, s + t.top + r.top, t.left, d);
  let p = [
    {
      type: "padding",
      text: t.top,
      position: "top"
    },
    {
      type: "padding",
      text: t.right,
      position: "right"
    },
    {
      type: "padding",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: t.left,
      position: "left"
    }
  ];
  return oR(p);
}
o(EEe, "drawPadding");
function xEe(e, { border: t, width: r, height: n, top: i, left: s, bottom: a, right: l }) {
  let u = n - t.top - t.bottom;
  e.fillStyle = uy.border, e.fillRect(s, i, r, t.top), e.fillRect(s, a - t.bottom, r, t.bottom), e.fillRect(s, i + t.top, t.left, u), e.fillRect(
    l - t.right,
    i + t.top,
    t.right,
    u
  );
  let c = [
    {
      type: "border",
      text: t.top,
      position: "top"
    },
    {
      type: "border",
      text: t.right,
      position: "right"
    },
    {
      type: "border",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: t.left,
      position: "left"
    }
  ];
  return oR(c);
}
o(xEe, "drawBorder");
function wEe(e, { padding: t, border: r, width: n, height: i, top: s, left: a }) {
  let l = n - r.left - r.right - t.left - t.right, u = i - t.top - t.bottom - r.top - r.bottom;
  return e.fillStyle = uy.content, e.fillRect(
    a + r.left + t.left,
    s + r.top + t.top,
    l,
    u
  ), [
    {
      type: "content",
      position: "center",
      text: `${pi(l)} x ${pi(u)}`
    }
  ];
}
o(wEe, "drawContent");
function TEe(e) {
  return (t) => {
    if (e && t) {
      let r = gEe(e), n = vEe(t, r), i = EEe(t, r), s = xEe(t, r), a = wEe(t, r), l = r.width <= RH * 3 || r.height <= RH;
      TH(
        t,
        r,
        [...a, ...i, ...s, ...n],
        l
      );
    }
  };
}
o(TEe, "drawBoxModel");
function SH(e) {
  bH(TEe(e));
}
o(SH, "drawSelectedElement");
var _H = /* @__PURE__ */ o((e, t) => {
  let r = k.document.elementFromPoint(e, t), n = /* @__PURE__ */ o((s) => {
    if (s && s.shadowRoot) {
      let a = s.shadowRoot.elementFromPoint(e, t);
      return s.isEqualNode(a) ? s : a.shadowRoot ? n(a) : a;
    }
    return s;
  }, "crawlShadows");
  return n(r) || r;
}, "deepElementFromPoint");
var CH, cy = { x: 0, y: 0 };
function PH(e, t) {
  CH = _H(e, t), SH(CH);
}
o(PH, "findAndDrawElement");
var AH = /* @__PURE__ */ o((e, t) => {
  let { measureEnabled: r } = t.globals || {};
  return kt$1(() => {
    if (typeof globalThis.document > "u")
      return;
    let n = /* @__PURE__ */ o((i) => {
      window.requestAnimationFrame(() => {
        i.stopPropagation(), cy.x = i.clientX, cy.y = i.clientY;
      });
    }, "onPointerMove");
    return globalThis.document.addEventListener("pointermove", n), () => {
      globalThis.document.removeEventListener("pointermove", n);
    };
  }, []), kt$1(() => {
    let n = /* @__PURE__ */ o((s) => {
      window.requestAnimationFrame(() => {
        s.stopPropagation(), PH(s.clientX, s.clientY);
      });
    }, "onPointerOver"), i = /* @__PURE__ */ o(() => {
      window.requestAnimationFrame(() => {
        gH();
      });
    }, "onResize");
    return t.viewMode === "story" && r && (globalThis.document.addEventListener("pointerover", n), hH(), globalThis.window.addEventListener(
      "resize",
      i
    ), PH(cy.x, cy.y)), () => {
      globalThis.window.removeEventListener("resize", i), vH();
    };
  }, [r, t.viewMode]), e();
}, "withMeasure");
var REe = globalThis.FEATURES?.measure ? [AH] : [], SEe = {
  [fH]: false
}, iR = /* @__PURE__ */ o(() => ({
  decorators: REe,
  initialGlobals: SEe
}), "default");
var dy = "outline";
var sR = /* @__PURE__ */ o((e) => {
  (Array.isArray(e) ? e : [e]).forEach(_Ee);
}, "clearStyles"), _Ee = /* @__PURE__ */ o((e) => {
  let t = typeof e == "string" ? e : e.join(""), r = k.document.getElementById(t);
  r && r.parentElement && r.parentElement.removeChild(r);
}, "clearStyle"), OH = /* @__PURE__ */ o((e, t) => {
  let r = k.document.getElementById(e);
  if (r)
    r.innerHTML !== t && (r.innerHTML = t);
  else {
    let n = k.document.createElement("style");
    n.setAttribute("id", e), n.innerHTML = t, k.document.head.appendChild(n);
  }
}, "addOutlineStyles");
function aR(e) {
  return Q$1`
    ${e} body {
      outline: 1px solid #2980b9 !important;
    }

    ${e} article {
      outline: 1px solid #3498db !important;
    }

    ${e} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${e} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${e} section {
      outline: 1px solid #66b8da !important;
    }

    ${e} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${e} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${e} h1 {
      outline: 1px solid #162544 !important;
    }

    ${e} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${e} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${e} h4 {
      outline: 1px solid #449baf !important;
    }

    ${e} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${e} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${e} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${e} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${e} div {
      outline: 1px solid #036cdb !important;
    }

    ${e} p {
      outline: 1px solid #ac050b !important;
    }

    ${e} hr {
      outline: 1px solid #ff063f !important;
    }

    ${e} pre {
      outline: 1px solid #850440 !important;
    }

    ${e} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${e} ol {
      outline: 1px solid #ff050c !important;
    }

    ${e} ul {
      outline: 1px solid #d90416 !important;
    }

    ${e} li {
      outline: 1px solid #d90416 !important;
    }

    ${e} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${e} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${e} dd {
      outline: 1px solid #e80174 !important;
    }

    ${e} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${e} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${e} table {
      outline: 1px solid #00cc99 !important;
    }

    ${e} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} thead {
      outline: 1px solid #98daca !important;
    }

    ${e} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${e} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${e} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${e} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${e} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${e} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${e} button {
      outline: 1px solid #da8301 !important;
    }

    ${e} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${e} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${e} form {
      outline: 1px solid #d23600 !important;
    }

    ${e} input {
      outline: 1px solid #fca600 !important;
    }

    ${e} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${e} label {
      outline: 1px solid #ee8900 !important;
    }

    ${e} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${e} meter {
      outline: 1px solid #e8630c !important;
    }

    ${e} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${e} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${e} output {
      outline: 1px solid #ff9619 !important;
    }

    ${e} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${e} select {
      outline: 1px solid #e26e0f !important;
    }

    ${e} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${e} details {
      outline: 1px solid #33848f !important;
    }

    ${e} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${e} command {
      outline: 1px solid #438da1 !important;
    }

    ${e} menu {
      outline: 1px solid #449da6 !important;
    }

    ${e} del {
      outline: 1px solid #bf0000 !important;
    }

    ${e} ins {
      outline: 1px solid #400000 !important;
    }

    ${e} img {
      outline: 1px solid #22746b !important;
    }

    ${e} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} embed {
      outline: 1px solid #98daca !important;
    }

    ${e} object {
      outline: 1px solid #00cc99 !important;
    }

    ${e} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} video {
      outline: 1px solid #6ee866 !important;
    }

    ${e} audio {
      outline: 1px solid #027353 !important;
    }

    ${e} source {
      outline: 1px solid #012426 !important;
    }

    ${e} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${e} track {
      outline: 1px solid #59a600 !important;
    }

    ${e} map {
      outline: 1px solid #7be500 !important;
    }

    ${e} area {
      outline: 1px solid #305900 !important;
    }

    ${e} a {
      outline: 1px solid #ff62ab !important;
    }

    ${e} em {
      outline: 1px solid #800b41 !important;
    }

    ${e} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${e} i {
      outline: 1px solid #803156 !important;
    }

    ${e} b {
      outline: 1px solid #cc1169 !important;
    }

    ${e} u {
      outline: 1px solid #ff0430 !important;
    }

    ${e} s {
      outline: 1px solid #f805e3 !important;
    }

    ${e} small {
      outline: 1px solid #d107b2 !important;
    }

    ${e} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${e} q {
      outline: 1px solid #240018 !important;
    }

    ${e} cite {
      outline: 1px solid #64003c !important;
    }

    ${e} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${e} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${e} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${e} time {
      outline: 1px solid #d6606d !important;
    }

    ${e} code {
      outline: 1px solid #e04251 !important;
    }

    ${e} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${e} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${e} var {
      outline: 1px solid #d90047 !important;
    }

    ${e} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${e} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${e} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${e} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${e} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${e} rp {
      outline: 1px solid #803e49 !important;
    }

    ${e} span {
      outline: 1px solid #cc2643 !important;
    }

    ${e} br {
      outline: 1px solid #db687d !important;
    }

    ${e} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
o(aR, "outlineCSS");
var qH = /* @__PURE__ */ o((e, t) => {
  let r = t.globals || {}, n = [true, "true"].includes(r[dy]), i = t.viewMode === "docs", s = Qa(() => aR(i ? '[data-story-block="true"]' : ".sb-show-main"), [t]);
  return kt$1(() => {
    let a = i ? `addon-outline-docs-${t.id}` : "addon-outline";
    return n ? OH(a, s) : sR(a), () => {
      sR(a);
    };
  }, [n, s, t]), e();
}, "withOutline");
var CEe = globalThis.FEATURES?.outline ? [qH] : [], PEe = {
  [dy]: false
}, lR = /* @__PURE__ */ o(() => ({ decorators: CEe, initialGlobals: PEe }), "default");
var AEe = /* @__PURE__ */ o(({ parameters: e }) => {
  e?.test?.mockReset === true ? dw() : e?.test?.clearMocks === true ? cw() : e?.test?.restoreMocks !== false && pw();
}, "resetAllMocksLoader"), uR = /* @__PURE__ */ o((e, t = 0, r) => {
  if (t > 5 || e == null)
    return e;
  if (hr$1(e))
    return r && e.mockName(r), e;
  if (typeof e == "function" && "isAction" in e && e.isAction && !("implicit" in e && e.implicit)) {
    let n = uw(e);
    return r && n.mockName(r), n;
  }
  if (Array.isArray(e)) {
    t++;
    for (let n = 0; n < e.length; n++)
      Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = uR(e[n], t));
    return e;
  }
  if (typeof e == "object" && e.constructor === Object) {
    t++;
    for (let [n, i] of Object.entries(e))
      Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = uR(i, t, n));
    return e;
  }
  return e;
}, "traverseArgs"), OEe = /* @__PURE__ */ o(({ initialArgs: e }) => {
  uR(e);
}, "nameSpiesAndWrapActionsInSpies"), IH = false, qEe = /* @__PURE__ */ o(async (e) => {
  globalThis.HTMLElement && e.canvasElement instanceof globalThis.HTMLElement && (e.canvas = HT(e.canvasElement));
  let t = globalThis.window?.navigator?.clipboard;
  if (t) {
    e.userEvent = rr(
      { userEvent: UT.setup() },
      { intercept: true }
    ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
      get: /* @__PURE__ */ o(() => t, "get"),
      configurable: true
    });
    let r = HTMLElement.prototype.focus;
    IH || Object.defineProperties(HTMLElement.prototype, {
      focus: {
        configurable: true,
        set: /* @__PURE__ */ o((n) => {
          r = n, IH = true;
        }, "set"),
        get: /* @__PURE__ */ o(() => r, "get")
      }
    });
  }
}, "enhanceContext"), cR = /* @__PURE__ */ o(() => ({
  loaders: [AEe, OEe, qEe]
}), "default");
var NH = "viewport";
var IEe = {
  [NH]: { value: void 0, isRotated: false }
}, dR = /* @__PURE__ */ o(() => ({
  initialGlobals: IEe
}), "default");
function py() {
  return [
    // @ts-expect-error CJS fallback
    (iR.default ?? iR)(),
    // @ts-expect-error CJS fallback
    (YT.default ?? YT)(),
    // @ts-expect-error CJS fallback
    (rR.default ?? rR)(),
    // @ts-expect-error CJS fallback
    (lR.default ?? lR)(),
    // @ts-expect-error CJS fallback
    (dR.default ?? dR)(),
    // @ts-expect-error CJS fallback
    (GT.default ?? GT)(),
    // @ts-expect-error CJS fallback
    (KT.default ?? KT)(),
    // @ts-expect-error CJS fallback
    (cR.default ?? cR)()
  ];
}
o(py, "getCoreAnnotations");
function fi(e) {
  return e != null && typeof e == "object" && "_tag" in e && e?._tag === "Story";
}
o(fi, "isStory");
var pR = /* @__PURE__ */ o((e) => e.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(
  /-+/g,
  "-"
).replace(/^-+/, "").replace(/-+$/, ""), "sanitize"), jH = /* @__PURE__ */ o((e, t) => {
  let r = pR(e);
  if (r === "")
    throw new Error(`Invalid ${t} '${e}', must include alphanumeric characters`);
  return r;
}, "sanitizeSafe"), LH = /* @__PURE__ */ o((e, t) => `${jH(e, "kind")}${t ? `--${jH(t, "name")}` : ""}`, "toId"), FH = /* @__PURE__ */ o((e) => o_(
  e
), "storyNameFromExport");
function kH(e, t) {
  return Array.isArray(t) ? t.includes(e) : e.match(t);
}
o(kH, "matches");
function va(e, { includeStories: t, excludeStories: r }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    e !== "__esModule" && (!t || kH(e, t)) && (!r || !kH(e, r))
  );
}
o(va, "isExportStory");
var DH = /* @__PURE__ */ o((...e) => {
  let t = e.reduce((r, n) => (n.startsWith("!") ? r.delete(n.slice(1)) : r.add(n), r), /* @__PURE__ */ new Set());
  return Array.from(t);
}, "combineTags");
function $H() {
}
o($H, "noop");
function fR(e) {
  return Object.getOwnPropertySymbols(e).filter((t) => Object.prototype.propertyIsEnumerable.call(e, t));
}
o(fR, "getSymbols");
function mR(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
o(mR, "getTag");
var BH = "[object RegExp]", HH = "[object String]", UH = "[object Number]", VH = "[object Boolean]", hR = "[object Arguments]", zH = "[object Symbol]", GH = "[object Date]", WH = "[object Map]", YH = "[object Set]", KH = "[object Array]", XH = "[object Function]", JH = "[object ArrayBuffer]", fy = "[object Object]", QH = "[object Error]", ZH = "[object DataView]", eU = "[object Uint8Array]", tU = "[object Uint8ClampedArray]", rU = "[object Uint16Array]", nU = "[object Uint32Array]", oU = "[object BigUint64Array]", iU = "[object Int8Array]", sU = "[object Int16Array]", aU = "[object Int32Array]", lU = "[object BigInt64Array]", uU = "[object Float32Array]", cU = "[object Float64Array]";
function ct$1(e) {
  if (!e || typeof e != "object")
    return false;
  let t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null ? Object.prototype.toString.call(e) === "[object Object]" : false;
}
o(ct$1, "isPlainObject");
function Sr$1(e, t) {
  let r = {}, n = Object.keys(e);
  for (let i = 0; i < n.length; i++) {
    let s = n[i], a = e[s];
    r[s] = t(a, s, e);
  }
  return r;
}
o(Sr$1, "mapValues");
function yR(e, t) {
  let r = {}, n = Object.keys(e);
  for (let i = 0; i < n.length; i++) {
    let s = n[i], a = e[s];
    t(a, s) && (r[s] = a);
  }
  return r;
}
o(yR, "pickBy");
function dU(e, t) {
  return e === t || Number.isNaN(e) && Number.isNaN(t);
}
o(dU, "eq");
function pU(e, t, r) {
  return Ea(e, t, void 0, void 0, void 0, void 0, r);
}
o(pU, "isEqualWith");
function Ea(e, t, r, n, i, s, a) {
  let l = a(e, t, r, n, i, s);
  if (l !== void 0)
    return l;
  if (typeof e == typeof t)
    switch (typeof e) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return e === t;
      case "number":
        return e === t || Object.is(e, t);
      case "function":
        return e === t;
      case "object":
        return xa(e, t, s, a);
    }
  return xa(e, t, s, a);
}
o(Ea, "isEqualWithImpl");
function xa(e, t, r, n) {
  if (Object.is(e, t))
    return true;
  let i = mR(e), s = mR(t);
  if (i === hR && (i = fy), s === hR && (s = fy), i !== s)
    return false;
  switch (i) {
    case HH:
      return e.toString() === t.toString();
    case UH: {
      let u = e.valueOf(), c = t.valueOf();
      return dU(u, c);
    }
    case VH:
    case GH:
    case zH:
      return Object.is(e.valueOf(), t.valueOf());
    case BH:
      return e.source === t.source && e.flags === t.flags;
    case XH:
      return e === t;
  }
  r = r ?? /* @__PURE__ */ new Map();
  let a = r.get(e), l = r.get(t);
  if (a != null && l != null)
    return a === t;
  r.set(e, t), r.set(t, e);
  try {
    switch (i) {
      case WH: {
        if (e.size !== t.size)
          return false;
        for (let [u, c] of e.entries())
          if (!t.has(u) || !Ea(c, t.get(u), u, e, t, r, n))
            return false;
        return true;
      }
      case YH: {
        if (e.size !== t.size)
          return false;
        let u = Array.from(e.values()), c = Array.from(t.values());
        for (let d = 0; d < u.length; d++) {
          let p = u[d], f = c.findIndex((m) => Ea(p, m, void 0, e, t, r, n));
          if (f === -1)
            return false;
          c.splice(f, 1);
        }
        return true;
      }
      case KH:
      case eU:
      case tU:
      case rU:
      case nU:
      case oU:
      case iU:
      case sU:
      case aU:
      case lU:
      case uU:
      case cU: {
        if (typeof Buffer < "u" && Buffer.isBuffer(e) !== Buffer.isBuffer(t) || e.length !== t.length)
          return false;
        for (let u = 0; u < e.length; u++)
          if (!Ea(e[u], t[u], u, e, t, r, n))
            return false;
        return true;
      }
      case JH:
        return e.byteLength !== t.byteLength ? false : xa(new Uint8Array(e), new Uint8Array(t), r, n);
      case ZH:
        return e.byteLength !== t.byteLength || e.byteOffset !== t.byteOffset ? false : xa(new Uint8Array(e), new Uint8Array(t), r, n);
      case QH:
        return e.name === t.name && e.message === t.message;
      case fy: {
        if (!(xa(e.constructor, t.constructor, r, n) || ct$1(e) && ct$1(t)))
          return false;
        let c = [...Object.keys(e), ...fR(e)], d = [...Object.keys(t), ...fR(t)];
        if (c.length !== d.length)
          return false;
        for (let p = 0; p < c.length; p++) {
          let f = c[p], m = e[f];
          if (!Object.hasOwn(t, f))
            return false;
          let h = t[f];
          if (!Ea(m, h, f, e, t, r, n))
            return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    r.delete(e), r.delete(t);
  }
}
o(xa, "areObjectsEqual");
function bR(e, t) {
  return pU(e, t, $H);
}
o(bR, "isEqual");
var _y = Ne(vR(), 1);
var mi = Symbol("incompatible"), ER = /* @__PURE__ */ o((e, t) => {
  let r = t.type;
  if (e == null || !r || t.mapping)
    return e;
  switch (r.name) {
    case "string":
      return String(e);
    case "enum":
      return e;
    case "number":
      return Number(e);
    case "boolean":
      return String(e) === "true";
    case "array":
      return !r.value || !Array.isArray(e) ? mi : e.reduce((n, i, s) => {
        let a = ER(i, { type: r.value });
        return a !== mi && (n[s] = a), n;
      }, new Array(e.length));
    case "object":
      return typeof e == "string" || typeof e == "number" ? e : !r.value || typeof e != "object" ? mi : Object.entries(e).reduce((n, [i, s]) => {
        let a = ER(s, { type: r.value[i] });
        return a === mi ? n : Object.assign(n, { [i]: a });
      }, {});
    default:
      return mi;
  }
}, "map"), mU = /* @__PURE__ */ o((e, t) => Object.entries(e).reduce((r, [n, i]) => {
  if (!t[n])
    return r;
  let s = ER(i, t[n]);
  return s === mi ? r : Object.assign(r, { [n]: s });
}, {}), "mapArgsToTypes"), hi = /* @__PURE__ */ o((e, t) => Array.isArray(e) && Array.isArray(t) ? t.reduce(
  (r, n, i) => (r[i] = hi(e[i], t[i]), r),
  [...e]
).filter((r) => r !== void 0) : !ct$1(e) || !ct$1(t) ? t : Object.keys({ ...e, ...t }).reduce((r, n) => {
  if (n in t) {
    let i = hi(e[n], t[n]);
    i !== void 0 && (r[n] = i);
  } else
    r[n] = e[n];
  return r;
}, {}), "combineArgs"), hU = /* @__PURE__ */ o((e, t) => Object.entries(t).reduce((r, [n, { options: i }]) => {
  function s() {
    return n in e && (r[n] = e[n]), r;
  }
  if (o(s, "allowArg"), !i)
    return s();
  if (!Array.isArray(i))
    return be.error(Q$1`
        Invalid argType: '${n}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `), s();
  if (i.some((p) => p && ["object", "function"].includes(typeof p)))
    return be.error(Q$1`
        Invalid argType: '${n}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `), s();
  let a = Array.isArray(e[n]), l = a && e[n].findIndex((p) => !i.includes(p)), u = a && l === -1;
  if (e[n] === void 0 || i.includes(e[n]) || u)
    return s();
  let c = a ? `${n}[${l}]` : n, d = i.map((p) => typeof p == "string" ? `'${p}'` : String(p)).join(", ");
  return be.warn(`Received illegal value for '${c}'. Supported options: ${d}`), r;
}, {}), "validateOptions"), Vn = Symbol("Deeply equal"), yi = /* @__PURE__ */ o((e, t) => {
  if (typeof e != typeof t)
    return t;
  if (bR(e, t))
    return Vn;
  if (Array.isArray(e) && Array.isArray(t)) {
    let r = t.reduce((n, i, s) => {
      let a = yi(e[s], i);
      return a !== Vn && (n[s] = a), n;
    }, new Array(t.length));
    return t.length >= e.length ? r : r.concat(new Array(e.length - t.length).fill(void 0));
  }
  return ct$1(e) && ct$1(t) ? Object.keys({ ...e, ...t }).reduce((r, n) => {
    let i = yi(e?.[n], t?.[n]);
    return i === Vn ? r : Object.assign(r, { [n]: i });
  }, {}) : t;
}, "deepDiff"), xR = "UNTARGETED";
function yU({
  args: e,
  argTypes: t
}) {
  let r = {};
  return Object.entries(e).forEach(([n, i]) => {
    let { target: s = xR } = t[n] || {};
    r[s] = r[s] || {}, r[s][n] = i;
  }), r;
}
o(yU, "groupArgsByTarget");
function MEe(e) {
  return Object.keys(e).forEach((t) => e[t] === void 0 && delete e[t]), e;
}
o(MEe, "deleteUndefined");
var wR = class wR2 {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(t) {
    if (!(t in this.argsByStoryId))
      throw new Error(`No args known for ${t} -- has it been rendered yet?`);
    return this.argsByStoryId[t];
  }
  setInitial(t) {
    if (!this.initialArgsByStoryId[t.id])
      this.initialArgsByStoryId[t.id] = t.initialArgs, this.argsByStoryId[t.id] = t.initialArgs;
    else if (this.initialArgsByStoryId[t.id] !== t.initialArgs) {
      let r = yi(this.initialArgsByStoryId[t.id], this.argsByStoryId[t.id]);
      this.initialArgsByStoryId[t.id] = t.initialArgs, this.argsByStoryId[t.id] = t.initialArgs, r !== Vn && this.updateFromDelta(t, r);
    }
  }
  updateFromDelta(t, r) {
    let n = hU(r, t.argTypes);
    this.argsByStoryId[t.id] = hi(this.argsByStoryId[t.id], n);
  }
  updateFromPersisted(t, r) {
    let n = mU(r, t.argTypes);
    return this.updateFromDelta(t, n);
  }
  update(t, r) {
    if (!(t in this.argsByStoryId))
      throw new Error(`No args known for ${t} -- has it been rendered yet?`);
    this.argsByStoryId[t] = MEe({
      ...this.argsByStoryId[t],
      ...r
    });
  }
};
o(wR, "ArgsStore");
var my = wR;
var hy = /* @__PURE__ */ o((e = {}) => Object.entries(e).reduce((t, [r, { defaultValue: n }]) => (typeof n < "u" && (t[r] = n), t), {}), "getValuesFromArgTypes");
var TR = class TR2 {
  constructor({
    globals: t = {},
    globalTypes: r = {}
  }) {
    this.set({ globals: t, globalTypes: r });
  }
  set({ globals: t = {}, globalTypes: r = {} }) {
    let n = this.initialGlobals && yi(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(t), ...Object.keys(r)]);
    let i = hy(r);
    this.initialGlobals = { ...i, ...t }, this.globals = this.initialGlobals, n && n !== Vn && this.updateFromPersisted(n);
  }
  filterAllowedGlobals(t) {
    return Object.entries(t).reduce((r, [n, i]) => (this.allowedGlobalNames.has(n) ? r[n] = i : se.warn(
      `Attempted to set a global (${n}) that is not defined in initial globals or globalTypes`
    ), r), {});
  }
  updateFromPersisted(t) {
    let r = this.filterAllowedGlobals(t);
    this.globals = { ...this.globals, ...r };
  }
  get() {
    return this.globals;
  }
  update(t) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(t) };
    for (let r in t)
      t[r] === void 0 && (this.globals[r] = this.initialGlobals[r]);
  }
};
o(TR, "GlobalsStore");
var yy = TR;
var bU = Ne(vR(), 1);
var NEe = (0, bU.default)(1)(
  (e) => Object.values(e).reduce(
    (t, r) => (t[r.importPath] = t[r.importPath] || r, t),
    {}
  )
), RR = class RR2 {
  constructor({ entries: t } = { v: 5, entries: {} }) {
    this.entries = t;
  }
  entryFromSpecifier(t) {
    let r = Object.values(this.entries);
    if (t === "*")
      return r[0];
    if (typeof t == "string")
      return this.entries[t] ? this.entries[t] : r.find((s) => s.id.startsWith(t));
    let { name: n, title: i } = t;
    return r.find((s) => s.name === n && s.title === i);
  }
  storyIdToEntry(t) {
    let r = this.entries[t];
    if (!r)
      throw new Mi({ storyId: t });
    return r;
  }
  importPathToEntry(t) {
    return NEe(this.entries)[t];
  }
};
o(RR, "StoryIndexStore");
var by = RR;
var jEe = /* @__PURE__ */ o((e) => typeof e == "string" ? { name: e } : e, "normalizeType"), kEe = /* @__PURE__ */ o((e) => typeof e == "string" ? { type: e } : e, "normalizeControl"), LEe = /* @__PURE__ */ o((e, t) => {
  let { type: r, control: n, ...i } = e, s = {
    name: t,
    ...i
  };
  return r && (s.type = jEe(r)), n ? s.control = kEe(n) : n === false && (s.control = { disable: true }), s;
}, "normalizeInputType"), zn = /* @__PURE__ */ o((e) => Sr$1(e, LEe), "normalizeInputTypes");
var de = /* @__PURE__ */ o((e) => Array.isArray(e) ? e : e ? [e] : [], "normalizeArrays");
var FEe = Q$1`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function Gn(e, t, r) {
  let n = t, i = typeof t == "function" ? t : null, { story: s } = n;
  s && (se.debug("deprecated story", s), Ai(FEe));
  let a = FH(e), l = typeof n != "function" && n.name || n.storyName || s?.name || a, u = [
    ...de(n.decorators),
    ...de(s?.decorators)
  ], c = { ...s?.parameters, ...n.parameters }, d = { ...s?.args, ...n.args }, p = { ...s?.argTypes, ...n.argTypes }, f = [
    ...de(n.loaders),
    ...de(s?.loaders)
  ], m = [
    ...de(n.beforeEach),
    ...de(s?.beforeEach)
  ], h = [
    ...de(n.afterEach),
    ...de(s?.afterEach)
  ], { render: b, play: v, tags: g = [], globals: w = {} } = n, E = c.__id || LH(r.id, a);
  return {
    moduleExport: t,
    id: E,
    name: l,
    tags: g,
    decorators: u,
    parameters: c,
    args: d,
    argTypes: zn(p),
    loaders: f,
    beforeEach: m,
    afterEach: h,
    globals: w,
    ...b && { render: b },
    ...i && { userStoryFn: i },
    ...v && { play: v }
  };
}
o(Gn, "normalizeStory");
function wa(e, t = e.title, r) {
  let { id: n, argTypes: i } = e;
  return {
    id: pR(n || t),
    ...e,
    title: t,
    ...i && { argTypes: zn(i) },
    parameters: {
      fileName: r,
      ...e.parameters
    }
  };
}
o(wa, "normalizeComponentAnnotations");
var DEe = /* @__PURE__ */ o((e) => {
  let { globals: t, globalTypes: r } = e;
  (t || r) && se.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals: t,
      globalTypes: r
    })
  );
}, "checkGlobals"), $Ee = /* @__PURE__ */ o((e) => {
  let { options: t } = e;
  t?.storySort && se.error("The storySort option parameter can only be set globally");
}, "checkStorySort"), gy = /* @__PURE__ */ o((e) => {
  e && (DEe(e), $Ee(e));
}, "checkDisallowedParameters");
function gU(e, t, r) {
  let { default: n, __namedExportsOrder: i, ...s } = e, a = Object.values(s)[0];
  if (fi(a)) {
    let c = wa(a.meta.input, r, t);
    gy(c.parameters);
    let d = { meta: c, stories: {}, moduleExports: e };
    return Object.keys(s).forEach((p) => {
      if (va(p, c)) {
        let f = Gn(p, s[p].input, c);
        gy(f.parameters), d.stories[f.id] = f;
      }
    }), d.projectAnnotations = a.meta.preview.composed, d;
  }
  let l = wa(
    n,
    r,
    t
  );
  gy(l.parameters);
  let u = { meta: l, stories: {}, moduleExports: e };
  return Object.keys(s).forEach((c) => {
    if (va(c, l)) {
      let d = Gn(c, s[c], l);
      gy(d.parameters), u.stories[d.id] = d;
    }
  }), u;
}
o(gU, "processCSFFile");
function EU(e) {
  return e != null && BEe(e).includes("mount");
}
o(EU, "mountDestructured");
function BEe(e) {
  let t = e.toString().match(/[^(]*\(([^)]*)/);
  if (!t)
    return [];
  let r = vU(t[1]);
  if (!r.length)
    return [];
  let n = r[0];
  return n.startsWith("{") && n.endsWith("}") ? vU(n.slice(1, -1).replace(/\s/g, "")).map((s) => s.replace(/:.*|=.*/g, "")) : [];
}
o(BEe, "getUsedProps");
function vU(e) {
  let t = [], r = [], n = 0;
  for (let s = 0; s < e.length; s++)
    if (e[s] === "{" || e[s] === "[")
      r.push(e[s] === "{" ? "}" : "]");
    else if (e[s] === r[r.length - 1])
      r.pop();
    else if (!r.length && e[s] === ",") {
      let a = e.substring(n, s).trim();
      a && t.push(a), n = s + 1;
    }
  let i = e.substring(n).trim();
  return i && t.push(i), t;
}
o(vU, "splitByComma");
function SR(e, t, r) {
  let n = r(e);
  return (i) => t(n, i);
}
o(SR, "decorateStory");
function _R({
  componentId: e,
  title: t,
  kind: r,
  id: n,
  name: i,
  story: s,
  parameters: a,
  initialArgs: l,
  argTypes: u,
  ...c
} = {}) {
  return c;
}
o(_R, "sanitizeStoryContextUpdate");
function vy(e, t) {
  let r = {}, n = /* @__PURE__ */ o((s) => (a) => {
    if (!r.value)
      throw new Error("Decorated function called without init");
    return r.value = {
      ...r.value,
      ..._R(a)
    }, s(r.value);
  }, "bindWithContext"), i = t.reduce(
    (s, a) => SR(s, a, n),
    e
  );
  return (s) => (r.value = s, i(s));
}
o(vy, "defaultDecorateStory");
var Tt$1 = /* @__PURE__ */ o((...e) => {
  let t = {}, r = e.filter(Boolean), n = r.reduce((i, s) => (Object.entries(s).forEach(([a, l]) => {
    let u = i[a];
    Array.isArray(l) || typeof u > "u" ? i[a] = l : ct$1(l) && ct$1(u) ? t[a] = true : typeof l < "u" && (i[a] = l);
  }), i), {});
  return Object.keys(t).forEach((i) => {
    let s = r.filter(Boolean).map((a) => a[i]).filter((a) => typeof a < "u");
    s.every((a) => ct$1(a)) ? n[i] = Tt$1(...s) : n[i] = s[s.length - 1];
  }), n;
}, "combineParameters");
function bi(e, t, r) {
  let { moduleExport: n, id: i, name: s } = e || {}, a = xU(
    e,
    t,
    r
  ), l = /* @__PURE__ */ o(async (P) => {
    let _ = {};
    for (let C of [
      de(r.loaders),
      de(t.loaders),
      de(e.loaders)
    ]) {
      if (P.abortSignal.aborted)
        return _;
      let O = await Promise.all(C.map((L) => L(P)));
      Object.assign(_, ...O);
    }
    return _;
  }, "applyLoaders"), u = /* @__PURE__ */ o(async (P) => {
    let _ = new Array();
    for (let C of [
      ...de(r.beforeEach),
      ...de(t.beforeEach),
      ...de(e.beforeEach)
    ]) {
      if (P.abortSignal.aborted)
        return _;
      let O = await C(P);
      O && _.push(O);
    }
    return _;
  }, "applyBeforeEach"), c = /* @__PURE__ */ o(async (P) => {
    let _ = [
      ...de(r.afterEach),
      ...de(t.afterEach),
      ...de(e.afterEach)
    ].reverse();
    for (let C of _) {
      if (P.abortSignal.aborted)
        return;
      await C(P);
    }
  }, "applyAfterEach"), d = /* @__PURE__ */ o((P) => P.originalStoryFn(P.args, P), "undecoratedStoryFn"), { applyDecorators: p = vy, runStep: f } = r, m = [
    ...de(e?.decorators),
    ...de(t?.decorators),
    ...de(r?.decorators)
  ], h = e?.userStoryFn || e?.render || t.render || r.render, b = Xa(p)(d, m), v = /* @__PURE__ */ o((P) => b(P), "unboundStoryFn"), g = e?.play ?? t?.play, w = EU(g);
  if (!h && !w)
    throw new Ui({ id: i });
  let E = /* @__PURE__ */ o((P) => async () => (await P.renderToCanvas(), P.canvas), "defaultMount"), R = e.mount ?? t.mount ?? r.mount ?? E, S = r.testingLibraryRender;
  return {
    storyGlobals: {},
    ...a,
    moduleExport: n,
    id: i,
    name: s,
    story: s,
    originalStoryFn: h,
    undecoratedStoryFn: d,
    unboundStoryFn: v,
    applyLoaders: l,
    applyBeforeEach: u,
    applyAfterEach: c,
    playFunction: g,
    runStep: f,
    mount: R,
    testingLibraryRender: S,
    renderToCanvas: r.renderToCanvas,
    usesMount: w
  };
}
o(bi, "prepareStory");
function Ey(e, t, r) {
  return {
    ...xU(void 0, e, t),
    moduleExport: r
  };
}
o(Ey, "prepareMeta");
function xU(e, t, r) {
  let n = ["dev", "test"], i = k.DOCS_OPTIONS?.autodocs === true ? ["autodocs"] : [], s = DH(
    ...n,
    ...i,
    ...r.tags ?? [],
    ...t.tags ?? [],
    ...e?.tags ?? []
  ), a = Tt$1(
    r.parameters,
    t.parameters,
    e?.parameters
  ), { argTypesEnhancers: l = [], argsEnhancers: u = [] } = r, c = Tt$1(
    r.argTypes,
    t.argTypes,
    e?.argTypes
  );
  if (e) {
    let g = e?.userStoryFn || e?.render || t.render || r.render;
    a.__isArgsStory = g && g.length > 0;
  }
  let d = {
    ...r.args,
    ...t.args,
    ...e?.args
  }, p = {
    ...t.globals,
    ...e?.globals
  }, f = {
    componentId: t.id,
    title: t.title,
    kind: t.title,
    // Back compat
    id: e?.id || t.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: e?.name || "__meta",
    story: e?.name || "__meta",
    // Back compat
    component: t.component,
    subcomponents: t.subcomponents,
    tags: s,
    parameters: a,
    initialArgs: d,
    argTypes: c,
    storyGlobals: p
  };
  f.argTypes = l.reduce(
    (g, w) => w({ ...f, argTypes: g }),
    f.argTypes
  );
  let m = { ...d };
  f.initialArgs = [...u].reduce(
    (g, w) => ({
      ...g,
      ...w({
        ...f,
        initialArgs: g
      })
    }),
    m
  );
  let { name: h, story: b, ...v } = f;
  return v;
}
o(xU, "preparePartialAnnotations");
function xy(e) {
  let { args: t } = e, r = {
    ...e,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (k.FEATURES?.argTypeTargetsV7) {
    let s = yU(e);
    r = {
      ...e,
      allArgs: e.args,
      argsByTarget: s,
      args: s[xR] || {}
    };
  }
  let n = Object.entries(r.args).reduce((s, [a, l]) => {
    if (!r.argTypes[a]?.mapping)
      return s[a] = l, s;
    let u = /* @__PURE__ */ o((c) => {
      let d = r.argTypes[a].mapping;
      return d && c in d ? d[c] : c;
    }, "mappingFn");
    return s[a] = Array.isArray(l) ? l.map(u) : u(l), s;
  }, {}), i = Object.entries(n).reduce((s, [a, l]) => {
    let u = r.argTypes[a] || {};
    return yg(u, n, r.globals) && (s[a] = l), s;
  }, {});
  return { ...r, unmappedArgs: t, args: i };
}
o(xy, "prepareContext");
var CR = /* @__PURE__ */ o((e, t, r) => {
  let n = typeof e;
  switch (n) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: n };
  }
  return e ? r.has(e) ? (se.warn(Q$1`
        We've detected a cycle in arg '${t}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (r.add(e), Array.isArray(e) ? { name: "array", value: e.length > 0 ? CR(e[0], t, new Set(
    r
  )) : { name: "other", value: "unknown" } } : { name: "object", value: Sr$1(e, (s) => CR(s, t, new Set(r))) }) : { name: "object", value: {} };
}, "inferType"), PR = /* @__PURE__ */ o((e) => {
  let { id: t, argTypes: r = {}, initialArgs: n = {} } = e, i = Sr$1(n, (a, l) => ({
    name: l,
    type: CR(a, `${t}.${l}`, /* @__PURE__ */ new Set())
  })), s = Sr$1(r, (a, l) => ({
    name: l
  }));
  return Tt$1(i, s, r);
}, "inferArgTypes");
PR.secondPass = true;
var wU = /* @__PURE__ */ o((e, t) => Array.isArray(t) ? t.includes(e) : e.match(t), "matches"), Ta = /* @__PURE__ */ o((e, t, r) => !t && !r ? e : e && yR(e, (n, i) => {
  let s = n.name || i.toString();
  return !!(!t || wU(s, t)) && (!r || !wU(s, r));
}), "filterArgTypes");
var HEe = /* @__PURE__ */ o((e, t, r) => {
  let { type: n, options: i } = e;
  if (n) {
    if (r.color && r.color.test(t)) {
      let s = n.name;
      if (s === "string")
        return { control: { type: "color" } };
      s !== "enum" && se.warn(
        `Addon controls: Control of type color only supports string, received "${s}" instead`
      );
    }
    if (r.date && r.date.test(t))
      return { control: { type: "date" } };
    switch (n.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        let { value: s } = n;
        return { control: { type: s?.length <= 5 ? "radio" : "select" }, options: s };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: i ? "select" : "object" } };
    }
  }
}, "inferControl"), gi = /* @__PURE__ */ o((e) => {
  let {
    argTypes: t,
    parameters: { __isArgsStory: r, controls: { include: n = null, exclude: i = null, matchers: s = {} } = {} }
  } = e;
  if (!r)
    return t;
  let a = Ta(t, n, i), l = Sr$1(a, (u, c) => u?.type && HEe(u, c.toString(), s));
  return Tt$1(l, a);
}, "inferControls");
gi.secondPass = true;
function Wn({
  argTypes: e,
  globalTypes: t,
  argTypesEnhancers: r,
  decorators: n,
  loaders: i,
  beforeEach: s,
  afterEach: a,
  initialGlobals: l,
  ...u
}) {
  return {
    ...e && { argTypes: zn(e) },
    ...t && { globalTypes: zn(t) },
    decorators: de(n),
    loaders: de(i),
    beforeEach: de(s),
    afterEach: de(a),
    argTypesEnhancers: [
      ...r || [],
      PR,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      gi
    ],
    initialGlobals: l,
    ...u
  };
}
o(Wn, "normalizeProjectAnnotations");
var TU = /* @__PURE__ */ o((e) => async () => {
  let t = [];
  for (let r of e) {
    let n = await r();
    n && t.unshift(n);
  }
  return async () => {
    for (let r of t)
      await r();
  };
}, "composeBeforeAllHooks");
function wy(e) {
  return async (t, r, n) => {
    await e.reduceRight(
      (s, a) => async () => a(t, s, n),
      async () => r(n)
    )();
  };
}
o(wy, "composeStepRunners");
function Sa(e, t) {
  return e.map((r) => r.default?.[t] ?? r[t]).filter(Boolean);
}
o(Sa, "getField");
function cn$1(e, t, r = {}) {
  return Sa(e, t).reduce((n, i) => {
    let s = de(i);
    return r.reverseFileOrder ? [...s, ...n] : [...n, ...s];
  }, []);
}
o(cn$1, "getArrayField");
function Ty(e, t) {
  return Object.assign({}, ...Sa(e, t));
}
o(Ty, "getObjectField");
function Ra(e, t) {
  return Sa(e, t).pop();
}
o(Ra, "getSingletonField");
function _r$1(e) {
  let t = cn$1(e, "argTypesEnhancers"), r = Sa(e, "runStep"), n = cn$1(e, "beforeAll");
  return {
    parameters: Tt$1(...Sa(e, "parameters")),
    decorators: cn$1(e, "decorators", {
      reverseFileOrder: !(k.FEATURES?.legacyDecoratorFileOrder ?? false)
    }),
    args: Ty(e, "args"),
    argsEnhancers: cn$1(e, "argsEnhancers"),
    argTypes: Ty(e, "argTypes"),
    argTypesEnhancers: [
      ...t.filter((i) => !i.secondPass),
      ...t.filter((i) => i.secondPass)
    ],
    initialGlobals: Ty(e, "initialGlobals"),
    globalTypes: Ty(e, "globalTypes"),
    loaders: cn$1(e, "loaders"),
    beforeAll: TU(n),
    beforeEach: cn$1(e, "beforeEach"),
    afterEach: cn$1(e, "afterEach"),
    render: Ra(e, "render"),
    renderToCanvas: Ra(e, "renderToCanvas"),
    applyDecorators: Ra(e, "applyDecorators"),
    runStep: wy(r),
    tags: cn$1(e, "tags"),
    mount: Ra(e, "mount"),
    testingLibraryRender: Ra(e, "testingLibraryRender")
  };
}
o(_r$1, "composeConfigs");
function Ry() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return false;
  }
}
o(Ry, "isTestEnvironment");
function Yn(e = true) {
  if (!("document" in globalThis && "createElement" in globalThis.document))
    return () => {
    };
  let t = document.createElement("style");
  t.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(t);
  let r = document.createElement("style");
  return r.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(r), document.body.clientHeight, document.head.removeChild(t), () => {
    r.parentNode?.removeChild(r);
  };
}
o(Yn, "pauseAnimations");
async function Kn(e) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
    return;
  let t = false;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((r) => {
      setTimeout(() => {
        let n = [globalThis.document, ...RU(globalThis.document)], i = /* @__PURE__ */ o(async () => {
          if (t || e?.aborted)
            return;
          let s = n.flatMap((a) => a?.getAnimations?.() || []).filter((a) => a.playState === "running" && !UEe(a));
          s.length > 0 && (await Promise.all(s.map((a) => a.finished)), await i());
        }, "checkAnimationsFinished");
        i().then(r);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (r) => setTimeout(() => {
        t = true, r(void 0);
      }, 5e3)
    )
  ]);
}
o(Kn, "waitForAnimations");
function RU(e) {
  return [e, ...e.querySelectorAll("*")].reduce(
    (t, r) => ("shadowRoot" in r && r.shadowRoot && t.push(r.shadowRoot, ...RU(r.shadowRoot)), t),
    []
  );
}
o(RU, "getShadowRoots");
function UEe(e) {
  if (e instanceof CSSAnimation && e.effect instanceof KeyframeEffect && e.effect.target) {
    let t = getComputedStyle(e.effect.target, e.effect.pseudoElement), r = t.animationName?.split(", ").indexOf(e.animationName);
    return t.animationIterationCount.split(", ")[r] === "infinite";
  }
  return false;
}
o(UEe, "isInfiniteAnimation");
var AR = class AR2 {
  constructor() {
    this.reports = [];
  }
  async addReport(t) {
    this.reports.push(t);
  }
};
o(AR, "ReporterAPI");
var dn$1 = AR;
function Sy(e, t, r) {
  return fi(e) ? {
    story: e.input,
    meta: e.meta.input,
    preview: e.meta.preview.composed
  } : { story: e, meta: t, preview: r };
}
o(Sy, "getCsfFactoryAnnotations");
function SU(e) {
  globalThis.defaultProjectAnnotations = e;
}
o(SU, "setDefaultProjectAnnotations");
var VEe = "ComposedStory", zEe = "Unnamed Story";
function GEe(e) {
  return e ? _r$1([e]) : {};
}
o(GEe, "extractAnnotation");
function _U(e) {
  let t = Array.isArray(e) ? e : [e];
  return globalThis.globalProjectAnnotations = _r$1([
    ...py(),
    globalThis.defaultProjectAnnotations ?? {},
    _r$1(t.map(GEe))
  ]), globalThis.globalProjectAnnotations ?? {};
}
o(_U, "setProjectAnnotations");
var pn$1 = [];
function OR(e, t, r, n, i) {
  if (e === void 0)
    throw new Error("Expected a story but received undefined.");
  t.title = t.title ?? VEe;
  let s = wa(t), a = i || e.storyName || e.story?.name || e.name || zEe, l = Gn(
    a,
    e,
    s
  ), u = Wn(
    _r$1([
      n ?? globalThis.globalProjectAnnotations ?? {},
      r ?? {}
    ])
  ), c = bi(
    l,
    s,
    u
  ), p = {
    ...hy(u.globalTypes),
    ...u.initialGlobals,
    ...c.storyGlobals
  }, f = new dn$1(), m = /* @__PURE__ */ o(() => {
    let E = xy({
      hooks: new qr$1(),
      globals: p,
      args: { ...c.initialArgs },
      viewMode: "story",
      reporting: f,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: /* @__PURE__ */ o((R, S) => c.runStep(R, S, E), "step"),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: u.globalTypes,
      ...c,
      context: null,
      mount: null
    });
    return E.parameters.__isPortableStory = true, E.context = E, c.renderToCanvas && (E.renderToCanvas = async () => {
      let R = await c.renderToCanvas?.(
        {
          componentId: c.componentId,
          title: c.title,
          id: c.id,
          name: c.name,
          tags: c.tags,
          showMain: /* @__PURE__ */ o(() => {
          }, "showMain"),
          showError: /* @__PURE__ */ o((S) => {
            throw new Error(`${S.title}
${S.description}`);
          }, "showError"),
          showException: /* @__PURE__ */ o((S) => {
            throw S;
          }, "showException"),
          forceRemount: true,
          storyContext: E,
          storyFn: /* @__PURE__ */ o(() => c.unboundStoryFn(E), "storyFn"),
          unboundStoryFn: c.unboundStoryFn
        },
        E.canvasElement
      );
      R && pn$1.push(R);
    }), E.mount = c.mount(E), E;
  }, "initializeContext"), h, b = /* @__PURE__ */ o(async (E) => {
    let R = m();
    return R.canvasElement ??= globalThis?.document?.body, h && (R.loaded = h.loaded), Object.assign(R, E), c.playFunction(R);
  }, "play"), v = /* @__PURE__ */ o((E) => {
    let R = m();
    return Object.assign(R, E), YEe(c, R);
  }, "run"), g = c.playFunction ? b : void 0;
  return Object.assign(
    /* @__PURE__ */ o(function(R) {
      let S = m();
      return h && (S.loaded = h.loaded), S.args = {
        ...S.initialArgs,
        ...R
      }, c.unboundStoryFn(S);
    }, "storyFn"),
    {
      id: c.id,
      storyName: a,
      load: /* @__PURE__ */ o(async () => {
        for (let R of [...pn$1].reverse())
          await R();
        pn$1.length = 0;
        let E = m();
        E.loaded = await c.applyLoaders(E), pn$1.push(...(await c.applyBeforeEach(E)).filter(Boolean)), h = E;
      }, "load"),
      globals: p,
      args: c.initialArgs,
      parameters: c.parameters,
      argTypes: c.argTypes,
      play: g,
      run: v,
      reporting: f,
      tags: c.tags
    }
  );
}
o(OR, "composeStory");
var WEe = /* @__PURE__ */ o((e, t, r, n) => OR(e, t, r, {}, n), "defaultComposeStory");
function CU(e, t, r = WEe) {
  let { default: n, __esModule: i, __namedExportsOrder: s, ...a } = e, l = n;
  return Object.entries(a).reduce(
    (c, [d, p]) => {
      let { story: f, meta: m } = Sy(p);
      return !l && m && (l = m), va(d, l) ? Object.assign(c, {
        [d]: r(f, l, t, d)
      }) : c;
    },
    {}
  );
}
o(CU, "composeStories");
function PU(e) {
  return e.extend({
    mount: /* @__PURE__ */ o(async ({ mount: t, page: r }, n) => {
      await n(async (i, ...s) => {
        if (!("__pw_type" in i) || "__pw_type" in i && i.__pw_type !== "jsx")
          throw new Error(Q$1`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        let { props: a, ...l } = i;
        await r.evaluate(async (c) => {
          let d = await globalThis.__pwUnwrapObject?.(c);
          return ("__pw_type" in d ? d.type : d)?.load?.();
        }, l);
        let u = await t(i, ...s);
        return await r.evaluate(async (c) => {
          let d = await globalThis.__pwUnwrapObject?.(c), p = "__pw_type" in d ? d.type : d, f = document.querySelector("#root");
          return p?.play?.({ canvasElement: f });
        }, l), u;
      });
    }, "mount")
  });
}
o(PU, "createPlaywrightTest");
async function YEe(e, t) {
  for (let s of [...pn$1].reverse())
    await s();
  if (pn$1.length = 0, !t.canvasElement) {
    let s = document.createElement("div");
    globalThis?.document?.body?.appendChild(s), t.canvasElement = s, pn$1.push(() => {
      globalThis?.document?.body?.contains(s) && globalThis?.document?.body?.removeChild(s);
    });
  }
  if (t.loaded = await e.applyLoaders(t), t.abortSignal.aborted)
    return;
  pn$1.push(...(await e.applyBeforeEach(t)).filter(Boolean));
  let r = e.playFunction, n = e.usesMount;
  if (n || await t.mount(), t.abortSignal.aborted)
    return;
  r && (n || (t.mount = async () => {
    throw new gn({ playFunction: r.toString() });
  }), await r(t));
  let i;
  Ry() ? i = Yn() : await Kn(t.abortSignal), await e.applyAfterEach(t), await i?.();
}
o(YEe, "runStory");
var AU = 1e3, KEe = 1e4, qR = class qR2 {
  constructor(t, r, n) {
    this.importFn = r;
    this.storyIndex = new by(t), this.projectAnnotations = Wn(
      _r$1([...py(), n])
    );
    let { initialGlobals: i, globalTypes: s } = this.projectAnnotations;
    this.args = new my(), this.userGlobals = new yy({ globals: i, globalTypes: s }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, _y.default)(AU)(gU), this.prepareMetaWithCache = (0, _y.default)(AU)(Ey), this.prepareStoryWithCache = (0, _y.default)(KEe)(bi);
  }
  setProjectAnnotations(t) {
    this.projectAnnotations = Wn(t);
    let { initialGlobals: r, globalTypes: n } = t;
    this.userGlobals.set({ globals: r, globalTypes: n });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn: t,
    storyIndex: r
  }) {
    t && (this.importFn = t), r && (this.storyIndex.entries = r.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(t) {
    return this.storyIndex.storyIdToEntry(t);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(t) {
    let { importPath: r, title: n } = this.storyIndex.storyIdToEntry(t), i = await this.importFn(r);
    return this.processCSFFileWithCache(i, r, n);
  }
  async loadAllCSFFiles() {
    let t = {};
    return Object.entries(this.storyIndex.entries).forEach(([n, { importPath: i }]) => {
      t[i] = n;
    }), (await Promise.all(
      Object.entries(t).map(async ([n, i]) => ({
        importPath: n,
        csfFile: await this.loadCSFFileByStoryId(i)
      }))
    )).reduce(
      (n, { importPath: i, csfFile: s }) => (n[i] = s, n),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile: t }) {
    let r = t.meta;
    return this.prepareMetaWithCache(
      r,
      this.projectAnnotations,
      t.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId: t }) {
    let r = await this.loadCSFFileByStoryId(t);
    return this.storyFromCSFFile({ storyId: t, csfFile: r });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId: t,
    csfFile: r
  }) {
    let n = r.stories[t];
    if (!n)
      throw new Bi({ storyId: t });
    let i = r.meta, s = this.prepareStoryWithCache(
      n,
      i,
      r.projectAnnotations ?? this.projectAnnotations
    );
    return this.args.setInitial(s), this.hooks[s.id] = this.hooks[s.id] || new qr$1(), s;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile: t
  }) {
    return Object.keys(this.storyIndex.entries).filter((r) => !!t.stories[r]).map((r) => this.storyFromCSFFile({ storyId: r, csfFile: t }));
  }
  async loadEntry(t) {
    let r = await this.storyIdToEntry(t), n = r.type === "docs" ? r.storiesImports : [], [i, ...s] = await Promise.all([
      this.importFn(r.importPath),
      ...n.map((a) => {
        let l = this.storyIndex.importPathToEntry(a);
        return this.loadCSFFileByStoryId(l.id);
      })
    ]);
    return { entryExports: i, csfFiles: s };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separtely to the (immutable) story.
  getStoryContext(t, { forceInitialArgs: r = false } = {}) {
    let n = this.userGlobals.get(), { initialGlobals: i } = this.userGlobals, s = new dn$1();
    return xy({
      ...t,
      args: r ? t.initialArgs : this.args.get(t.id),
      initialGlobals: i,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals: n,
      reporting: s,
      globals: {
        ...n,
        ...t.storyGlobals
      },
      hooks: this.hooks[t.id]
    });
  }
  addCleanupCallbacks(t, ...r) {
    this.cleanupCallbacks[t.id] = (this.cleanupCallbacks[t.id] || []).concat(r);
  }
  async cleanupStory(t) {
    this.hooks[t.id].clean();
    let r = this.cleanupCallbacks[t.id];
    if (r)
      for (let n of [...r].reverse())
        await n();
    delete this.cleanupCallbacks[t.id];
  }
  extract(t = { includeDocsOnly: false }) {
    let { cachedCSFFiles: r } = this;
    if (!r)
      throw new ji();
    return Object.entries(this.storyIndex.entries).reduce(
      (n, [i, { type: s, importPath: a }]) => {
        if (s === "docs")
          return n;
        let l = r[a], u = this.storyFromCSFFile({ storyId: i, csfFile: l });
        return !t.includeDocsOnly && u.parameters.docsOnly || (n[i] = Object.entries(u).reduce(
          (c, [d, p]) => d === "moduleExport" || typeof p == "function" ? c : Array.isArray(p) ? Object.assign(c, { [d]: p.slice().sort() }) : Object.assign(c, { [d]: p }),
          {
            //
            args: u.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...u.storyGlobals
            }
          }
        )), n;
      },
      {}
    );
  }
};
o(qR, "StoryStore");
var Xn = qR;
function IR(e) {
  return e.startsWith("\\\\?\\") ? e : e.replace(/\\/g, "/");
}
o(IR, "slash");
var XEe = /* @__PURE__ */ o((e) => {
  if (e.length === 0)
    return e;
  let t = e[e.length - 1], r = t?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (e.length === 1)
    return [r];
  let n = e[e.length - 2];
  return r && n && r.toLowerCase() === n.toLowerCase() ? [...e.slice(0, -2), r] : r && (/^(story|stories)([.][^.]+)$/i.test(t) || /^index$/i.test(r)) ? e.slice(0, -1) : [...e.slice(0, -1), r];
}, "sanitize");
function OU(e) {
  return e.flatMap((t) => t.split("/")).filter(Boolean).join("/");
}
o(OU, "pathJoin");
var MR = /* @__PURE__ */ o((e, t, r) => {
  let { directory: n, importPathMatcher: i, titlePrefix: s = "" } = t || {};
  typeof e == "number" && be.warn(Q$1`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let a = IR(String(e));
  if (i.exec(a)) {
    if (!r) {
      let l = a.replace(n, ""), u = OU([s, l]).split("/");
      return u = XEe(u), u.join("/");
    }
    return s ? OU([s, r]) : r;
  }
}, "userOrAutoTitleFromSpecifier"), qU = /* @__PURE__ */ o((e, t, r) => {
  for (let n = 0; n < t.length; n += 1) {
    let i = MR(e, t[n], r);
    if (i)
      return i;
  }
  return r || void 0;
}, "userOrAutoTitle");
var IU = /\s*\/\s*/, MU = /* @__PURE__ */ o((e = {}) => (t, r) => {
  if (t.title === r.title && !e.includeNames)
    return 0;
  let n = e.method || "configure", i = e.order || [], s = t.title.trim().split(IU), a = r.title.trim().split(IU);
  e.includeNames && (s.push(t.name), a.push(r.name));
  let l = 0;
  for (; s[l] || a[l]; ) {
    if (!s[l])
      return -1;
    if (!a[l])
      return 1;
    let u = s[l], c = a[l];
    if (u !== c) {
      let p = i.indexOf(u), f = i.indexOf(c), m = i.indexOf("*");
      return p !== -1 || f !== -1 ? (p === -1 && (m !== -1 ? p = m : p = i.length), f === -1 && (m !== -1 ? f = m : f = i.length), p - f) : n === "configure" ? 0 : u.localeCompare(c, e.locales ? e.locales : void 0, {
        numeric: true,
        sensitivity: "accent"
      });
    }
    let d = i.indexOf(u);
    d === -1 && (d = i.indexOf("*")), i = d !== -1 && Array.isArray(i[d + 1]) ? i[d + 1] : [], l += 1;
  }
  return 0;
}, "storySort");
var JEe = /* @__PURE__ */ o((e, t, r) => {
  if (t) {
    let n;
    typeof t == "function" ? n = t : n = MU(t), e.sort(n);
  } else
    e.sort(
      (n, i) => r.indexOf(n.importPath) - r.indexOf(i.importPath)
    );
  return e;
}, "sortStoriesCommon"), NU = /* @__PURE__ */ o((e, t, r) => {
  try {
    return JEe(e, t, r);
  } catch (n) {
    throw new Error(Q$1`
    Error sorting stories with sort parameter ${t}:

    > ${n.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
}, "sortStoriesV7");
var fn$1 = new Error("prepareAborted");
var { AbortController: jU } = globalThis;
function kU(e) {
  try {
    let { name: t = "Error", message: r = String(e), stack: n } = e;
    return { name: t, message: r, stack: n };
  } catch {
    return { name: "Error", message: String(e) };
  }
}
o(kU, "serializeError");
var NR = class NR2 {
  constructor(t, r, n, i, s, a, l = { autoplay: true, forceInitialArgs: false }, u) {
    this.channel = t;
    this.store = r;
    this.renderToScreen = n;
    this.callbacks = i;
    this.id = s;
    this.viewMode = a;
    this.renderOptions = l;
    this.type = "story";
    this.notYetRendered = true;
    this.rerenderEnqueued = false;
    this.disableKeyListeners = false;
    this.teardownRender = /* @__PURE__ */ o(() => {
    }, "teardownRender");
    this.torndown = false;
    this.abortController = new jU(), this.renderId = Date.now(), u && (this.story = u, this.phase = "preparing");
  }
  async runPhase(t, r, n) {
    this.phase = r, this.channel.emit(jt, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    }), n && (await n(), this.checkIfAborted(t));
  }
  checkIfAborted(t) {
    return t.aborted ? (this.phase = "aborted", this.channel.emit(jt, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    }), true) : false;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), fn$1;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(t) {
    return !!(this.id === t.id && this.story && this.story === t.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(t) {
    return this.canvasElement = t, this.render({ initial: true, forceRemount: true });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    let { forceInitialArgs: t } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: t });
  }
  async render({
    initial: t = false,
    forceRemount: r = false
  } = {}) {
    let { canvasElement: n } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    let i = this.story;
    if (!n)
      throw new Error("cannot render when canvasElement is unset");
    let {
      id: s,
      componentId: a,
      title: l,
      name: u,
      tags: c,
      applyLoaders: d,
      applyBeforeEach: p,
      applyAfterEach: f,
      unboundStoryFn: m,
      playFunction: h,
      runStep: b
    } = i;
    r && !t && (this.cancelRender(), this.abortController = new jU());
    let v = this.abortController.signal, g = false, w = i.usesMount;
    try {
      let E = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: v,
        canvasElement: n,
        loaded: {},
        step: /* @__PURE__ */ o((H, M) => b(H, M, E), "step"),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: /* @__PURE__ */ o(async () => {
          let H = await this.renderToScreen(R, n);
          this.teardownRender = H || (() => {
          }), g = true;
        }, "renderToCanvas"),
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: /* @__PURE__ */ o(async (...H) => {
          this.callbacks.showStoryDuringRender?.();
          let M = null;
          return await this.runPhase(v, "rendering", async () => {
            M = await i.mount(E)(...H);
          }), w && await this.runPhase(v, "playing"), M;
        }, "mount")
      };
      E.context = E;
      let R = {
        componentId: a,
        title: l,
        kind: l,
        id: s,
        name: u,
        story: u,
        tags: c,
        ...this.callbacks,
        showError: /* @__PURE__ */ o((H) => (this.phase = "errored", this.callbacks.showError(H)), "showError"),
        showException: /* @__PURE__ */ o((H) => (this.phase = "errored", this.callbacks.showException(H)), "showException"),
        forceRemount: r || this.notYetRendered,
        storyContext: E,
        storyFn: /* @__PURE__ */ o(() => m(E), "storyFn"),
        unboundStoryFn: m
      };
      if (await this.runPhase(v, "loading", async () => {
        E.loaded = await d(E);
      }), v.aborted)
        return;
      let S = await p(E);
      if (this.store.addCleanupCallbacks(i, ...S), this.checkIfAborted(v) || (!g && !w && await E.mount(), this.notYetRendered = false, v.aborted))
        return;
      let P = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === true, _ = /* @__PURE__ */ new Set(), C = /* @__PURE__ */ o((H) => {
        H.error && _.add(H.error);
      }, "onError"), O = /* @__PURE__ */ o((H) => {
        H.reason && _.add(H.reason);
      }, "onUnhandledRejection");
      if (this.renderOptions.autoplay && r && h && this.phase !== "errored") {
        window?.addEventListener?.("error", C), window?.addEventListener?.("unhandledrejection", O), this.disableKeyListeners = true;
        try {
          if (w ? await h(E) : (E.mount = async () => {
            throw new gn({ playFunction: h.toString() });
          }, await this.runPhase(v, "playing", async () => h(E))), !g)
            throw new Vi();
          this.checkIfAborted(v), !P && _.size > 0 ? await this.runPhase(v, "errored") : await this.runPhase(v, "played");
        } catch (H) {
          if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(v, "errored", async () => {
            this.channel.emit(zy, kU(H));
          }), this.story.parameters.throwPlayFunctionExceptions !== false)
            throw H;
          console.error(H);
        }
        if (!P && _.size > 0 && this.channel.emit(
          Gy,
          Array.from(_).map(kU)
        ), this.disableKeyListeners = false, window?.removeEventListener?.("unhandledrejection", O), window?.removeEventListener?.("error", C), v.aborted)
          return;
      }
      await this.runPhase(v, "completing", async () => {
        Ry() ? this.store.addCleanupCallbacks(i, Yn()) : await Kn(v);
      }), await this.runPhase(v, "completed", async () => {
        this.channel.emit(uo, s);
      }), this.phase !== "errored" && await this.runPhase(v, "afterEach", async () => {
        await f(E);
      });
      let L = !P && _.size > 0, q = E.reporting.reports.some(
        (H) => H.status === "failed"
      ), D = L || q;
      await this.runPhase(
        v,
        "finished",
        async () => this.channel.emit(Da, {
          storyId: s,
          status: D ? "error" : "success",
          reporters: E.reporting.reports
        })
      );
    } catch (E) {
      this.phase = "errored", this.callbacks.showException(E), await this.runPhase(
        v,
        "finished",
        async () => this.channel.emit(Da, {
          storyId: s,
          status: "error",
          reporters: []
        })
      );
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = false, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = true;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: true });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === "playing" && (this.abortController.abort(), this.runPhase(this.abortController.signal, "aborted"));
  }
  async teardown() {
    this.torndown = true, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let t = 0; t < 3; t += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((r) => setTimeout(r, 0));
    }
    window?.location?.reload?.(), await new Promise(() => {
    });
  }
};
o(NR, "StoryRender");
var Jn = NR;
var { fetch: QEe } = k, ZEe = "./index.json", jR = class jR2 {
  constructor(t, r, n = He.getChannel(), i = true) {
    this.importFn = t;
    this.getProjectAnnotations = r;
    this.channel = n;
    this.storyRenders = [];
    this.storeInitializationPromise = new Promise((s, a) => {
      this.resolveStoreInitializationPromise = s, this.rejectStoreInitializationPromise = a;
    }), i && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: /* @__PURE__ */ o((t, r) => {
          if (this.storyStoreValue)
            return Ai("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[r];
          throw new Hi();
        }, "get")
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      let t = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(t), await this.initializeWithProjectAnnotations(t);
    } catch (t) {
      this.rejectStoreInitializationPromise(t);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(Zy, this.onStoryIndexChanged.bind(this)), this.channel.on(Ci, this.onUpdateGlobals.bind(this)), this.channel.on(Pi, this.onUpdateArgs.bind(this)), this.channel.on(ab, this.onRequestArgTypesInfo.bind(this)), this.channel.on(Si, this.onResetArgs.bind(this)), this.channel.on(Ri, this.onForceReRender.bind(this)), this.channel.on(lo, this.onForceRemount.bind(this)), this.channel.on(ob, this.onStoryHotUpdated.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      let t = await this.getProjectAnnotations();
      if (this.renderToCanvas = t.renderToCanvas, !this.renderToCanvas)
        throw new ki();
      return t;
    } catch (t) {
      throw this.renderPreviewEntryError("Error reading preview.js:", t), t;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(t) {
    this.projectAnnotationsBeforeInitialization = t;
    try {
      let r = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(r);
    } catch (r) {
      throw this.renderPreviewEntryError("Error loading story index:", r), r;
    }
  }
  async runBeforeAllHook(t) {
    try {
      await this.beforeAllCleanup?.(), this.beforeAllCleanup = await t.beforeAll?.();
    } catch (r) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", r), r;
    }
  }
  async getStoryIndexFromServer() {
    let t = await QEe(ZEe);
    if (t.status === 200)
      return t.json();
    throw new Li({ text: await t.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(t) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new Xn(
      t,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new We({ methodName: "emitGlobals" });
    let t = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(Ky, t);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: t
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = t;
    let r = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(r), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(r);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(r), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        let t = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(t);
          return;
        }
        await this.onStoriesChanged({ storyIndex: t });
      } catch (t) {
        throw this.renderPreviewEntryError("Error loading story index:", t), t;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: t,
    storyIndex: r
  }) {
    if (!this.storyStoreValue)
      throw new We({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn: t, storyIndex: r });
  }
  async onUpdateGlobals({
    globals: t,
    currentStory: r
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new We({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(t), r) {
      let { initialGlobals: n, storyGlobals: i, userGlobals: s, globals: a } = this.storyStoreValue.getStoryContext(r);
      this.channel.emit(bn, {
        initialGlobals: n,
        userGlobals: s,
        storyGlobals: i,
        globals: a
      });
    } else {
      let { initialGlobals: n, globals: i } = this.storyStoreValue.userGlobals;
      this.channel.emit(bn, {
        initialGlobals: n,
        userGlobals: i,
        storyGlobals: {},
        globals: i
      });
    }
    await Promise.all(this.storyRenders.map((n) => n.rerender()));
  }
  async onUpdateArgs({ storyId: t, updatedArgs: r }) {
    if (!this.storyStoreValue)
      throw new We({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(t, r), await Promise.all(
      this.storyRenders.filter((n) => n.id === t && !n.renderOptions.forceInitialArgs).map(
        (n) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          n.story && n.story.usesMount ? n.remount() : n.rerender()
        )
      )
    ), this.channel.emit(Xy, {
      storyId: t,
      args: this.storyStoreValue.args.get(t)
    });
  }
  async onRequestArgTypesInfo({ id: t, payload: r }) {
    try {
      await this.storeInitializationPromise;
      let n = await this.storyStoreValue?.loadStory(r);
      this.channel.emit($a, {
        id: t,
        success: true,
        payload: { argTypes: n?.argTypes || {} },
        error: null
      });
    } catch (n) {
      this.channel.emit($a, {
        id: t,
        success: false,
        error: n?.message
      });
    }
  }
  async onResetArgs({ storyId: t, argNames: r }) {
    if (!this.storyStoreValue)
      throw new We({ methodName: "onResetArgs" });
    let i = this.storyRenders.find((l) => l.id === t)?.story || await this.storyStoreValue.loadStory({ storyId: t }), a = (r || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(i.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(t))
      ])
    ]).reduce((l, u) => (l[u] = i.initialArgs[u], l), {});
    await this.onUpdateArgs({ storyId: t, updatedArgs: a });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((t) => t.rerender()));
  }
  async onForceRemount({ storyId: t }) {
    await Promise.all(this.storyRenders.filter((r) => r.id === t).map((r) => r.remount()));
  }
  async onStoryHotUpdated() {
    await Promise.all(this.storyRenders.map((t) => t.cancelPlayFunction()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(t, r, n, i) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new We({
        methodName: "renderStoryToElement"
      });
    let s = new Jn(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      n,
      t.id,
      "docs",
      i,
      t
    );
    return s.renderToElement(r), this.storyRenders.push(s), async () => {
      await this.teardownRender(s);
    };
  }
  async teardownRender(t, { viewModeChanged: r } = {}) {
    this.storyRenders = this.storyRenders.filter((n) => n !== t), await t?.teardown?.({ viewModeChanged: r });
  }
  // API
  async loadStory({ storyId: t }) {
    if (!this.storyStoreValue)
      throw new We({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId: t });
  }
  getStoryContext(t, { forceInitialArgs: r = false } = {}) {
    if (!this.storyStoreValue)
      throw new We({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(t, { forceInitialArgs: r });
  }
  async extract(t) {
    if (!this.storyStoreValue)
      throw new We({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(t);
  }
  // UTILITIES
  renderPreviewEntryError(t, r) {
    this.previewEntryError = r, se.error(t), se.error(r), this.channel.emit(Uy, r);
  }
};
o(jR, "Preview");
var Qn = jR;
var kR = class kR2 {
  constructor(t, r, n, i) {
    this.channel = t;
    this.store = r;
    this.renderStoryToElement = n;
    this.storyIdByName = /* @__PURE__ */ o((t7) => {
      let r7 = this.nameToStoryId.get(t7);
      if (r7)
        return r7;
      throw new Error(`No story found with that name: ${t7}`);
    }, "storyIdByName");
    this.componentStories = /* @__PURE__ */ o(() => this.componentStoriesValue, "componentStories");
    this.componentStoriesFromCSFFile = /* @__PURE__ */ o((t7) => this.store.componentStoriesFromCSFFile({ csfFile: t7 }), "componentStoriesFromCSFFile");
    this.storyById = /* @__PURE__ */ o((t7) => {
      if (!t7) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      let r7 = this.storyIdToCSFFile.get(t7);
      if (!r7)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${t7}`);
      return this.store.storyFromCSFFile({ storyId: t7, csfFile: r7 });
    }, "storyById");
    this.getStoryContext = /* @__PURE__ */ o((t7) => ({
      ...this.store.getStoryContext(t7),
      loaded: {},
      viewMode: "docs"
    }), "getStoryContext");
    this.loadStory = /* @__PURE__ */ o((t7) => this.store.loadStory({ storyId: t7 }), "loadStory");
    this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), i.forEach((s, a) => {
      this.referenceCSFFile(s);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(t) {
    this.exportsToCSFFile.set(t.moduleExports, t), this.exportsToCSFFile.set(t.moduleExports.default, t), this.store.componentStoriesFromCSFFile(
      { csfFile: t }
    ).forEach((n) => {
      let i = t.stories[n.id];
      this.storyIdToCSFFile.set(i.id, t), this.exportToStory.set(i.moduleExport, n);
    });
  }
  attachCSFFile(t) {
    if (!this.exportsToCSFFile.has(t.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    if (this.attachedCSFFiles.has(t))
      return;
    this.attachedCSFFiles.add(t), this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((n) => {
      this.nameToStoryId.set(n.name, n.id), this.componentStoriesValue.push(n), this.primaryStory || (this.primaryStory = n);
    });
  }
  referenceMeta(t, r) {
    let n = this.resolveModuleExport(t);
    if (n.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    r && this.attachCSFFile(n.csfFile);
  }
  get projectAnnotations() {
    let { projectAnnotations: t } = this.store;
    if (!t)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return t;
  }
  resolveAttachedModuleExportType(t) {
    if (t === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    let r = Array.from(this.attachedCSFFiles)[0];
    if (t === "meta")
      return { type: "meta", csfFile: r };
    let { component: n } = r.meta;
    if (!n)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component: n };
  }
  resolveModuleExport(t) {
    let r = this.exportsToCSFFile.get(t);
    if (r)
      return { type: "meta", csfFile: r };
    let n = this.exportToStory.get(
      fi(t) ? t.input : t
    );
    return n ? { type: "story", story: n } : { type: "component", component: t };
  }
  resolveOf(t, r = []) {
    let n;
    if (["component", "meta", "story"].includes(t)) {
      let i = t;
      n = this.resolveAttachedModuleExportType(i);
    } else
      n = this.resolveModuleExport(t);
    if (r.length && !r.includes(n.type)) {
      let i = n.type === "component" ? "component or unknown" : n.type;
      throw new Error(Q$1`Invalid value passed to the 'of' prop. The value was resolved to a '${i}' type but the only types for this block are: ${r.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (n.type) {
      case "component":
        return {
          ...n,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...n,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: n.csfFile })
        };
      case "story":
      default:
        return n;
    }
  }
};
o(kR, "DocsContext");
var Cr$1 = kR;
var LR = class LR2 {
  constructor(t, r, n, i) {
    this.channel = t;
    this.store = r;
    this.entry = n;
    this.callbacks = i;
    this.type = "docs";
    this.subtype = "csf";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = n.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw fn$1;
    let { importPath: n, title: i } = this.entry, s = this.store.processCSFFileWithCache(
      t,
      n,
      i
    ), a = Object.keys(s.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: a, csfFile: s }), this.csfFiles = [s, ...r], this.preparing = false;
  }
  isEqual(t) {
    return !!(this.id === t.id && this.story && this.story === t.story);
  }
  docsContext(t) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let r = new Cr$1(
      this.channel,
      this.store,
      t,
      this.csfFiles
    );
    return this.csfFiles.forEach((n) => r.attachCSFFile(n)), r;
  }
  async renderToElement(t, r) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    let n = this.docsContext(r), { docs: i } = this.story.parameters || {};
    if (!i)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let s = await i.renderer(), { render: a } = s, l = /* @__PURE__ */ o(async () => {
      try {
        await a(n, i, t), this.channel.emit(Ti, this.id);
      } catch (u) {
        this.callbacks.showException(u);
      }
    }, "renderDocs");
    return this.rerender = async () => l(), this.teardownRender = async ({ viewModeChanged: u }) => {
      !u || !t || s.unmount(t);
    }, l();
  }
  async teardown({ viewModeChanged: t } = {}) {
    this.teardownRender?.({ viewModeChanged: t }), this.torndown = true;
  }
};
o(LR, "CsfDocsRender");
var _a = LR;
var FR = class FR2 {
  constructor(t, r, n, i) {
    this.channel = t;
    this.store = r;
    this.entry = n;
    this.callbacks = i;
    this.type = "docs";
    this.subtype = "mdx";
    this.torndown = false;
    this.disableKeyListeners = false;
    this.preparing = false;
    this.id = n.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = true;
    let { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw fn$1;
    this.csfFiles = r, this.exports = t, this.preparing = false;
  }
  isEqual(t) {
    return !!(this.id === t.id && this.exports && this.exports === t.exports);
  }
  docsContext(t) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new Cr$1(
      this.channel,
      this.store,
      t,
      this.csfFiles
    );
  }
  async renderToElement(t, r) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    let n = this.docsContext(r), { docs: i } = this.store.projectAnnotations.parameters ?? {};
    if (!i)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    let s = { ...i, page: this.exports.default }, a = await i.renderer(), { render: l } = a, u = /* @__PURE__ */ o(async () => {
      try {
        await l(n, s, t), this.channel.emit(Ti, this.id);
      } catch (c) {
        this.callbacks.showException(c);
      }
    }, "renderDocs");
    return this.rerender = async () => u(), this.teardownRender = async ({ viewModeChanged: c } = {}) => {
      !c || !t || (a.unmount(t), this.torndown = true);
    }, u();
  }
  async teardown({ viewModeChanged: t } = {}) {
    this.teardownRender?.({ viewModeChanged: t }), this.torndown = true;
  }
};
o(FR, "MdxDocsRender");
var Ca = FR;
var exe = globalThis;
function txe(e) {
  let t = e.composedPath && e.composedPath()[0] || e.target;
  return /input|textarea/i.test(t.tagName) || t.getAttribute("contenteditable") !== null;
}
o(txe, "focusInInput");
var LU = "attached-mdx", rxe = "unattached-mdx";
function nxe({ tags: e }) {
  return e?.includes(rxe) || e?.includes(LU);
}
o(nxe, "isMdxEntry");
function DR(e) {
  return e.type === "story";
}
o(DR, "isStoryRender");
function oxe(e) {
  return e.type === "docs";
}
o(oxe, "isDocsRender");
function ixe(e) {
  return oxe(e) && e.subtype === "csf";
}
o(ixe, "isCsfDocsRender");
var $R = class $R2 extends Qn {
  constructor(r, n, i, s) {
    super(r, n, void 0, false);
    this.importFn = r;
    this.getProjectAnnotations = n;
    this.selectionStore = i;
    this.view = s;
    this.initialize();
  }
  setupListeners() {
    super.setupListeners(), exe.onkeydown = this.onKeydown.bind(this), this.channel.on(_i, this.onSetCurrentStory.bind(this)), this.channel.on(ib, this.onUpdateQueryParams.bind(this)), this.channel.on(Wy, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue)
      throw new We({ methodName: "setInitialGlobals" });
    let { globals: r } = this.selectionStore.selectionSpecifier || {};
    r && this.storyStoreValue.userGlobals.updateFromPersisted(r), this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(r) {
    return await super.initializeWithStoryIndex(r), this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue)
      throw new We({
        methodName: "selectSpecifiedStory"
      });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    let { storySpecifier: r, args: n } = this.selectionStore.selectionSpecifier, i = this.storyStoreValue.storyIndex.entryFromSpecifier(r);
    if (!i) {
      r === "*" ? this.renderStoryLoadingException(r, new Di()) : this.renderStoryLoadingException(
        r,
        new $i({ storySpecifier: r.toString() })
      );
      return;
    }
    let { id: s, type: a } = i;
    this.selectionStore.setSelection({ storyId: s, viewMode: a }), this.channel.emit(tb, this.selectionStore.selection), this.channel.emit(
      La,
      this.selectionStore.selection
    ), await this.renderSelection({ persistedArgs: n });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: r
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: r }), this.selectionStore.selection && this.renderSelection();
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: r,
    storyIndex: n
  }) {
    await super.onStoriesChanged({ importFn: r, storyIndex: n }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(r) {
    if (!this.storyRenders.find((n) => n.disableKeyListeners) && !txe(r)) {
      let { altKey: n, ctrlKey: i, metaKey: s, shiftKey: a, key: l, code: u, keyCode: c } = r;
      this.channel.emit(Yy, {
        event: { altKey: n, ctrlKey: i, metaKey: s, shiftKey: a, key: l, code: u, keyCode: c }
      });
    }
  }
  async onSetCurrentStory(r) {
    this.selectionStore.setSelection({ viewMode: "story", ...r }), await this.storeInitializationPromise, this.channel.emit(La, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(r) {
    this.selectionStore.setQueryParams(r);
  }
  async onUpdateGlobals({ globals: r }) {
    let n = this.currentRender instanceof Jn && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals: r, currentStory: n }), (this.currentRender instanceof Ca || this.currentRender instanceof _a) && await this.currentRender.rerender?.();
  }
  async onUpdateArgs({ storyId: r, updatedArgs: n }) {
    super.onUpdateArgs({ storyId: r, updatedArgs: n });
  }
  async onPreloadStories({ ids: r }) {
    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(r.map((n) => this.storyStoreValue?.loadEntry(n)));
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs: r } = {}) {
    let { renderToCanvas: n } = this;
    if (!this.storyStoreValue || !n)
      throw new We({ methodName: "renderSelection" });
    let { selection: i } = this.selectionStore;
    if (!i)
      throw new Error("Cannot call renderSelection as no selection was made");
    let { storyId: s } = i, a;
    try {
      a = await this.storyStoreValue.storyIdToEntry(s);
    } catch (m) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(s, m);
      return;
    }
    let l = this.currentSelection?.storyId !== s, u = this.currentRender?.type !== a.type;
    a.type === "story" ? this.view.showPreparingStory({ immediate: u }) : this.view.showPreparingDocs({ immediate: u }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);
    let c;
    a.type === "story" ? c = new Jn(
      this.channel,
      this.storyStoreValue,
      n,
      this.mainStoryCallbacks(s),
      s,
      "story"
    ) : nxe(a) ? c = new Ca(
      this.channel,
      this.storyStoreValue,
      a,
      this.mainStoryCallbacks(s)
    ) : c = new _a(
      this.channel,
      this.storyStoreValue,
      a,
      this.mainStoryCallbacks(s)
    );
    let d = this.currentSelection;
    this.currentSelection = i;
    let p = this.currentRender;
    this.currentRender = c;
    try {
      await c.prepare();
    } catch (m) {
      p && await this.teardownRender(p), m !== fn$1 && this.renderStoryLoadingException(s, m);
      return;
    }
    let f = !l && p && !c.isEqual(p);
    if (r && DR(c) && (gt$1(!!c.story), this.storyStoreValue.args.updateFromPersisted(c.story, r)), p && !p.torndown && !l && !f && !u) {
      this.currentRender = p, this.channel.emit(nb, s), this.view.showMain();
      return;
    }
    if (p && await this.teardownRender(p, { viewModeChanged: u }), d && (l || u) && this.channel.emit(Jy, s), DR(c)) {
      gt$1(!!c.story);
      let {
        parameters: m,
        initialArgs: h,
        argTypes: b,
        unmappedArgs: v,
        initialGlobals: g,
        userGlobals: w,
        storyGlobals: E,
        globals: R
      } = this.storyStoreValue.getStoryContext(c.story);
      this.channel.emit(eb, {
        id: s,
        parameters: m,
        initialArgs: h,
        argTypes: b,
        args: v
      }), this.channel.emit(bn, { userGlobals: w, storyGlobals: E, globals: R, initialGlobals: g });
    } else {
      let { parameters: m } = this.storyStoreValue.projectAnnotations, { initialGlobals: h, globals: b } = this.storyStoreValue.userGlobals;
      if (this.channel.emit(bn, {
        globals: b,
        initialGlobals: h,
        storyGlobals: {},
        userGlobals: b
      }), ixe(c) || c.entry.tags?.includes(LU)) {
        if (!c.csfFiles)
          throw new Fi({ storyId: s });
        ({ parameters: m } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: c.csfFiles[0]
        }));
      }
      this.channel.emit(Vy, {
        id: s,
        parameters: m
      });
    }
    DR(c) ? (gt$1(!!c.story), this.storyRenders.push(c), this.currentRender.renderToElement(
      this.view.prepareForStory(c.story)
    )) : this.currentRender.renderToElement(
      this.view.prepareForDocs(),
      // This argument is used for docs, which is currently only compatible with HTMLElements
      this.renderStoryToElement.bind(this)
    );
  }
  async teardownRender(r, { viewModeChanged: n = false } = {}) {
    this.storyRenders = this.storyRenders.filter((i) => i !== r), await r?.teardown?.({ viewModeChanged: n });
  }
  // UTILITIES
  mainStoryCallbacks(r) {
    return {
      showStoryDuringRender: /* @__PURE__ */ o(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
      showMain: /* @__PURE__ */ o(() => this.view.showMain(), "showMain"),
      showError: /* @__PURE__ */ o((n) => this.renderError(r, n), "showError"),
      showException: /* @__PURE__ */ o((n) => this.renderException(r, n), "showException")
    };
  }
  renderPreviewEntryError(r, n) {
    super.renderPreviewEntryError(r, n), this.view.showErrorDisplay(n);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(Fa);
  }
  renderStoryLoadingException(r, n) {
    se.error(n), this.view.showErrorDisplay(n), this.channel.emit(Fa, r);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(r, n) {
    let { name: i = "Error", message: s = String(n), stack: a } = n, l = this.currentRender?.renderId;
    this.channel.emit(rb, { name: i, message: s, stack: a }), this.channel.emit(jt, { newPhase: "errored", renderId: l, storyId: r }), this.view.showErrorDisplay(n), se.error(`Error rendering story '${r}':`), se.error(n);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(r, { title: n, description: i }) {
    let s = this.currentRender?.renderId;
    this.channel.emit(Qy, { title: n, description: i }), this.channel.emit(jt, { newPhase: "errored", renderId: s, storyId: r }), this.view.showErrorDisplay({ message: n, stack: i }), se.error(`Error rendering story ${n}: ${i}`);
  }
};
o($R, "PreviewWithSelection");
var Zn = $R;
var Aa = Ne(qy(), 1);
var XU = Ne(qy(), 1);
var KU = /^[a-zA-Z0-9 _-]*$/, JU = /^-?[0-9]+(\.[0-9]+)?$/, qxe = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i, QU = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i, WR = /* @__PURE__ */ o((e = "", t) => e === null || e === "" || !KU.test(e) ? false : t == null || t instanceof Date || typeof t == "number" || typeof t == "boolean" ? true : typeof t == "string" ? KU.test(t) || JU.test(t) || qxe.test(t) || QU.test(t) : Array.isArray(t) ? t.every((r) => WR(
  e,
  r
)) : ct$1(t) ? Object.entries(t).every(([r, n]) => WR(r, n)) : false, "validateArgs"), Ixe = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: true,
  arrayRepeat: true,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(e) {
    if (e.startsWith("!")) {
      if (e === "!undefined")
        return;
      if (e === "!null")
        return null;
      if (e === "!true")
        return true;
      if (e === "!false")
        return false;
      if (e.startsWith("!date(") && e.endsWith(")"))
        return new Date(e.replaceAll(" ", "+").slice(6, -1));
      if (e.startsWith("!hex(") && e.endsWith(")"))
        return `#${e.slice(5, -1)}`;
      let t = e.slice(1).match(QU);
      if (t)
        return e.startsWith("!rgba") || e.startsWith("!RGBA") ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]}, ${t[5]})` : e.startsWith("!hsla") || e.startsWith(
          "!HSLA"
        ) ? `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%, ${t[5]})` : e.startsWith("!rgb") || e.startsWith("!RGB") ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]})` : `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%)`;
    }
    return JU.test(e) ? Number(e) : e;
  }
}, YR = /* @__PURE__ */ o((e) => {
  let t = e.split(";").map((r) => r.replace("=", "~").replace(":", "="));
  return Object.entries((0, XU.parse)(t.join(";"), Ixe)).reduce((r, [n, i]) => WR(n, i) ? Object.assign(r, { [n]: i }) : (be.warn(Q$1`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `), r), {});
}, "parseArgsParam");
var { history: ZU, document: mn$1 } = k;
function Mxe(e) {
  let t = (e || "").match(/^\/story\/(.+)/);
  if (!t)
    throw new Error(`Invalid path '${e}',  must start with '/story/'`);
  return t[1];
}
o(Mxe, "pathToId");
var e5 = /* @__PURE__ */ o(({
  selection: e,
  extraParams: t
}) => {
  let r = mn$1?.location.search.slice(1), { path: n, selectedKind: i, selectedStory: s, ...a } = (0, Aa.parse)(r);
  return `?${(0, Aa.stringify)({
    ...a,
    ...t,
    ...e && { id: e.storyId, viewMode: e.viewMode }
  })}`;
}, "getQueryString"), Nxe = /* @__PURE__ */ o((e) => {
  if (!e)
    return;
  let t = e5({ selection: e }), { hash: r = "" } = mn$1.location;
  mn$1.title = e.storyId, ZU.replaceState({}, "", `${mn$1.location.pathname}${t}${r}`);
}, "setPath"), jxe = /* @__PURE__ */ o((e) => e != null && typeof e == "object" && Array.isArray(e) === false, "isObject"), Pa = /* @__PURE__ */ o(
  (e) => {
    if (e !== void 0) {
      if (typeof e == "string")
        return e;
      if (Array.isArray(e))
        return Pa(e[0]);
      if (jxe(e))
        return Pa(
          Object.values(e).filter(Boolean)
        );
    }
  },
  "getFirstString"
), kxe = /* @__PURE__ */ o(() => {
  if (typeof mn$1 < "u") {
    let e = mn$1.location.search.slice(1), t = (0, Aa.parse)(e), r = typeof t.args == "string" ? YR(t.args) : void 0, n = typeof t.globals == "string" ? YR(t.globals) : void 0, i = Pa(t.viewMode);
    (typeof i != "string" || !i.match(/docs|story/)) && (i = "story");
    let s = Pa(t.path), a = s ? Mxe(s) : Pa(t.id);
    if (a)
      return { storySpecifier: a, args: r, globals: n, viewMode: i };
  }
  return null;
}, "getSelectionSpecifierFromPath"), KR = class KR2 {
  constructor() {
    this.selectionSpecifier = kxe();
  }
  setSelection(t) {
    this.selection = t, Nxe(this.selection);
  }
  setQueryParams(t) {
    let r = e5({ extraParams: t }), { hash: n = "" } = mn$1.location;
    ZU.replaceState({}, "", `${mn$1.location.pathname}${r}${n}`);
  }
};
o(KR, "UrlStore");
var ro = KR;
var I5 = Ne(A5(), 1), M5 = Ne(qy(), 1);
var { document: ot$1 } = k, O5 = 100, N5 = /* @__PURE__ */ ((s) => (s.MAIN = "MAIN", s.NOPREVIEW = "NOPREVIEW", s.PREPARING_STORY = "PREPARING_STORY", s.PREPARING_DOCS = "PREPARING_DOCS", s.ERROR = "ERROR", s))(N5 || {}), rS = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
}, nS = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
}, q5 = new I5.default({
  escapeXML: true
}), oS = class oS2 {
  constructor() {
    this.testing = false;
    if (typeof ot$1 < "u") {
      let { __SPECIAL_TEST_PARAMETER__: t } = (0, M5.parse)(ot$1.location.search.slice(1));
      switch (t) {
        case "preparing-story": {
          this.showPreparingStory(), this.testing = true;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs(), this.testing = true;
          break;
        }
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(t) {
    return this.showStory(), this.applyLayout(t.parameters.layout), ot$1.documentElement.scrollTop = 0, ot$1.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return ot$1.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), ot$1.documentElement.scrollTop = 0, ot$1.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return ot$1.getElementById("storybook-docs");
  }
  applyLayout(t = "padded") {
    if (t === "none") {
      ot$1.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(t);
    let r = nS[t];
    ot$1.body.classList.remove(this.currentLayoutClass), ot$1.body.classList.add(r), this.currentLayoutClass = r;
  }
  checkIfLayoutExists(t) {
    nS[t] || se.warn(
      Q$1`
          The desired layout: ${t} is not a valid option.
          The possible options are: ${Object.keys(nS).join(", ")}, none.
        `
    );
  }
  showMode(t) {
    clearTimeout(this.preparingTimeout), Object.keys(N5).forEach((r) => {
      r === t ? ot$1.body.classList.add(rS[r]) : ot$1.body.classList.remove(rS[r]);
    });
  }
  showErrorDisplay({ message: t = "", stack: r = "" }) {
    let n = t, i = r, s = t.split(`
`);
    s.length > 1 && ([n] = s, i = s.slice(1).join(`
`).replace(/^\n/, "")), ot$1.getElementById("error-message").innerHTML = q5.toHtml(n), ot$1.getElementById("error-stack").innerHTML = q5.toHtml(
      i
    ), this.showMode("ERROR");
  }
  showNoPreview() {
    this.testing || (this.showMode("NOPREVIEW"), this.storyRoot()?.setAttribute("hidden", "true"), this.docsRoot()?.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate: t = false } = {}) {
    clearTimeout(this.preparingTimeout), t ? this.showMode("PREPARING_STORY") : this.preparingTimeout = setTimeout(
      () => this.showMode("PREPARING_STORY"),
      O5
    );
  }
  showPreparingDocs({ immediate: t = false } = {}) {
    clearTimeout(this.preparingTimeout), t ? this.showMode("PREPARING_DOCS") : this.preparingTimeout = setTimeout(() => this.showMode("PREPARING_DOCS"), O5);
  }
  showMain() {
    this.showMode("MAIN");
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    ot$1.body.classList.add(rS.MAIN);
  }
};
o(oS, "WebView");
var oo = oS;
var iS = class iS2 extends Zn {
  constructor(r, n) {
    super(r, n, new ro(), new oo());
    this.importFn = r;
    this.getProjectAnnotations = n;
    k.__STORYBOOK_PREVIEW__ = this;
  }
};
o(iS, "PreviewWeb");
var qa = iS;
var { document: io } = k, bwe = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
], gwe = "script", j5 = "scripts-root";
function Ia() {
  let e = io.createEvent("Event");
  e.initEvent("DOMContentLoaded", true, true), io.dispatchEvent(e);
}
o(Ia, "simulateDOMContentLoaded");
function vwe(e, t, r) {
  let n = io.createElement("script");
  n.type = e.type === "module" ? "module" : "text/javascript", e.src ? (n.onload = t, n.onerror = t, n.src = e.src) : n.textContent = e.innerText, r ? r.appendChild(n) : io.head.appendChild(n), e.parentNode.removeChild(e), e.src || t();
}
o(vwe, "insertScript");
function k5(e, t, r = 0) {
  e[r](() => {
    r++, r === e.length ? t() : k5(e, t, r);
  });
}
o(k5, "insertScriptsSequentially");
function sS(e) {
  let t = io.getElementById(j5);
  t ? t.innerHTML = "" : (t = io.createElement("div"), t.id = j5, io.body.appendChild(t));
  let r = Array.from(e.querySelectorAll(gwe));
  if (r.length) {
    let n = [];
    r.forEach((i) => {
      let s = i.getAttribute("type");
      (!s || bwe.includes(s)) && n.push((a) => vwe(i, a, t));
    }), n.length && k5(n, Ia, void 0);
  } else
    Ia();
}
o(sS, "simulatePageLoad");
var L5 = "storybook/docs";
var F5 = `${L5}/snippet-rendered`;
async function aS(e, t) {
  let r = t.parameters?.docs?.source?.transform, { id: n, unmappedArgs: i } = t, s = r && e ? r?.(e, t) : e, a = s ? await s : void 0;
  He.getChannel().emit(F5, {
    id: n,
    source: a,
    args: i
  });
}
o(aS, "emitTransformCode");
var so = {
  depth: 10,
  clearOnStoryChange: true,
  limit: 50
}, Ewe = /* @__PURE__ */ o((e = {}) => {
  Object.assign(so, e);
}, "configureActions");
var D5 = /* @__PURE__ */ o((e, t) => {
  let r = Object.getPrototypeOf(e);
  return !r || t(r) ? r : D5(r, t);
}, "findProto"), xwe = /* @__PURE__ */ o((e) => !!(typeof e == "object" && e && D5(e, (t) => /^Synthetic(?:Base)?Event$/.test(t.constructor.name)) && typeof e.persist == "function"), "isReactSyntheticEvent"), wwe = /* @__PURE__ */ o((e) => {
  if (xwe(e)) {
    let t = Object.create(
      e.constructor.prototype,
      Object.getOwnPropertyDescriptors(e)
    );
    t.persist();
    let r = Object.getOwnPropertyDescriptor(t, "view"), n = r?.value;
    return typeof n == "object" && n?.constructor.name === "Window" && Object.defineProperty(t, "view", {
      ...r,
      value: Object.create(n.constructor.prototype)
    }), t;
  }
  return e;
}, "serializeArg");
function Ir(e, t = {}) {
  let r = {
    ...so,
    ...t
  }, n = /* @__PURE__ */ o(function(...s) {
    if (t.implicit) {
      let m = ("__STORYBOOK_PREVIEW__" in k ? k.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
        (h) => h.phase === "playing" || h.phase === "rendering"
      );
      if (m) {
        let h = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, b = new Ni({
          phase: m.phase,
          name: e,
          deprecated: h
        });
        if (h)
          console.warn(b);
        else
          throw b;
      }
    }
    let a = He.getChannel(), l = Date.now().toString(36) + Math.random().toString(36).substring(2), u = 5, c = s.map(wwe), d = s.length > 1 ? c : c[0], p = {
      id: l,
      count: 0,
      data: { name: e, args: d },
      options: {
        ...r,
        maxDepth: u + (r.depth || 3)
      }
    };
    a.emit(sg, p);
  }, "actionHandler");
  return n.isAction = true, n.implicit = t.implicit, n;
}
o(Ir, "action");
var Twe = /* @__PURE__ */ o((...e) => {
  let t = so, r = e;
  r.length === 1 && Array.isArray(r[0]) && ([r] = r), r.length !== 1 && typeof r[r.length - 1] != "string" && (t = {
    ...so,
    ...r.pop()
  });
  let n = r[0];
  (r.length !== 1 || typeof n == "string") && (n = {}, r.forEach((s) => {
    n[s] = s;
  }));
  let i = {};
  return Object.keys(n).forEach((s) => {
    i[s] = Ir(n[s], t);
  }), i;
}, "actions");
var $5 = {
  "@storybook/global": lb,
  "storybook/test": VT,
  "storybook/actions": lS,
  "storybook/preview-api": Dy,
  "storybook/internal/channels": qb,
  "storybook/internal/client-logger": fb,
  "storybook/internal/core-events": co,
  "storybook/internal/types": ig,
  "storybook/internal/preview-errors": Fb,
  "storybook/internal/preview-api": Dy
};
async function B5() {
  let e = new URL(window.location.href);
  if (e.searchParams.get("navigator") !== "true" || globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__)
    return;
  globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__ = true;
  let t = await (await fetch("/index.json")).json(), r = e.searchParams.get("id");
  if (!r) {
    let n = Object.values(t.entries)[0];
    n && (e.searchParams.set("id", n.id), e.searchParams.set("viewMode", n.type), window.location.href = e.toString());
    return;
  }
  Rwe(t, r);
}
o(B5, "maybeSetupPreviewNavigator");
var Rwe = /* @__PURE__ */ o(async (e, t) => {
  let r = { title: "", entries: {}, isActive: true };
  for (let l of Object.values(e.entries)) {
    let u = l.title.split("/"), c = r;
    for (let d of u)
      c.entries || (c.entries = {}), c.entries[d] ? t === l.id && (c.entries[d].isActive = true) : c.entries[d] = {
        title: d,
        isActive: t === l.id,
        entries: {}
      }, c = c.entries[d];
    c.entries || (c.entries = {}), c.entries[l.name] = {
      id: l.id,
      name: l.name,
      href: `?id=${l.id}&viewMode=${l.type}&navigator=true`,
      isActive: t === l.id
    };
  }
  let n = /* @__PURE__ */ o((l) => {
    if ("entries" in l && "title" in l) {
      let c = l;
      return `
      <li class="sb-navigator-branch">
        <details${c.isActive ? " open" : ""}>
          <summary class="sb-navigator-title">
            ${c.title}
          </summary>
          <ul class="sb-navigator-entries" aria-label="${c.title}">
            ${Object.values(c.entries).map(n).join("")}
          </ul>
        </details>
      </li>
      `;
    }
    let u = l;
    return `
      <li class="sb-navigator-story-item">
        <a href="${u.href}" 
           class="sb-navigator-story-link${u.isActive ? " active" : ""}" 
           aria-current="${u.isActive ? "location" : "false"}">${u.name}</a>
      </li>
    `;
  }, "createHtmlForNode"), i = Object.values(r.entries).map(n).join(""), s = document.createElement("nav");
  s.id = "sb-navigator-container", s.setAttribute("role", "navigation"), s.setAttribute("aria-label", "Story navigation"), s.innerHTML = `
    <ul class="sb-navigator-list">${i}</ul>
  `, document.body.insertBefore(s, document.body.firstChild);
  let a = document.createElement("style");
  a.id = "sb-navigator-style", a.textContent = `
    body {
      display: grid !important;
      grid-template-columns: 300px 1fr;
      font-family: 'Nunito', sans-serif;
      height: 100vh;
      margin: 0;

      --text-color: rgb(46, 52, 56);
      --bg-color: rgb(246, 249, 252);

      @media (prefers-color-scheme: dark) {
        --text-color: rgb(201, 205, 207);
        --bg-color: rgb(34, 36, 37);
      }
    }
    #storybook-root, #storybook-docs {
      overflow-y: auto;
      max-height: 100vh;
      max-width: 100%;
    }
    #sb-navigator-container, #sb-navigator-container * {
      box-sizing: border-box;
    }
    #sb-navigator-container {
        height: 100vh;
        overflow-y: auto;
        border-right: 1px solid #eee;
        padding: 1rem;
        font-size: 14px;
        color: var(--text-color);
        background-color: var(--bg-color);
        align-self: start;
        z-index: 1000;
    }
    .sb-main-padded #sb-navigator-container {
      margin: -1rem 1rem -1rem -1rem;
    }
    .sb-navigator-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    .sb-navigator-branch {
      list-style-type: none;
    }
    .sb-navigator-item {
      margin-bottom: 15px;
    }
    .sb-navigator-title {
      color: var(--text-color);
      text-decoration: none;
      padding-block: 5px;
      cursor: pointer;
    }
    .sb-navigator-entries {
      padding-left: 15px;
    }
    .sb-navigator-story-item {
      margin-bottom: 8px;
      margin-left: 8px;
    }
    .sb-navigator-story-link {
      color: var(--text-color);
    }
    .sb-navigator-story-link.active {
      font-weight: bold;
      color: rgb(2, 156, 253);
    }
  `, document.head.appendChild(a), s.querySelector(".sb-navigator-story-link.active")?.closest("details")?.scrollIntoView({ block: "center" });
}, "setupPreviewNavigator");
var U5 = Ne(H5(), 1);
var dS;
function Swe() {
  return dS || (dS = new U5.default(k.navigator?.userAgent).getBrowserInfo()), dS;
}
o(Swe, "getBrowserInfo");
function V5(e) {
  return e.browserInfo = Swe(), e;
}
o(V5, "prepareForTelemetry");
function _we(e) {
  let t = e.error || e;
  t.fromStorybook && k.sendTelemetryError(t);
}
o(_we, "errorListener");
function Cwe({ reason: e }) {
  e.fromStorybook && k.sendTelemetryError(e);
}
o(Cwe, "unhandledRejectionListener");
function Pwe() {
  fS.forEach((e) => {
    k[ub[e]] = $5[e];
  }), k.sendTelemetryError = (e) => {
    k.__STORYBOOK_ADDONS_CHANNEL__.emit(sb, V5(e));
  }, k.addEventListener("error", _we), k.addEventListener("unhandledrejection", Cwe), B5();
}
o(Pwe, "setup");
Pwe();

const { createBrowserChannel } = __STORYBOOK_MODULE_CHANNELS__;
    const { addons: addons$2 } = __STORYBOOK_MODULE_PREVIEW_API__;

    const channel = createBrowserChannel({ page: 'preview' });
    addons$2.setChannel(channel);
    window.__STORYBOOK_ADDONS_CHANNEL__ = channel;
    
    if (window.CONFIG_TYPE === 'DEVELOPMENT'){
      window.__STORYBOOK_SERVER_CHANNEL__ = channel;
    }

const scriptRel = 'modulepreload';const assetsURL = function(dep, importerUrl) { return new URL(dep, importerUrl).href };const seen$2 = {};const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (true && deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen$2) return;
        seen$2[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i = links.length - 1; i >= 0; i--) {
            const link2 = links[i];
            if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};

const importers = {
  "./src/components/action-sheet/ActionSheet.stories.js": () => __vitePreload(() => import('./ActionSheet.stories-BrdygiOL.js'),true?__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]):void 0,import.meta.url),
  "./src/components/alert/Alert.stories.js": () => __vitePreload(() => import('./Alert.stories-CpJT-eKq.js'),true?__vite__mapDeps([16,17,18]):void 0,import.meta.url),
  "./src/components/amount-combobox/AmountCombobx.stories.js": () => __vitePreload(() => import('./AmountCombobx.stories-B757sUKM.js'),true?__vite__mapDeps([19,12,13,20,21,22,23,24,10,25,26,27,28,6,7,5,29,30,31,32]):void 0,import.meta.url),
  "./src/components/amount-input/AmountInput.stories.js": () => __vitePreload(() => import('./AmountInput.stories-RpIDorpj.js'),true?__vite__mapDeps([33,12,13,20,21,23,24,10,25,26]):void 0,import.meta.url),
  "./src/components/amount/Amount.stories.js": () => __vitePreload(() => import('./Amount.stories-Bp8mPoat.js'),true?__vite__mapDeps([34,11,12,13,35,2,36,10,37]):void 0,import.meta.url),
  "./src/components/article/Article.stories.js": () => __vitePreload(() => import('./Article.stories-DBs1fiyo.js'),true?__vite__mapDeps([38,39,40]):void 0,import.meta.url),
  "./src/components/badge/Badge.stories.js": () => __vitePreload(() => import('./Badge.stories-Dkn1jSSs.js'),true?__vite__mapDeps([41,42,43]):void 0,import.meta.url),
  "./src/components/button/Animation.stories.js": () => __vitePreload(() => import('./Animation.stories-DT3_zt2O.js'),true?__vite__mapDeps([44,12,13]):void 0,import.meta.url),
  "./src/components/button/Button.stories.js": () => __vitePreload(() => import('./Button.stories-C8O9bm2A.js'),true?__vite__mapDeps([45,12,13]):void 0,import.meta.url),
  "./src/components/button/ButtonGroup.stories.js": () => __vitePreload(() => import('./ButtonGroup.stories-BodARW8d.js'),true?__vite__mapDeps([46,12,13,47,48]):void 0,import.meta.url),
  "./src/components/button/ButtonTokenSystem.stories.js": () => __vitePreload(() => import('./ButtonTokenSystem.stories-tKssrJ_L.js'),true?__vite__mapDeps([49,12,13]):void 0,import.meta.url),
  "./src/components/card/Card.stories.js": () => __vitePreload(() => import('./Card.stories-JpsHvv46.js'),true?__vite__mapDeps([50,51,52]):void 0,import.meta.url),
  "./src/components/clamp-text/ClampText.stories.js": () => __vitePreload(() => import('./ClampText.stories-BtyXCtkC.js'),true?__vite__mapDeps([53,54,3,55]):void 0,import.meta.url),
  "./src/components/combobox/Combobox.stories.js": () => __vitePreload(() => import('./Combobox.stories-Br8lKMsg.js'),true?__vite__mapDeps([56,57,31,58,28,6,7,5,29,30,8,9,59]):void 0,import.meta.url),
  "./src/components/copy-input/CopyInput.stories.js": () => __vitePreload(() => import('./CopyInput.stories-wZ10vnqQ.js'),true?__vite__mapDeps([60,61,62,20,21,63]):void 0,import.meta.url),
  "./src/components/country-flag-icon/CountryFlagIcon.stories.js": () => __vitePreload(() => import('./CountryFlagIcon.stories-SPsaYMBg.js'),true?__vite__mapDeps([64,65,66,67]):void 0,import.meta.url),
  "./src/components/drawer/Drawer.stories.js": () => __vitePreload(() => import('./Drawer.stories-DYWdXnJj.js'),true?__vite__mapDeps([68,1,2,3,4,5,6,7,8,9,10,11,12,13,69,70,71]):void 0,import.meta.url),
  "./src/components/drop-zone/DropZone.stories.js": () => __vitePreload(() => import('./DropZone.stories-CZ2PIq7_.js'),true?__vite__mapDeps([72,73,2,74]):void 0,import.meta.url),
  "./src/components/dropdown/Dropdown.stories.js": () => __vitePreload(() => import('./Dropdown.stories-Do8xpRFa.js'),true?__vite__mapDeps([75,76,4,5,6,7,29,77]):void 0,import.meta.url),
  "./src/components/file-input/FileInput.stories.js": () => __vitePreload(() => import('./FileInput.stories-C1B7U5na.js'),true?__vite__mapDeps([78,12,13,79,70,80]):void 0,import.meta.url),
  "./src/components/form-field/FormField.stories.js": () => __vitePreload(() => import('./FormField.stories-Dtb7F88a.js'),true?__vite__mapDeps([81,20,21]):void 0,import.meta.url),
  "./src/components/form-textarea/FormTextarea.stories.js": () => __vitePreload(() => import('./FormTextarea.stories-ZImbog20.js'),true?__vite__mapDeps([82,83,84]):void 0,import.meta.url),
  "./src/components/friendly-number/FriendlyNumber.stories.js": () => __vitePreload(() => import('./FriendlyNumber.stories-CSz1zGeX.js'),true?__vite__mapDeps([85,20,21,86]):void 0,import.meta.url),
  "./src/components/hint/Hint.stories.js": () => __vitePreload(() => import('./Hint.stories-CV8CIFq-.js'),true?__vite__mapDeps([87,88,89,90,91]):void 0,import.meta.url),
  "./src/components/input-text/InputText.stories.js": () => __vitePreload(() => import('./InputText.stories-CuMdKeur.js'),true?__vite__mapDeps([92,93,94]):void 0,import.meta.url),
  "./src/components/modal-dialog/ModalDialog.stories.js": () => __vitePreload(() => import('./ModalDialog.stories-2yaVXekh.js'),true?__vite__mapDeps([95,96,14,1,2,3,4,5,6,7,8,9,15,17,18,35,36,10,11,37,22,23,24,20,21,25,26,27,28,29,30,31,32,39,40,42,43,12,13,47,48,51,52,65,66,67,54,55,57,58,59,61,62,63,69,70,71,76,77,73,74,86,93,94,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,83,84,121,122,123,89,90,88,91,124,125,126,79,80,127]):void 0,import.meta.url),
  "./src/components/pagination/Pagination.stories.js": () => __vitePreload(() => import('./Pagination.stories-8ijiT4xl.js'),true?__vite__mapDeps([128,97,98]):void 0,import.meta.url),
  "./src/components/phone-input/PhoneInput.stories.js": () => __vitePreload(() => import('./PhoneInput.stories-CAF1pp-M.js'),true?__vite__mapDeps([129,99,24,10,100]):void 0,import.meta.url),
  "./src/components/picture/Picture.stories.js": () => __vitePreload(() => import('./Picture.stories-BdRrY6Cf.js'),true?__vite__mapDeps([130,3,96]):void 0,import.meta.url),
  "./src/components/progress-bar/ProgressBar.stories.js": () => __vitePreload(() => import('./ProgressBar.stories-YstESm5w.js'),true?__vite__mapDeps([131,101,102]):void 0,import.meta.url),
  "./src/components/progress-field/ProgressField.stories.js": () => __vitePreload(() => import('./ProgressField.stories-mixRq0JX.js'),true?__vite__mapDeps([132,124,20,21,111,112,125,126]):void 0,import.meta.url),
  "./src/components/quantity-field/QuantityField.stories.js": () => __vitePreload(() => import('./QuantityField.stories-DdGZcTao.js'),true?__vite__mapDeps([133,35,2,36,10,11,37,23,24,20,21,25,26,134]):void 0,import.meta.url),
  "./src/components/radio/Radio.stories.js": () => __vitePreload(() => import('./Radio.stories-tfLvuAes.js'),true?__vite__mapDeps([135,103,104]):void 0,import.meta.url),
  "./src/components/select/Select.stories.js": () => __vitePreload(() => import('./Select.stories-B5ZPWf4H.js'),true?__vite__mapDeps([136,105,27,28,6,7,5,29,30,106,107,58,108]):void 0,import.meta.url),
  "./src/components/skeleton/Skeleton.stories.js": () => __vitePreload(() => import('./Skeleton.stories-CCaBgJ8J.js'),true?__vite__mapDeps([137,109,110]):void 0,import.meta.url),
  "./src/components/spinner/Spinner.stories.js": () => __vitePreload(() => import('./Spinner.stories-CSFm6nJQ.js'),true?__vite__mapDeps([138,111,112]):void 0,import.meta.url),
  "./src/components/svg-icon/SvgIcon.stories.js": () => __vitePreload(() => import('./SvgIcon.stories-BXF3K825.js'),true?__vite__mapDeps([139,62,113,66,25]):void 0,import.meta.url),
  "./src/components/switcher/Switcher.stories.js": () => __vitePreload(() => import('./Switcher.stories-3KlrfZpE.js'),true?__vite__mapDeps([140,114,115,28,6,29,116]):void 0,import.meta.url),
  "./src/components/switcher/SwitcherWithText.stories.js": () => __vitePreload(() => import('./SwitcherWithText.stories-DwavZzyQ.js'),true?__vite__mapDeps([141,117,115,28,6,29,118]):void 0,import.meta.url),
  "./src/components/tabs/Tabs.stories.js": () => __vitePreload(() => import('./Tabs.stories-CGiy-uvC.js'),true?__vite__mapDeps([142,119,36,6,29,5,9,120]):void 0,import.meta.url),
  "./src/components/text-mark/TextMark.stories.js": () => __vitePreload(() => import('./TextMark.stories-2_6J687d.js'),true?__vite__mapDeps([143,121]):void 0,import.meta.url),
  "./src/components/ticker/Ticker.stories.js": () => __vitePreload(() => import('./Ticker.stories-DtVhnZhF.js'),true?__vite__mapDeps([144,122,123]):void 0,import.meta.url),
  "./src/components/tooltip/Tooltip.stories.js": () => __vitePreload(() => import('./Tooltip.stories-BmMzn-mA.js'),true?__vite__mapDeps([145,105,27,28,6,7,5,29,30,106,89,90,125]):void 0,import.meta.url)
};

async function importFn(path) {
  return await importers[path]();
}

var __defProp$1=Object.defineProperty;var __export$1=(target,all)=>{for(var name in all)__defProp$1(target,name,{get:all[name],enumerable:!0});};

var dr = Object.create;
var Ie = Object.defineProperty;
var Tr = Object.getOwnPropertyDescriptor;
var gr = Object.getOwnPropertyNames;
var xr = Object.getPrototypeOf, hr = Object.prototype.hasOwnProperty;
var r$1 = (n, s) => Ie(n, "name", { value: s, configurable: !0 });
var Jr = (n, s) => () => (s || n((s = { exports: {} }).exports, s), s.exports);
var wr = (n, s, a, p) => {
  if (s && typeof s == "object" || typeof s == "function")
    for (let c of gr(s))
      !hr.call(n, c) && c !== a && Ie(n, c, { get: () => s[c], enumerable: !(p = Tr(s, c)) || p.enumerable });
  return n;
};
var Pr = (n, s, a) => (a = n != null ? dr(xr(n)) : {}, wr(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  Ie(a, "default", { value: n, enumerable: !0 }) ,
  n
));

// ../node_modules/jsdoc-type-pratt-parser/dist/index.js
var dt = Jr((fe, yt) => {
  (function(n, s) {
    typeof fe == "object" && typeof yt < "u" ? s(fe) : typeof define == "function" && define.amd ? define(["exports"], s) : (n = typeof globalThis <
    "u" ? globalThis : n || self, s(n.jtpp = {}));
  })(fe, function(n) {
    function s(e) {
      return e.text !== void 0 && e.text !== "" ? `'${e.type}' with value '${e.text}'` : `'${e.type}'`;
    }
    r$1(s, "tokenToString");
    let ne = class ne extends Error {
      constructor(t) {
        super(`No parslet found for token: ${s(t)}`), this.token = t, Object.setPrototypeOf(this, ne.prototype);
      }
      getToken() {
        return this.token;
      }
    };
    r$1(ne, "NoParsletFoundError");
    let a = ne, oe = class oe extends Error {
      constructor(t) {
        super(`The parsing ended early. The next token was: ${s(t)}`), this.token = t, Object.setPrototypeOf(this, oe.prototype);
      }
      getToken() {
        return this.token;
      }
    };
    r$1(oe, "EarlyEndOfParseError");
    let p = oe, se = class se extends Error {
      constructor(t, o) {
        let i = `Unexpected type: '${t.type}'.`;
        o !== void 0 && (i += ` Message: ${o}`), super(i), Object.setPrototypeOf(this, se.prototype);
      }
    };
    r$1(se, "UnexpectedTypeError");
    let c = se;
    function u(e) {
      return (t) => t.startsWith(e) ? { type: e, text: e } : null;
    }
    r$1(u, "makePunctuationRule");
    function m(e) {
      let t = 0, o, i = e[0], l = !1;
      if (i !== "'" && i !== '"')
        return null;
      for (; t < e.length; ) {
        if (t++, o = e[t], !l && o === i) {
          t++;
          break;
        }
        l = !l && o === "\\";
      }
      if (o !== i)
        throw new Error("Unterminated String");
      return e.slice(0, t);
    }
    r$1(m, "getQuoted");
    let T = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), g = new RegExp(
    "[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
    function P(e) {
      let t = e[0];
      if (!T.test(t))
        return null;
      let o = 1;
      do {
        if (t = e[o], !g.test(t))
          break;
        o++;
      } while (o < e.length);
      return e.slice(0, o);
    }
    r$1(P, "getIdentifier");
    let b = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
    function de(e) {
      var t, o;
      return (o = (t = b.exec(e)) === null || t === void 0 ? void 0 : t[0]) !== null && o !== void 0 ? o : null;
    }
    r$1(de, "getNumber");
    let q = /* @__PURE__ */ r$1((e) => {
      let t = P(e);
      return t == null ? null : {
        type: "Identifier",
        text: t
      };
    }, "identifierRule");
    function S(e) {
      return (t) => {
        if (!t.startsWith(e))
          return null;
        let o = t[e.length];
        return o !== void 0 && g.test(o) ? null : {
          type: e,
          text: e
        };
      };
    }
    r$1(S, "makeKeyWordRule");
    let z = /* @__PURE__ */ r$1((e) => {
      let t = m(e);
      return t == null ? null : {
        type: "StringValue",
        text: t
      };
    }, "stringValueRule"), Te = /* @__PURE__ */ r$1((e) => e.length > 0 ? null : {
      type: "EOF",
      text: ""
    }, "eofRule"), ge = /* @__PURE__ */ r$1((e) => {
      let t = de(e);
      return t === null ? null : {
        type: "Number",
        text: t
      };
    }, "numberRule"), Rt = [
      Te,
      u("=>"),
      u("("),
      u(")"),
      u("{"),
      u("}"),
      u("["),
      u("]"),
      u("|"),
      u("&"),
      u("<"),
      u(">"),
      u(","),
      u(";"),
      u("*"),
      u("?"),
      u("!"),
      u("="),
      u(":"),
      u("..."),
      u("."),
      u("#"),
      u("~"),
      u("/"),
      u("@"),
      S("undefined"),
      S("null"),
      S("function"),
      S("this"),
      S("new"),
      S("module"),
      S("event"),
      S("external"),
      S("typeof"),
      S("keyof"),
      S("readonly"),
      S("import"),
      S("is"),
      S("in"),
      S("asserts"),
      ge,
      q,
      z
    ], jt = /^\s*\n\s*/, U = class U {
      static create(t) {
        let o = this.read(t);
        t = o.text;
        let i = this.read(t);
        return t = i.text, new U(t, void 0, o.token, i.token);
      }
      constructor(t, o, i, l) {
        this.text = "", this.text = t, this.previous = o, this.current = i, this.next = l;
      }
      static read(t, o = !1) {
        o = o || jt.test(t), t = t.trim();
        for (let i of Rt) {
          let l = i(t);
          if (l !== null) {
            let f = Object.assign(Object.assign({}, l), { startOfLine: o });
            return t = t.slice(f.text.length), { text: t, token: f };
          }
        }
        throw new Error("Unexpected Token " + t);
      }
      advance() {
        let t = U.read(this.text);
        return new U(t.text, this.current, this.next, t.token);
      }
    };
    r$1(U, "Lexer");
    let xe = U;
    function J(e) {
      if (e === void 0)
        throw new Error("Unexpected undefined");
      if (e.type === "JsdocTypeKeyValue" || e.type === "JsdocTypeParameterList" || e.type === "JsdocTypeProperty" || e.type === "JsdocTypeRe\
adonlyProperty" || e.type === "JsdocTypeObjectField" || e.type === "JsdocTypeJsdocObjectField" || e.type === "JsdocTypeIndexSignature" || e.
      type === "JsdocTypeMappedType")
        throw new c(e);
      return e;
    }
    r$1(J, "assertRootResult");
    function he(e) {
      return e.type === "JsdocTypeKeyValue" ? H(e) : J(e);
    }
    r$1(he, "assertPlainKeyValueOrRootResult");
    function Ft(e) {
      return e.type === "JsdocTypeName" ? e : H(e);
    }
    r$1(Ft, "assertPlainKeyValueOrNameResult");
    function H(e) {
      if (e.type !== "JsdocTypeKeyValue")
        throw new c(e);
      return e;
    }
    r$1(H, "assertPlainKeyValueResult");
    function _t(e) {
      var t;
      if (e.type === "JsdocTypeVariadic") {
        if (((t = e.element) === null || t === void 0 ? void 0 : t.type) === "JsdocTypeName")
          return e;
        throw new c(e);
      }
      if (e.type !== "JsdocTypeNumber" && e.type !== "JsdocTypeName")
        throw new c(e);
      return e;
    }
    r$1(_t, "assertNumberOrVariadicNameResult");
    function Je(e) {
      return e.type === "JsdocTypeIndexSignature" || e.type === "JsdocTypeMappedType";
    }
    r$1(Je, "isSquaredProperty");
    var y;
    (function(e) {
      e[e.ALL = 0] = "ALL", e[e.PARAMETER_LIST = 1] = "PARAMETER_LIST", e[e.OBJECT = 2] = "OBJECT", e[e.KEY_VALUE = 3] = "KEY_VALUE", e[e.INDEX_BRACKETS =
      4] = "INDEX_BRACKETS", e[e.UNION = 5] = "UNION", e[e.INTERSECTION = 6] = "INTERSECTION", e[e.PREFIX = 7] = "PREFIX", e[e.INFIX = 8] = "\
INFIX", e[e.TUPLE = 9] = "TUPLE", e[e.SYMBOL = 10] = "SYMBOL", e[e.OPTIONAL = 11] = "OPTIONAL", e[e.NULLABLE = 12] = "NULLABLE", e[e.KEY_OF_TYPE_OF =
      13] = "KEY_OF_TYPE_OF", e[e.FUNCTION = 14] = "FUNCTION", e[e.ARROW = 15] = "ARROW", e[e.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", e[e.GENERIC =
      17] = "GENERIC", e[e.NAME_PATH = 18] = "NAME_PATH", e[e.PARENTHESIS = 19] = "PARENTHESIS", e[e.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
    })(y || (y = {}));
    let Ae = class Ae {
      constructor(t, o, i) {
        this.grammar = t, typeof o == "string" ? this._lexer = xe.create(o) : this._lexer = o, this.baseParser = i;
      }
      get lexer() {
        return this._lexer;
      }
      /**
       * Parses a given string and throws an error if the parse ended before the end of the string.
       */
      parse() {
        let t = this.parseType(y.ALL);
        if (this.lexer.current.type !== "EOF")
          throw new p(this.lexer.current);
        return t;
      }
      /**
       * Parses with the current lexer and asserts that the result is a {@link RootResult}.
       */
      parseType(t) {
        return J(this.parseIntermediateType(t));
      }
      /**
       * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
       * to parse the state in the infix step.
       */
      parseIntermediateType(t) {
        let o = this.tryParslets(null, t);
        if (o === null)
          throw new a(this.lexer.current);
        return this.parseInfixIntermediateType(o, t);
      }
      /**
       * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
       * a result.
       */
      parseInfixIntermediateType(t, o) {
        let i = this.tryParslets(t, o);
        for (; i !== null; )
          t = i, i = this.tryParslets(t, o);
        return t;
      }
      /**
       * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
       */
      tryParslets(t, o) {
        for (let i of this.grammar) {
          let l = i(this, o, t);
          if (l !== null)
            return l;
        }
        return null;
      }
      /**
       * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
       * advanced.
       */
      consume(t) {
        return Array.isArray(t) || (t = [t]), t.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;
      }
      acceptLexerState(t) {
        this._lexer = t.lexer;
      }
    };
    r$1(Ae, "Parser");
    let I = Ae;
    function Ye(e) {
      return e === "EOF" || e === "|" || e === "," || e === ")" || e === ">";
    }
    r$1(Ye, "isQuestionMarkUnknownType");
    let we = /* @__PURE__ */ r$1((e, t, o) => {
      let i = e.lexer.current.type, l = e.lexer.next.type;
      return o == null && i === "?" && !Ye(l) || o != null && i === "?" ? (e.consume("?"), o == null ? {
        type: "JsdocTypeNullable",
        element: e.parseType(y.NULLABLE),
        meta: {
          position: "prefix"
        }
      } : {
        type: "JsdocTypeNullable",
        element: J(o),
        meta: {
          position: "suffix"
        }
      }) : null;
    }, "nullableParslet");
    function x(e) {
      let t = /* @__PURE__ */ r$1((o, i, l) => {
        let f = o.lexer.current.type, d = o.lexer.next.type;
        if (l === null) {
          if ("parsePrefix" in e && e.accept(f, d))
            return e.parsePrefix(o);
        } else if ("parseInfix" in e && e.precedence > i && e.accept(f, d))
          return e.parseInfix(o, l);
        return null;
      }, "parslet");
      return Object.defineProperty(t, "name", {
        value: e.name
      }), t;
    }
    r$1(x, "composeParslet");
    let Q = x({
      name: "optionalParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "=", "accept"),
      precedence: y.OPTIONAL,
      parsePrefix: /* @__PURE__ */ r$1((e) => (e.consume("="), {
        type: "JsdocTypeOptional",
        element: e.parseType(y.OPTIONAL),
        meta: {
          position: "prefix"
        }
      }), "parsePrefix"),
      parseInfix: /* @__PURE__ */ r$1((e, t) => (e.consume("="), {
        type: "JsdocTypeOptional",
        element: J(t),
        meta: {
          position: "suffix"
        }
      }), "parseInfix")
    }), Z = x({
      name: "numberParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "Number", "accept"),
      parsePrefix: /* @__PURE__ */ r$1((e) => {
        let t = parseFloat(e.lexer.current.text);
        return e.consume("Number"), {
          type: "JsdocTypeNumber",
          value: t
        };
      }, "parsePrefix")
    }), Vt = x({
      name: "parenthesisParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "(", "accept"),
      parsePrefix: /* @__PURE__ */ r$1((e) => {
        if (e.consume("("), e.consume(")"))
          return {
            type: "JsdocTypeParameterList",
            elements: []
          };
        let t = e.parseIntermediateType(y.ALL);
        if (!e.consume(")"))
          throw new Error("Unterminated parenthesis");
        return t.type === "JsdocTypeParameterList" ? t : t.type === "JsdocTypeKeyValue" ? {
          type: "JsdocTypeParameterList",
          elements: [t]
        } : {
          type: "JsdocTypeParenthesis",
          element: J(t)
        };
      }, "parsePrefix")
    }), Lt = x({
      name: "specialTypesParslet",
      accept: /* @__PURE__ */ r$1((e, t) => e === "?" && Ye(t) || e === "null" || e === "undefined" || e === "*", "accept"),
      parsePrefix: /* @__PURE__ */ r$1((e) => {
        if (e.consume("null"))
          return {
            type: "JsdocTypeNull"
          };
        if (e.consume("undefined"))
          return {
            type: "JsdocTypeUndefined"
          };
        if (e.consume("*"))
          return {
            type: "JsdocTypeAny"
          };
        if (e.consume("?"))
          return {
            type: "JsdocTypeUnknown"
          };
        throw new Error("Unacceptable token: " + e.lexer.current.text);
      }, "parsePrefix")
    }), Ut = x({
      name: "notNullableParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "!", "accept"),
      precedence: y.NULLABLE,
      parsePrefix: /* @__PURE__ */ r$1((e) => (e.consume("!"), {
        type: "JsdocTypeNotNullable",
        element: e.parseType(y.NULLABLE),
        meta: {
          position: "prefix"
        }
      }), "parsePrefix"),
      parseInfix: /* @__PURE__ */ r$1((e, t) => (e.consume("!"), {
        type: "JsdocTypeNotNullable",
        element: J(t),
        meta: {
          position: "suffix"
        }
      }), "parseInfix")
    });
    function Bt({ allowTrailingComma: e }) {
      return x({
        name: "parameterListParslet",
        accept: /* @__PURE__ */ r$1((t) => t === ",", "accept"),
        precedence: y.PARAMETER_LIST,
        parseInfix: /* @__PURE__ */ r$1((t, o) => {
          let i = [
            he(o)
          ];
          t.consume(",");
          do
            try {
              let l = t.parseIntermediateType(y.PARAMETER_LIST);
              i.push(he(l));
            } catch (l) {
              if (e && l instanceof a)
                break;
              throw l;
            }
          while (t.consume(","));
          if (i.length > 0 && i.slice(0, -1).some((l) => l.type === "JsdocTypeVariadic"))
            throw new Error("Only the last parameter may be a rest parameter");
          return {
            type: "JsdocTypeParameterList",
            elements: i
          };
        }, "parseInfix")
      });
    }
    r$1(Bt, "createParameterListParslet");
    let Ct = x({
      name: "genericParslet",
      accept: /* @__PURE__ */ r$1((e, t) => e === "<" || e === "." && t === "<", "accept"),
      precedence: y.GENERIC,
      parseInfix: /* @__PURE__ */ r$1((e, t) => {
        let o = e.consume(".");
        e.consume("<");
        let i = [];
        do
          i.push(e.parseType(y.PARAMETER_LIST));
        while (e.consume(","));
        if (!e.consume(">"))
          throw new Error("Unterminated generic parameter list");
        return {
          type: "JsdocTypeGeneric",
          left: J(t),
          elements: i,
          meta: {
            brackets: "angle",
            dot: o
          }
        };
      }, "parseInfix")
    }), Mt = x({
      name: "unionParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "|", "accept"),
      precedence: y.UNION,
      parseInfix: /* @__PURE__ */ r$1((e, t) => {
        e.consume("|");
        let o = [];
        do
          o.push(e.parseType(y.UNION));
        while (e.consume("|"));
        return {
          type: "JsdocTypeUnion",
          elements: [J(t), ...o]
        };
      }, "parseInfix")
    }), Pe = [
      we,
      Q,
      Z,
      Vt,
      Lt,
      Ut,
      Bt({
        allowTrailingComma: !0
      }),
      Ct,
      Mt,
      Q
    ];
    function ee({ allowSquareBracketsOnAnyType: e, allowJsdocNamePaths: t, pathGrammar: o }) {
      return /* @__PURE__ */ r$1(function(l, f, d) {
        if (d == null || f >= y.NAME_PATH)
          return null;
        let h = l.lexer.current.type, D = l.lexer.next.type;
        if (!(h === "." && D !== "<" || h === "[" && (e || d.type === "JsdocTypeName") || t && (h === "~" || h === "#")))
          return null;
        let O, ae = !1;
        l.consume(".") ? O = "property" : l.consume("[") ? (O = "property-brackets", ae = !0) : l.consume("~") ? O = "inner" : (l.consume("#"),
        O = "instance");
        let rt = o !== null ? new I(o, l.lexer, l) : l, k = rt.parseIntermediateType(y.NAME_PATH);
        l.acceptLexerState(rt);
        let G;
        switch (k.type) {
          case "JsdocTypeName":
            G = {
              type: "JsdocTypeProperty",
              value: k.value,
              meta: {
                quote: void 0
              }
            };
            break;
          case "JsdocTypeNumber":
            G = {
              type: "JsdocTypeProperty",
              value: k.value.toString(10),
              meta: {
                quote: void 0
              }
            };
            break;
          case "JsdocTypeStringValue":
            G = {
              type: "JsdocTypeProperty",
              value: k.value,
              meta: {
                quote: k.meta.quote
              }
            };
            break;
          case "JsdocTypeSpecialNamePath":
            if (k.specialType === "event")
              G = k;
            else
              throw new c(k, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
            break;
          default:
            throw new c(k, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
        }
        if (ae && !l.consume("]")) {
          let nt = l.lexer.current;
          throw new Error(`Unterminated square brackets. Next token is '${nt.type}' with text '${nt.text}'`);
        }
        return {
          type: "JsdocTypeNamePath",
          left: J(d),
          right: G,
          pathType: O
        };
      }, "namePathParslet");
    }
    r$1(ee, "createNamePathParslet");
    function R({ allowedAdditionalTokens: e }) {
      return x({
        name: "nameParslet",
        accept: /* @__PURE__ */ r$1((t) => t === "Identifier" || t === "this" || t === "new" || e.includes(t), "accept"),
        parsePrefix: /* @__PURE__ */ r$1((t) => {
          let { type: o, text: i } = t.lexer.current;
          return t.consume(o), {
            type: "JsdocTypeName",
            value: i
          };
        }, "parsePrefix")
      });
    }
    r$1(R, "createNameParslet");
    let Y = x({
      name: "stringValueParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "StringValue", "accept"),
      parsePrefix: /* @__PURE__ */ r$1((e) => {
        let t = e.lexer.current.text;
        return e.consume("StringValue"), {
          type: "JsdocTypeStringValue",
          value: t.slice(1, -1),
          meta: {
            quote: t[0] === "'" ? "single" : "double"
          }
        };
      }, "parsePrefix")
    });
    function te({ pathGrammar: e, allowedTypes: t }) {
      return x({
        name: "specialNamePathParslet",
        accept: /* @__PURE__ */ r$1((o) => t.includes(o), "accept"),
        parsePrefix: /* @__PURE__ */ r$1((o) => {
          let i = o.lexer.current.type;
          if (o.consume(i), !o.consume(":"))
            return {
              type: "JsdocTypeName",
              value: i
            };
          let l, f = o.lexer.current;
          if (o.consume("StringValue"))
            l = {
              type: "JsdocTypeSpecialNamePath",
              value: f.text.slice(1, -1),
              specialType: i,
              meta: {
                quote: f.text[0] === "'" ? "single" : "double"
              }
            };
          else {
            let D = "", E = ["Identifier", "@", "/"];
            for (; E.some((O) => o.consume(O)); )
              D += f.text, f = o.lexer.current;
            l = {
              type: "JsdocTypeSpecialNamePath",
              value: D,
              specialType: i,
              meta: {
                quote: void 0
              }
            };
          }
          let d = new I(e, o.lexer, o), h = d.parseInfixIntermediateType(l, y.ALL);
          return o.acceptLexerState(d), J(h);
        }, "parsePrefix")
      });
    }
    r$1(te, "createSpecialNamePathParslet");
    let We = [
      R({
        allowedAdditionalTokens: ["external", "module"]
      }),
      Y,
      Z,
      ee({
        allowSquareBracketsOnAnyType: !1,
        allowJsdocNamePaths: !0,
        pathGrammar: null
      })
    ], L = [
      ...We,
      te({
        allowedTypes: ["event"],
        pathGrammar: We
      })
    ];
    function be(e) {
      let t;
      if (e.type === "JsdocTypeParameterList")
        t = e.elements;
      else if (e.type === "JsdocTypeParenthesis")
        t = [e.element];
      else
        throw new c(e);
      return t.map((o) => he(o));
    }
    r$1(be, "getParameters");
    function Kt(e) {
      let t = be(e);
      if (t.some((o) => o.type === "JsdocTypeKeyValue"))
        throw new Error("No parameter should be named");
      return t;
    }
    r$1(Kt, "getUnnamedParameters");
    function Se({ allowNamedParameters: e, allowNoReturnType: t, allowWithoutParenthesis: o, allowNewAsFunctionKeyword: i }) {
      return x({
        name: "functionParslet",
        accept: /* @__PURE__ */ r$1((l, f) => l === "function" || i && l === "new" && f === "(", "accept"),
        parsePrefix: /* @__PURE__ */ r$1((l) => {
          let f = l.consume("new");
          l.consume("function");
          let d = l.lexer.current.type === "(";
          if (!d) {
            if (!o)
              throw new Error("function is missing parameter list");
            return {
              type: "JsdocTypeName",
              value: "function"
            };
          }
          let h = {
            type: "JsdocTypeFunction",
            parameters: [],
            arrow: !1,
            constructor: f,
            parenthesis: d
          }, D = l.parseIntermediateType(y.FUNCTION);
          if (e === void 0)
            h.parameters = Kt(D);
          else {
            if (f && D.type === "JsdocTypeFunction" && D.arrow)
              return h = D, h.constructor = !0, h;
            h.parameters = be(D);
            for (let E of h.parameters)
              if (E.type === "JsdocTypeKeyValue" && !e.includes(E.key))
                throw new Error(`only allowed named parameters are ${e.join(", ")} but got ${E.type}`);
          }
          if (l.consume(":"))
            h.returnType = l.parseType(y.PREFIX);
          else if (!t)
            throw new Error("function is missing return type");
          return h;
        }, "parsePrefix")
      });
    }
    r$1(Se, "createFunctionParslet");
    function Ee({ allowPostfix: e, allowEnclosingBrackets: t }) {
      return x({
        name: "variadicParslet",
        accept: /* @__PURE__ */ r$1((o) => o === "...", "accept"),
        precedence: y.PREFIX,
        parsePrefix: /* @__PURE__ */ r$1((o) => {
          o.consume("...");
          let i = t && o.consume("[");
          try {
            let l = o.parseType(y.PREFIX);
            if (i && !o.consume("]"))
              throw new Error("Unterminated variadic type. Missing ']'");
            return {
              type: "JsdocTypeVariadic",
              element: J(l),
              meta: {
                position: "prefix",
                squareBrackets: i
              }
            };
          } catch (l) {
            if (l instanceof a) {
              if (i)
                throw new Error("Empty square brackets for variadic are not allowed.");
              return {
                type: "JsdocTypeVariadic",
                meta: {
                  position: void 0,
                  squareBrackets: !1
                }
              };
            } else
              throw l;
          }
        }, "parsePrefix"),
        parseInfix: e ? (o, i) => (o.consume("..."), {
          type: "JsdocTypeVariadic",
          element: J(i),
          meta: {
            position: "suffix",
            squareBrackets: !1
          }
        }) : void 0
      });
    }
    r$1(Ee, "createVariadicParslet");
    let Ge = x({
      name: "symbolParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "(", "accept"),
      precedence: y.SYMBOL,
      parseInfix: /* @__PURE__ */ r$1((e, t) => {
        if (t.type !== "JsdocTypeName")
          throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
        e.consume("(");
        let o = {
          type: "JsdocTypeSymbol",
          value: t.value
        };
        if (!e.consume(")")) {
          let i = e.parseIntermediateType(y.SYMBOL);
          if (o.element = _t(i), !e.consume(")"))
            throw new Error("Symbol does not end after value");
        }
        return o;
      }, "parseInfix")
    }), Xe = x({
      name: "arrayBracketsParslet",
      precedence: y.ARRAY_BRACKETS,
      accept: /* @__PURE__ */ r$1((e, t) => e === "[" && t === "]", "accept"),
      parseInfix: /* @__PURE__ */ r$1((e, t) => (e.consume("["), e.consume("]"), {
        type: "JsdocTypeGeneric",
        left: {
          type: "JsdocTypeName",
          value: "Array"
        },
        elements: [
          J(t)
        ],
        meta: {
          brackets: "square",
          dot: !1
        }
      }), "parseInfix")
    });
    function Ne({ objectFieldGrammar: e, allowKeyTypes: t }) {
      return x({
        name: "objectParslet",
        accept: /* @__PURE__ */ r$1((o) => o === "{", "accept"),
        parsePrefix: /* @__PURE__ */ r$1((o) => {
          o.consume("{");
          let i = {
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: []
          };
          if (!o.consume("}")) {
            let l, f = new I(e, o.lexer, o);
            for (; ; ) {
              f.acceptLexerState(o);
              let d = f.parseIntermediateType(y.OBJECT);
              o.acceptLexerState(f), d === void 0 && t && (d = o.parseIntermediateType(y.OBJECT));
              let h = !1;
              if (d.type === "JsdocTypeNullable" && (h = !0, d = d.element), d.type === "JsdocTypeNumber" || d.type === "JsdocTypeName" || d.
              type === "JsdocTypeStringValue") {
                let E;
                d.type === "JsdocTypeStringValue" && (E = d.meta.quote), i.elements.push({
                  type: "JsdocTypeObjectField",
                  key: d.value.toString(),
                  right: void 0,
                  optional: h,
                  readonly: !1,
                  meta: {
                    quote: E
                  }
                });
              } else if (d.type === "JsdocTypeObjectField" || d.type === "JsdocTypeJsdocObjectField")
                i.elements.push(d);
              else
                throw new c(d);
              if (o.lexer.current.startOfLine)
                l = "linebreak";
              else if (o.consume(","))
                l = "comma";
              else if (o.consume(";"))
                l = "semicolon";
              else
                break;
              if (o.lexer.current.type === "}")
                break;
            }
            if (i.meta.separator = l ?? "comma", !o.consume("}"))
              throw new Error("Unterminated record type. Missing '}'");
          }
          return i;
        }, "parsePrefix")
      });
    }
    r$1(Ne, "createObjectParslet");
    function De({ allowSquaredProperties: e, allowKeyTypes: t, allowReadonly: o, allowOptional: i }) {
      return x({
        name: "objectFieldParslet",
        precedence: y.KEY_VALUE,
        accept: /* @__PURE__ */ r$1((l) => l === ":", "accept"),
        parseInfix: /* @__PURE__ */ r$1((l, f) => {
          var d;
          let h = !1, D = !1;
          i && f.type === "JsdocTypeNullable" && (h = !0, f = f.element), o && f.type === "JsdocTypeReadonlyProperty" && (D = !0, f = f.element);
          let E = (d = l.baseParser) !== null && d !== void 0 ? d : l;
          if (E.acceptLexerState(l), f.type === "JsdocTypeNumber" || f.type === "JsdocTypeName" || f.type === "JsdocTypeStringValue" || Je(f)) {
            if (Je(f) && !e)
              throw new c(f);
            E.consume(":");
            let O;
            f.type === "JsdocTypeStringValue" && (O = f.meta.quote);
            let ae = E.parseType(y.KEY_VALUE);
            return l.acceptLexerState(E), {
              type: "JsdocTypeObjectField",
              key: Je(f) ? f : f.value.toString(),
              right: ae,
              optional: h,
              readonly: D,
              meta: {
                quote: O
              }
            };
          } else {
            if (!t)
              throw new c(f);
            E.consume(":");
            let O = E.parseType(y.KEY_VALUE);
            return l.acceptLexerState(E), {
              type: "JsdocTypeJsdocObjectField",
              left: J(f),
              right: O
            };
          }
        }, "parseInfix")
      });
    }
    r$1(De, "createObjectFieldParslet");
    function Oe({ allowOptional: e, allowVariadic: t }) {
      return x({
        name: "keyValueParslet",
        precedence: y.KEY_VALUE,
        accept: /* @__PURE__ */ r$1((o) => o === ":", "accept"),
        parseInfix: /* @__PURE__ */ r$1((o, i) => {
          let l = !1, f = !1;
          if (e && i.type === "JsdocTypeNullable" && (l = !0, i = i.element), t && i.type === "JsdocTypeVariadic" && i.element !== void 0 &&
          (f = !0, i = i.element), i.type !== "JsdocTypeName")
            throw new c(i);
          o.consume(":");
          let d = o.parseType(y.KEY_VALUE);
          return {
            type: "JsdocTypeKeyValue",
            key: i.value,
            right: d,
            optional: l,
            variadic: f
          };
        }, "parseInfix")
      });
    }
    r$1(Oe, "createKeyValueParslet");
    let ze = [
      ...Pe,
      Se({
        allowWithoutParenthesis: !0,
        allowNamedParameters: ["this", "new"],
        allowNoReturnType: !0,
        allowNewAsFunctionKeyword: !1
      }),
      Y,
      te({
        allowedTypes: ["module", "external", "event"],
        pathGrammar: L
      }),
      Ee({
        allowEnclosingBrackets: !0,
        allowPostfix: !0
      }),
      R({
        allowedAdditionalTokens: ["keyof"]
      }),
      Ge,
      Xe,
      ee({
        allowSquareBracketsOnAnyType: !1,
        allowJsdocNamePaths: !0,
        pathGrammar: L
      })
    ], $t = [
      ...ze,
      Ne({
        // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
        // we leave out the object type deliberately
        objectFieldGrammar: [
          R({
            allowedAdditionalTokens: ["module", "in"]
          }),
          De({
            allowSquaredProperties: !1,
            allowKeyTypes: !0,
            allowOptional: !1,
            allowReadonly: !1
          }),
          ...ze
        ],
        allowKeyTypes: !0
      }),
      Oe({
        allowOptional: !0,
        allowVariadic: !0
      })
    ], He = x({
      name: "typeOfParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "typeof", "accept"),
      parsePrefix: /* @__PURE__ */ r$1((e) => (e.consume("typeof"), {
        type: "JsdocTypeTypeof",
        element: J(e.parseType(y.KEY_OF_TYPE_OF))
      }), "parsePrefix")
    }), qt = [
      R({
        allowedAdditionalTokens: ["module", "keyof", "event", "external", "in"]
      }),
      we,
      Q,
      Y,
      Z,
      De({
        allowSquaredProperties: !1,
        allowKeyTypes: !1,
        allowOptional: !1,
        allowReadonly: !1
      })
    ], Yt = [
      ...Pe,
      Ne({
        allowKeyTypes: !1,
        objectFieldGrammar: qt
      }),
      R({
        allowedAdditionalTokens: ["event", "external", "in"]
      }),
      He,
      Se({
        allowWithoutParenthesis: !1,
        allowNamedParameters: ["this", "new"],
        allowNoReturnType: !0,
        allowNewAsFunctionKeyword: !1
      }),
      Ee({
        allowEnclosingBrackets: !1,
        allowPostfix: !1
      }),
      // additional name parslet is needed for some special cases
      R({
        allowedAdditionalTokens: ["keyof"]
      }),
      te({
        allowedTypes: ["module"],
        pathGrammar: L
      }),
      ee({
        allowSquareBracketsOnAnyType: !1,
        allowJsdocNamePaths: !0,
        pathGrammar: L
      }),
      Oe({
        allowOptional: !1,
        allowVariadic: !1
      }),
      Ge
    ], Wt = x({
      name: "assertsParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "asserts", "accept"),
      parsePrefix: /* @__PURE__ */ r$1((e) => {
        e.consume("asserts");
        let t = e.parseIntermediateType(y.SYMBOL);
        if (t.type !== "JsdocTypeName")
          throw new c(t, "A typescript asserts always has to have a name on the left side.");
        return e.consume("is"), {
          type: "JsdocTypeAsserts",
          left: t,
          right: J(e.parseIntermediateType(y.INFIX))
        };
      }, "parsePrefix")
    });
    function Gt({ allowQuestionMark: e }) {
      return x({
        name: "tupleParslet",
        accept: /* @__PURE__ */ r$1((t) => t === "[", "accept"),
        parsePrefix: /* @__PURE__ */ r$1((t) => {
          t.consume("[");
          let o = {
            type: "JsdocTypeTuple",
            elements: []
          };
          if (t.consume("]"))
            return o;
          let i = t.parseIntermediateType(y.ALL);
          if (i.type === "JsdocTypeParameterList" ? i.elements[0].type === "JsdocTypeKeyValue" ? o.elements = i.elements.map(H) : o.elements =
          i.elements.map(J) : i.type === "JsdocTypeKeyValue" ? o.elements = [H(i)] : o.elements = [J(i)], !t.consume("]"))
            throw new Error("Unterminated '['");
          if (!e && o.elements.some((l) => l.type === "JsdocTypeUnknown"))
            throw new Error("Question mark in tuple not allowed");
          return o;
        }, "parsePrefix")
      });
    }
    r$1(Gt, "createTupleParslet");
    let Xt = x({
      name: "keyOfParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "keyof", "accept"),
      parsePrefix: /* @__PURE__ */ r$1((e) => (e.consume("keyof"), {
        type: "JsdocTypeKeyof",
        element: J(e.parseType(y.KEY_OF_TYPE_OF))
      }), "parsePrefix")
    }), zt = x({
      name: "importParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "import", "accept"),
      parsePrefix: /* @__PURE__ */ r$1((e) => {
        if (e.consume("import"), !e.consume("("))
          throw new Error("Missing parenthesis after import keyword");
        let t = e.parseType(y.PREFIX);
        if (t.type !== "JsdocTypeStringValue")
          throw new Error("Only string values are allowed as paths for imports");
        if (!e.consume(")"))
          throw new Error("Missing closing parenthesis after import keyword");
        return {
          type: "JsdocTypeImport",
          element: t
        };
      }, "parsePrefix")
    }), Ht = x({
      name: "readonlyPropertyParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "readonly", "accept"),
      parsePrefix: /* @__PURE__ */ r$1((e) => (e.consume("readonly"), {
        type: "JsdocTypeReadonlyProperty",
        element: e.parseType(y.KEY_VALUE)
      }), "parsePrefix")
    }), Qt = x({
      name: "arrowFunctionParslet",
      precedence: y.ARROW,
      accept: /* @__PURE__ */ r$1((e) => e === "=>", "accept"),
      parseInfix: /* @__PURE__ */ r$1((e, t) => (e.consume("=>"), {
        type: "JsdocTypeFunction",
        parameters: be(t).map(Ft),
        arrow: !0,
        constructor: !1,
        parenthesis: !0,
        returnType: e.parseType(y.OBJECT)
      }), "parseInfix")
    }), Zt = x({
      name: "intersectionParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "&", "accept"),
      precedence: y.INTERSECTION,
      parseInfix: /* @__PURE__ */ r$1((e, t) => {
        e.consume("&");
        let o = [];
        do
          o.push(e.parseType(y.INTERSECTION));
        while (e.consume("&"));
        return {
          type: "JsdocTypeIntersection",
          elements: [J(t), ...o]
        };
      }, "parseInfix")
    }), er = x({
      name: "predicateParslet",
      precedence: y.INFIX,
      accept: /* @__PURE__ */ r$1((e) => e === "is", "accept"),
      parseInfix: /* @__PURE__ */ r$1((e, t) => {
        if (t.type !== "JsdocTypeName")
          throw new c(t, "A typescript predicate always has to have a name on the left side.");
        return e.consume("is"), {
          type: "JsdocTypePredicate",
          left: t,
          right: J(e.parseIntermediateType(y.INFIX))
        };
      }, "parseInfix")
    }), tr = x({
      name: "objectSquareBracketPropertyParslet",
      accept: /* @__PURE__ */ r$1((e) => e === "[", "accept"),
      parsePrefix: /* @__PURE__ */ r$1((e) => {
        if (e.baseParser === void 0)
          throw new Error("Only allowed inside object grammar");
        e.consume("[");
        let t = e.lexer.current.text;
        e.consume("Identifier");
        let o;
        if (e.consume(":")) {
          let i = e.baseParser;
          i.acceptLexerState(e), o = {
            type: "JsdocTypeIndexSignature",
            key: t,
            right: i.parseType(y.INDEX_BRACKETS)
          }, e.acceptLexerState(i);
        } else if (e.consume("in")) {
          let i = e.baseParser;
          i.acceptLexerState(e), o = {
            type: "JsdocTypeMappedType",
            key: t,
            right: i.parseType(y.ARRAY_BRACKETS)
          }, e.acceptLexerState(i);
        } else
          throw new Error("Missing ':' or 'in' inside square bracketed property.");
        if (!e.consume("]"))
          throw new Error("Unterminated square brackets");
        return o;
      }, "parsePrefix")
    }), rr = [
      Ht,
      R({
        allowedAdditionalTokens: ["module", "event", "keyof", "event", "external", "in"]
      }),
      we,
      Q,
      Y,
      Z,
      De({
        allowSquaredProperties: !0,
        allowKeyTypes: !1,
        allowOptional: !0,
        allowReadonly: !0
      }),
      tr
    ], nr = [
      ...Pe,
      Ne({
        allowKeyTypes: !1,
        objectFieldGrammar: rr
      }),
      He,
      Xt,
      zt,
      Y,
      Se({
        allowWithoutParenthesis: !0,
        allowNoReturnType: !1,
        allowNamedParameters: ["this", "new", "args"],
        allowNewAsFunctionKeyword: !0
      }),
      Gt({
        allowQuestionMark: !1
      }),
      Ee({
        allowEnclosingBrackets: !1,
        allowPostfix: !1
      }),
      Wt,
      R({
        allowedAdditionalTokens: ["event", "external", "in"]
      }),
      te({
        allowedTypes: ["module"],
        pathGrammar: L
      }),
      Xe,
      Qt,
      ee({
        allowSquareBracketsOnAnyType: !0,
        allowJsdocNamePaths: !1,
        pathGrammar: L
      }),
      Zt,
      er,
      Oe({
        allowVariadic: !0,
        allowOptional: !0
      })
    ];
    function Qe(e, t) {
      switch (t) {
        case "closure":
          return new I(Yt, e).parse();
        case "jsdoc":
          return new I($t, e).parse();
        case "typescript":
          return new I(nr, e).parse();
      }
    }
    r$1(Qe, "parse");
    function or(e, t = ["typescript", "closure", "jsdoc"]) {
      let o;
      for (let i of t)
        try {
          return Qe(e, i);
        } catch (l) {
          o = l;
        }
      throw o;
    }
    r$1(or, "tryParse");
    function W(e, t) {
      let o = e[t.type];
      if (o === void 0)
        throw new Error(`In this set of transform rules exists no rule for type ${t.type}.`);
      return o(t, (i) => W(e, i));
    }
    r$1(W, "transform");
    function N(e) {
      throw new Error("This transform is not available. Are you trying the correct parsing mode?");
    }
    r$1(N, "notAvailableTransform");
    function Ze(e) {
      let t = {
        params: []
      };
      for (let o of e.parameters)
        o.type === "JsdocTypeKeyValue" ? o.key === "this" ? t.this = o.right : o.key === "new" ? t.new = o.right : t.params.push(o) : t.params.
        push(o);
      return t;
    }
    r$1(Ze, "extractSpecialParams");
    function re(e, t, o) {
      return e === "prefix" ? o + t : t + o;
    }
    r$1(re, "applyPosition");
    function j(e, t) {
      switch (t) {
        case "double":
          return `"${e}"`;
        case "single":
          return `'${e}'`;
        case void 0:
          return e;
      }
    }
    r$1(j, "quote");
    function et() {
      return {
        JsdocTypeParenthesis: /* @__PURE__ */ r$1((e, t) => `(${e.element !== void 0 ? t(e.element) : ""})`, "JsdocTypeParenthesis"),
        JsdocTypeKeyof: /* @__PURE__ */ r$1((e, t) => `keyof ${t(e.element)}`, "JsdocTypeKeyof"),
        JsdocTypeFunction: /* @__PURE__ */ r$1((e, t) => {
          if (e.arrow) {
            if (e.returnType === void 0)
              throw new Error("Arrow function needs a return type.");
            let o = `(${e.parameters.map(t).join(", ")}) => ${t(e.returnType)}`;
            return e.constructor && (o = "new " + o), o;
          } else {
            let o = e.constructor ? "new" : "function";
            return e.parenthesis && (o += `(${e.parameters.map(t).join(", ")})`, e.returnType !== void 0 && (o += `: ${t(e.returnType)}`)), o;
          }
        }, "JsdocTypeFunction"),
        JsdocTypeName: /* @__PURE__ */ r$1((e) => e.value, "JsdocTypeName"),
        JsdocTypeTuple: /* @__PURE__ */ r$1((e, t) => `[${e.elements.map(t).join(", ")}]`, "JsdocTypeTuple"),
        JsdocTypeVariadic: /* @__PURE__ */ r$1((e, t) => e.meta.position === void 0 ? "..." : re(e.meta.position, t(e.element), "..."), "Jsdoc\
TypeVariadic"),
        JsdocTypeNamePath: /* @__PURE__ */ r$1((e, t) => {
          let o = t(e.left), i = t(e.right);
          switch (e.pathType) {
            case "inner":
              return `${o}~${i}`;
            case "instance":
              return `${o}#${i}`;
            case "property":
              return `${o}.${i}`;
            case "property-brackets":
              return `${o}[${i}]`;
          }
        }, "JsdocTypeNamePath"),
        JsdocTypeStringValue: /* @__PURE__ */ r$1((e) => j(e.value, e.meta.quote), "JsdocTypeStringValue"),
        JsdocTypeAny: /* @__PURE__ */ r$1(() => "*", "JsdocTypeAny"),
        JsdocTypeGeneric: /* @__PURE__ */ r$1((e, t) => {
          if (e.meta.brackets === "square") {
            let o = e.elements[0], i = t(o);
            return o.type === "JsdocTypeUnion" || o.type === "JsdocTypeIntersection" ? `(${i})[]` : `${i}[]`;
          } else
            return `${t(e.left)}${e.meta.dot ? "." : ""}<${e.elements.map(t).join(", ")}>`;
        }, "JsdocTypeGeneric"),
        JsdocTypeImport: /* @__PURE__ */ r$1((e, t) => `import(${t(e.element)})`, "JsdocTypeImport"),
        JsdocTypeObjectField: /* @__PURE__ */ r$1((e, t) => {
          let o = "";
          return e.readonly && (o += "readonly "), typeof e.key == "string" ? o += j(e.key, e.meta.quote) : o += t(e.key), e.optional && (o +=
          "?"), e.right === void 0 ? o : o + `: ${t(e.right)}`;
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: /* @__PURE__ */ r$1((e, t) => `${t(e.left)}: ${t(e.right)}`, "JsdocTypeJsdocObjectField"),
        JsdocTypeKeyValue: /* @__PURE__ */ r$1((e, t) => {
          let o = e.key;
          return e.optional && (o += "?"), e.variadic && (o = "..." + o), e.right === void 0 ? o : o + `: ${t(e.right)}`;
        }, "JsdocTypeKeyValue"),
        JsdocTypeSpecialNamePath: /* @__PURE__ */ r$1((e) => `${e.specialType}:${j(e.value, e.meta.quote)}`, "JsdocTypeSpecialNamePath"),
        JsdocTypeNotNullable: /* @__PURE__ */ r$1((e, t) => re(e.meta.position, t(e.element), "!"), "JsdocTypeNotNullable"),
        JsdocTypeNull: /* @__PURE__ */ r$1(() => "null", "JsdocTypeNull"),
        JsdocTypeNullable: /* @__PURE__ */ r$1((e, t) => re(e.meta.position, t(e.element), "?"), "JsdocTypeNullable"),
        JsdocTypeNumber: /* @__PURE__ */ r$1((e) => e.value.toString(), "JsdocTypeNumber"),
        JsdocTypeObject: /* @__PURE__ */ r$1((e, t) => `{${e.elements.map(t).join((e.meta.separator === "comma" ? "," : ";") + " ")}}`, "Jsdoc\
TypeObject"),
        JsdocTypeOptional: /* @__PURE__ */ r$1((e, t) => re(e.meta.position, t(e.element), "="), "JsdocTypeOptional"),
        JsdocTypeSymbol: /* @__PURE__ */ r$1((e, t) => `${e.value}(${e.element !== void 0 ? t(e.element) : ""})`, "JsdocTypeSymbol"),
        JsdocTypeTypeof: /* @__PURE__ */ r$1((e, t) => `typeof ${t(e.element)}`, "JsdocTypeTypeof"),
        JsdocTypeUndefined: /* @__PURE__ */ r$1(() => "undefined", "JsdocTypeUndefined"),
        JsdocTypeUnion: /* @__PURE__ */ r$1((e, t) => e.elements.map(t).join(" | "), "JsdocTypeUnion"),
        JsdocTypeUnknown: /* @__PURE__ */ r$1(() => "?", "JsdocTypeUnknown"),
        JsdocTypeIntersection: /* @__PURE__ */ r$1((e, t) => e.elements.map(t).join(" & "), "JsdocTypeIntersection"),
        JsdocTypeProperty: /* @__PURE__ */ r$1((e) => j(e.value, e.meta.quote), "JsdocTypeProperty"),
        JsdocTypePredicate: /* @__PURE__ */ r$1((e, t) => `${t(e.left)} is ${t(e.right)}`, "JsdocTypePredicate"),
        JsdocTypeIndexSignature: /* @__PURE__ */ r$1((e, t) => `[${e.key}: ${t(e.right)}]`, "JsdocTypeIndexSignature"),
        JsdocTypeMappedType: /* @__PURE__ */ r$1((e, t) => `[${e.key} in ${t(e.right)}]`, "JsdocTypeMappedType"),
        JsdocTypeAsserts: /* @__PURE__ */ r$1((e, t) => `asserts ${t(e.left)} is ${t(e.right)}`, "JsdocTypeAsserts")
      };
    }
    r$1(et, "stringifyRules");
    let sr = et();
    function ar(e) {
      return W(sr, e);
    }
    r$1(ar, "stringify");
    let ir = [
      "null",
      "true",
      "false",
      "break",
      "case",
      "catch",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "else",
      "export",
      "extends",
      "finally",
      "for",
      "function",
      "if",
      "import",
      "in",
      "instanceof",
      "new",
      "return",
      "super",
      "switch",
      "this",
      "throw",
      "try",
      "typeof",
      "var",
      "void",
      "while",
      "with",
      "yield"
    ];
    function F(e) {
      let t = {
        type: "NameExpression",
        name: e
      };
      return ir.includes(e) && (t.reservedWord = !0), t;
    }
    r$1(F, "makeName");
    let pr = {
      JsdocTypeOptional: /* @__PURE__ */ r$1((e, t) => {
        let o = t(e.element);
        return o.optional = !0, o;
      }, "JsdocTypeOptional"),
      JsdocTypeNullable: /* @__PURE__ */ r$1((e, t) => {
        let o = t(e.element);
        return o.nullable = !0, o;
      }, "JsdocTypeNullable"),
      JsdocTypeNotNullable: /* @__PURE__ */ r$1((e, t) => {
        let o = t(e.element);
        return o.nullable = !1, o;
      }, "JsdocTypeNotNullable"),
      JsdocTypeVariadic: /* @__PURE__ */ r$1((e, t) => {
        if (e.element === void 0)
          throw new Error("dots without value are not allowed in catharsis mode");
        let o = t(e.element);
        return o.repeatable = !0, o;
      }, "JsdocTypeVariadic"),
      JsdocTypeAny: /* @__PURE__ */ r$1(() => ({
        type: "AllLiteral"
      }), "JsdocTypeAny"),
      JsdocTypeNull: /* @__PURE__ */ r$1(() => ({
        type: "NullLiteral"
      }), "JsdocTypeNull"),
      JsdocTypeStringValue: /* @__PURE__ */ r$1((e) => F(j(e.value, e.meta.quote)), "JsdocTypeStringValue"),
      JsdocTypeUndefined: /* @__PURE__ */ r$1(() => ({
        type: "UndefinedLiteral"
      }), "JsdocTypeUndefined"),
      JsdocTypeUnknown: /* @__PURE__ */ r$1(() => ({
        type: "UnknownLiteral"
      }), "JsdocTypeUnknown"),
      JsdocTypeFunction: /* @__PURE__ */ r$1((e, t) => {
        let o = Ze(e), i = {
          type: "FunctionType",
          params: o.params.map(t)
        };
        return o.this !== void 0 && (i.this = t(o.this)), o.new !== void 0 && (i.new = t(o.new)), e.returnType !== void 0 && (i.result = t(e.
        returnType)), i;
      }, "JsdocTypeFunction"),
      JsdocTypeGeneric: /* @__PURE__ */ r$1((e, t) => ({
        type: "TypeApplication",
        applications: e.elements.map((o) => t(o)),
        expression: t(e.left)
      }), "JsdocTypeGeneric"),
      JsdocTypeSpecialNamePath: /* @__PURE__ */ r$1((e) => F(e.specialType + ":" + j(e.value, e.meta.quote)), "JsdocTypeSpecialNamePath"),
      JsdocTypeName: /* @__PURE__ */ r$1((e) => e.value !== "function" ? F(e.value) : {
        type: "FunctionType",
        params: []
      }, "JsdocTypeName"),
      JsdocTypeNumber: /* @__PURE__ */ r$1((e) => F(e.value.toString()), "JsdocTypeNumber"),
      JsdocTypeObject: /* @__PURE__ */ r$1((e, t) => {
        let o = {
          type: "RecordType",
          fields: []
        };
        for (let i of e.elements)
          i.type !== "JsdocTypeObjectField" && i.type !== "JsdocTypeJsdocObjectField" ? o.fields.push({
            type: "FieldType",
            key: t(i),
            value: void 0
          }) : o.fields.push(t(i));
        return o;
      }, "JsdocTypeObject"),
      JsdocTypeObjectField: /* @__PURE__ */ r$1((e, t) => {
        if (typeof e.key != "string")
          throw new Error("Index signatures and mapped types are not supported");
        return {
          type: "FieldType",
          key: F(j(e.key, e.meta.quote)),
          value: e.right === void 0 ? void 0 : t(e.right)
        };
      }, "JsdocTypeObjectField"),
      JsdocTypeJsdocObjectField: /* @__PURE__ */ r$1((e, t) => ({
        type: "FieldType",
        key: t(e.left),
        value: t(e.right)
      }), "JsdocTypeJsdocObjectField"),
      JsdocTypeUnion: /* @__PURE__ */ r$1((e, t) => ({
        type: "TypeUnion",
        elements: e.elements.map((o) => t(o))
      }), "JsdocTypeUnion"),
      JsdocTypeKeyValue: /* @__PURE__ */ r$1((e, t) => ({
        type: "FieldType",
        key: F(e.key),
        value: e.right === void 0 ? void 0 : t(e.right)
      }), "JsdocTypeKeyValue"),
      JsdocTypeNamePath: /* @__PURE__ */ r$1((e, t) => {
        let o = t(e.left), i;
        e.right.type === "JsdocTypeSpecialNamePath" ? i = t(e.right).name : i = j(e.right.value, e.right.meta.quote);
        let l = e.pathType === "inner" ? "~" : e.pathType === "instance" ? "#" : ".";
        return F(`${o.name}${l}${i}`);
      }, "JsdocTypeNamePath"),
      JsdocTypeSymbol: /* @__PURE__ */ r$1((e) => {
        let t = "", o = e.element, i = !1;
        return o?.type === "JsdocTypeVariadic" && (o.meta.position === "prefix" ? t = "..." : i = !0, o = o.element), o?.type === "JsdocType\
Name" ? t += o.value : o?.type === "JsdocTypeNumber" && (t += o.value.toString()), i && (t += "..."), F(`${e.value}(${t})`);
      }, "JsdocTypeSymbol"),
      JsdocTypeParenthesis: /* @__PURE__ */ r$1((e, t) => t(J(e.element)), "JsdocTypeParenthesis"),
      JsdocTypeMappedType: N,
      JsdocTypeIndexSignature: N,
      JsdocTypeImport: N,
      JsdocTypeKeyof: N,
      JsdocTypeTuple: N,
      JsdocTypeTypeof: N,
      JsdocTypeIntersection: N,
      JsdocTypeProperty: N,
      JsdocTypePredicate: N,
      JsdocTypeAsserts: N
    };
    function cr(e) {
      return W(pr, e);
    }
    r$1(cr, "catharsisTransform");
    function V(e) {
      switch (e) {
        case void 0:
          return "none";
        case "single":
          return "single";
        case "double":
          return "double";
      }
    }
    r$1(V, "getQuoteStyle");
    function lr(e) {
      switch (e) {
        case "inner":
          return "INNER_MEMBER";
        case "instance":
          return "INSTANCE_MEMBER";
        case "property":
          return "MEMBER";
        case "property-brackets":
          return "MEMBER";
      }
    }
    r$1(lr, "getMemberType");
    function ve(e, t) {
      return t.length === 2 ? {
        type: e,
        left: t[0],
        right: t[1]
      } : {
        type: e,
        left: t[0],
        right: ve(e, t.slice(1))
      };
    }
    r$1(ve, "nestResults");
    let ur = {
      JsdocTypeOptional: /* @__PURE__ */ r$1((e, t) => ({
        type: "OPTIONAL",
        value: t(e.element),
        meta: {
          syntax: e.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
        }
      }), "JsdocTypeOptional"),
      JsdocTypeNullable: /* @__PURE__ */ r$1((e, t) => ({
        type: "NULLABLE",
        value: t(e.element),
        meta: {
          syntax: e.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
        }
      }), "JsdocTypeNullable"),
      JsdocTypeNotNullable: /* @__PURE__ */ r$1((e, t) => ({
        type: "NOT_NULLABLE",
        value: t(e.element),
        meta: {
          syntax: e.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
        }
      }), "JsdocTypeNotNullable"),
      JsdocTypeVariadic: /* @__PURE__ */ r$1((e, t) => {
        let o = {
          type: "VARIADIC",
          meta: {
            syntax: e.meta.position === "prefix" ? "PREFIX_DOTS" : e.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
          }
        };
        return e.element !== void 0 && (o.value = t(e.element)), o;
      }, "JsdocTypeVariadic"),
      JsdocTypeName: /* @__PURE__ */ r$1((e) => ({
        type: "NAME",
        name: e.value
      }), "JsdocTypeName"),
      JsdocTypeTypeof: /* @__PURE__ */ r$1((e, t) => ({
        type: "TYPE_QUERY",
        name: t(e.element)
      }), "JsdocTypeTypeof"),
      JsdocTypeTuple: /* @__PURE__ */ r$1((e, t) => ({
        type: "TUPLE",
        entries: e.elements.map(t)
      }), "JsdocTypeTuple"),
      JsdocTypeKeyof: /* @__PURE__ */ r$1((e, t) => ({
        type: "KEY_QUERY",
        value: t(e.element)
      }), "JsdocTypeKeyof"),
      JsdocTypeImport: /* @__PURE__ */ r$1((e) => ({
        type: "IMPORT",
        path: {
          type: "STRING_VALUE",
          quoteStyle: V(e.element.meta.quote),
          string: e.element.value
        }
      }), "JsdocTypeImport"),
      JsdocTypeUndefined: /* @__PURE__ */ r$1(() => ({
        type: "NAME",
        name: "undefined"
      }), "JsdocTypeUndefined"),
      JsdocTypeAny: /* @__PURE__ */ r$1(() => ({
        type: "ANY"
      }), "JsdocTypeAny"),
      JsdocTypeFunction: /* @__PURE__ */ r$1((e, t) => {
        let o = Ze(e), i = {
          type: e.arrow ? "ARROW" : "FUNCTION",
          params: o.params.map((l) => {
            if (l.type === "JsdocTypeKeyValue") {
              if (l.right === void 0)
                throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
              return {
                type: "NAMED_PARAMETER",
                name: l.key,
                typeName: t(l.right)
              };
            } else
              return t(l);
          }),
          new: null,
          returns: null
        };
        return o.this !== void 0 ? i.this = t(o.this) : e.arrow || (i.this = null), o.new !== void 0 && (i.new = t(o.new)), e.returnType !==
        void 0 && (i.returns = t(e.returnType)), i;
      }, "JsdocTypeFunction"),
      JsdocTypeGeneric: /* @__PURE__ */ r$1((e, t) => {
        let o = {
          type: "GENERIC",
          subject: t(e.left),
          objects: e.elements.map(t),
          meta: {
            syntax: e.meta.brackets === "square" ? "SQUARE_BRACKET" : e.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
          }
        };
        return e.meta.brackets === "square" && e.elements[0].type === "JsdocTypeFunction" && !e.elements[0].parenthesis && (o.objects[0] = {
          type: "NAME",
          name: "function"
        }), o;
      }, "JsdocTypeGeneric"),
      JsdocTypeObjectField: /* @__PURE__ */ r$1((e, t) => {
        if (typeof e.key != "string")
          throw new Error("Index signatures and mapped types are not supported");
        if (e.right === void 0)
          return {
            type: "RECORD_ENTRY",
            key: e.key,
            quoteStyle: V(e.meta.quote),
            value: null,
            readonly: !1
          };
        let o = t(e.right);
        return e.optional && (o = {
          type: "OPTIONAL",
          value: o,
          meta: {
            syntax: "SUFFIX_KEY_QUESTION_MARK"
          }
        }), {
          type: "RECORD_ENTRY",
          key: e.key.toString(),
          quoteStyle: V(e.meta.quote),
          value: o,
          readonly: !1
        };
      }, "JsdocTypeObjectField"),
      JsdocTypeJsdocObjectField: /* @__PURE__ */ r$1(() => {
        throw new Error("Keys may not be typed in jsdoctypeparser.");
      }, "JsdocTypeJsdocObjectField"),
      JsdocTypeKeyValue: /* @__PURE__ */ r$1((e, t) => {
        if (e.right === void 0)
          return {
            type: "RECORD_ENTRY",
            key: e.key,
            quoteStyle: "none",
            value: null,
            readonly: !1
          };
        let o = t(e.right);
        return e.optional && (o = {
          type: "OPTIONAL",
          value: o,
          meta: {
            syntax: "SUFFIX_KEY_QUESTION_MARK"
          }
        }), {
          type: "RECORD_ENTRY",
          key: e.key,
          quoteStyle: "none",
          value: o,
          readonly: !1
        };
      }, "JsdocTypeKeyValue"),
      JsdocTypeObject: /* @__PURE__ */ r$1((e, t) => {
        let o = [];
        for (let i of e.elements)
          (i.type === "JsdocTypeObjectField" || i.type === "JsdocTypeJsdocObjectField") && o.push(t(i));
        return {
          type: "RECORD",
          entries: o
        };
      }, "JsdocTypeObject"),
      JsdocTypeSpecialNamePath: /* @__PURE__ */ r$1((e) => {
        if (e.specialType !== "module")
          throw new Error(`jsdoctypeparser does not support type ${e.specialType} at this point.`);
        return {
          type: "MODULE",
          value: {
            type: "FILE_PATH",
            quoteStyle: V(e.meta.quote),
            path: e.value
          }
        };
      }, "JsdocTypeSpecialNamePath"),
      JsdocTypeNamePath: /* @__PURE__ */ r$1((e, t) => {
        let o = !1, i, l;
        e.right.type === "JsdocTypeSpecialNamePath" && e.right.specialType === "event" ? (o = !0, i = e.right.value, l = V(e.right.meta.quote)) :
        (i = e.right.value, l = V(e.right.meta.quote));
        let f = {
          type: lr(e.pathType),
          owner: t(e.left),
          name: i,
          quoteStyle: l,
          hasEventPrefix: o
        };
        if (f.owner.type === "MODULE") {
          let d = f.owner;
          return f.owner = f.owner.value, d.value = f, d;
        } else
          return f;
      }, "JsdocTypeNamePath"),
      JsdocTypeUnion: /* @__PURE__ */ r$1((e, t) => ve("UNION", e.elements.map(t)), "JsdocTypeUnion"),
      JsdocTypeParenthesis: /* @__PURE__ */ r$1((e, t) => ({
        type: "PARENTHESIS",
        value: t(J(e.element))
      }), "JsdocTypeParenthesis"),
      JsdocTypeNull: /* @__PURE__ */ r$1(() => ({
        type: "NAME",
        name: "null"
      }), "JsdocTypeNull"),
      JsdocTypeUnknown: /* @__PURE__ */ r$1(() => ({
        type: "UNKNOWN"
      }), "JsdocTypeUnknown"),
      JsdocTypeStringValue: /* @__PURE__ */ r$1((e) => ({
        type: "STRING_VALUE",
        quoteStyle: V(e.meta.quote),
        string: e.value
      }), "JsdocTypeStringValue"),
      JsdocTypeIntersection: /* @__PURE__ */ r$1((e, t) => ve("INTERSECTION", e.elements.map(t)), "JsdocTypeIntersection"),
      JsdocTypeNumber: /* @__PURE__ */ r$1((e) => ({
        type: "NUMBER_VALUE",
        number: e.value.toString()
      }), "JsdocTypeNumber"),
      JsdocTypeSymbol: N,
      JsdocTypeProperty: N,
      JsdocTypePredicate: N,
      JsdocTypeMappedType: N,
      JsdocTypeIndexSignature: N,
      JsdocTypeAsserts: N
    };
    function mr(e) {
      return W(ur, e);
    }
    r$1(mr, "jtpTransform");
    function fr() {
      return {
        JsdocTypeIntersection: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeIntersection",
          elements: e.elements.map(t)
        }), "JsdocTypeIntersection"),
        JsdocTypeGeneric: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeGeneric",
          left: t(e.left),
          elements: e.elements.map(t),
          meta: {
            dot: e.meta.dot,
            brackets: e.meta.brackets
          }
        }), "JsdocTypeGeneric"),
        JsdocTypeNullable: /* @__PURE__ */ r$1((e) => e, "JsdocTypeNullable"),
        JsdocTypeUnion: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeUnion",
          elements: e.elements.map(t)
        }), "JsdocTypeUnion"),
        JsdocTypeUnknown: /* @__PURE__ */ r$1((e) => e, "JsdocTypeUnknown"),
        JsdocTypeUndefined: /* @__PURE__ */ r$1((e) => e, "JsdocTypeUndefined"),
        JsdocTypeTypeof: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeTypeof",
          element: t(e.element)
        }), "JsdocTypeTypeof"),
        JsdocTypeSymbol: /* @__PURE__ */ r$1((e, t) => {
          let o = {
            type: "JsdocTypeSymbol",
            value: e.value
          };
          return e.element !== void 0 && (o.element = t(e.element)), o;
        }, "JsdocTypeSymbol"),
        JsdocTypeOptional: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeOptional",
          element: t(e.element),
          meta: {
            position: e.meta.position
          }
        }), "JsdocTypeOptional"),
        JsdocTypeObject: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeObject",
          meta: {
            separator: "comma"
          },
          elements: e.elements.map(t)
        }), "JsdocTypeObject"),
        JsdocTypeNumber: /* @__PURE__ */ r$1((e) => e, "JsdocTypeNumber"),
        JsdocTypeNull: /* @__PURE__ */ r$1((e) => e, "JsdocTypeNull"),
        JsdocTypeNotNullable: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeNotNullable",
          element: t(e.element),
          meta: {
            position: e.meta.position
          }
        }), "JsdocTypeNotNullable"),
        JsdocTypeSpecialNamePath: /* @__PURE__ */ r$1((e) => e, "JsdocTypeSpecialNamePath"),
        JsdocTypeObjectField: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeObjectField",
          key: e.key,
          right: e.right === void 0 ? void 0 : t(e.right),
          optional: e.optional,
          readonly: e.readonly,
          meta: e.meta
        }), "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeJsdocObjectField",
          left: t(e.left),
          right: t(e.right)
        }), "JsdocTypeJsdocObjectField"),
        JsdocTypeKeyValue: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeKeyValue",
          key: e.key,
          right: e.right === void 0 ? void 0 : t(e.right),
          optional: e.optional,
          variadic: e.variadic
        }), "JsdocTypeKeyValue"),
        JsdocTypeImport: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeImport",
          element: t(e.element)
        }), "JsdocTypeImport"),
        JsdocTypeAny: /* @__PURE__ */ r$1((e) => e, "JsdocTypeAny"),
        JsdocTypeStringValue: /* @__PURE__ */ r$1((e) => e, "JsdocTypeStringValue"),
        JsdocTypeNamePath: /* @__PURE__ */ r$1((e) => e, "JsdocTypeNamePath"),
        JsdocTypeVariadic: /* @__PURE__ */ r$1((e, t) => {
          let o = {
            type: "JsdocTypeVariadic",
            meta: {
              position: e.meta.position,
              squareBrackets: e.meta.squareBrackets
            }
          };
          return e.element !== void 0 && (o.element = t(e.element)), o;
        }, "JsdocTypeVariadic"),
        JsdocTypeTuple: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeTuple",
          elements: e.elements.map(t)
        }), "JsdocTypeTuple"),
        JsdocTypeName: /* @__PURE__ */ r$1((e) => e, "JsdocTypeName"),
        JsdocTypeFunction: /* @__PURE__ */ r$1((e, t) => {
          let o = {
            type: "JsdocTypeFunction",
            arrow: e.arrow,
            parameters: e.parameters.map(t),
            constructor: e.constructor,
            parenthesis: e.parenthesis
          };
          return e.returnType !== void 0 && (o.returnType = t(e.returnType)), o;
        }, "JsdocTypeFunction"),
        JsdocTypeKeyof: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeKeyof",
          element: t(e.element)
        }), "JsdocTypeKeyof"),
        JsdocTypeParenthesis: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeParenthesis",
          element: t(e.element)
        }), "JsdocTypeParenthesis"),
        JsdocTypeProperty: /* @__PURE__ */ r$1((e) => e, "JsdocTypeProperty"),
        JsdocTypePredicate: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypePredicate",
          left: t(e.left),
          right: t(e.right)
        }), "JsdocTypePredicate"),
        JsdocTypeIndexSignature: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeIndexSignature",
          key: e.key,
          right: t(e.right)
        }), "JsdocTypeIndexSignature"),
        JsdocTypeMappedType: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeMappedType",
          key: e.key,
          right: t(e.right)
        }), "JsdocTypeMappedType"),
        JsdocTypeAsserts: /* @__PURE__ */ r$1((e, t) => ({
          type: "JsdocTypeAsserts",
          left: t(e.left),
          right: t(e.right)
        }), "JsdocTypeAsserts")
      };
    }
    r$1(fr, "identityTransformRules");
    let tt = {
      JsdocTypeAny: [],
      JsdocTypeFunction: ["parameters", "returnType"],
      JsdocTypeGeneric: ["left", "elements"],
      JsdocTypeImport: [],
      JsdocTypeIndexSignature: ["right"],
      JsdocTypeIntersection: ["elements"],
      JsdocTypeKeyof: ["element"],
      JsdocTypeKeyValue: ["right"],
      JsdocTypeMappedType: ["right"],
      JsdocTypeName: [],
      JsdocTypeNamePath: ["left", "right"],
      JsdocTypeNotNullable: ["element"],
      JsdocTypeNull: [],
      JsdocTypeNullable: ["element"],
      JsdocTypeNumber: [],
      JsdocTypeObject: ["elements"],
      JsdocTypeObjectField: ["right"],
      JsdocTypeJsdocObjectField: ["left", "right"],
      JsdocTypeOptional: ["element"],
      JsdocTypeParenthesis: ["element"],
      JsdocTypeSpecialNamePath: [],
      JsdocTypeStringValue: [],
      JsdocTypeSymbol: ["element"],
      JsdocTypeTuple: ["elements"],
      JsdocTypeTypeof: ["element"],
      JsdocTypeUndefined: [],
      JsdocTypeUnion: ["elements"],
      JsdocTypeUnknown: [],
      JsdocTypeVariadic: ["element"],
      JsdocTypeProperty: [],
      JsdocTypePredicate: ["left", "right"],
      JsdocTypeAsserts: ["left", "right"]
    };
    function ke(e, t, o, i, l) {
      i?.(e, t, o);
      let f = tt[e.type];
      for (let d of f) {
        let h = e[d];
        if (h !== void 0)
          if (Array.isArray(h))
            for (let D of h)
              ke(D, e, d, i, l);
          else
            ke(h, e, d, i, l);
      }
      l?.(e, t, o);
    }
    r$1(ke, "_traverse");
    function yr(e, t, o) {
      ke(e, void 0, void 0, t, o);
    }
    r$1(yr, "traverse"), n.catharsisTransform = cr, n.identityTransformRules = fr, n.jtpTransform = mr, n.parse = Qe, n.stringify = ar, n.stringifyRules =
    et, n.transform = W, n.traverse = yr, n.tryParse = or, n.visitorKeys = tt;
  });
});

// src/docs-tools/argTypes/convert/flow/convert.ts
const { UnknownArgTypesError: br } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;
var Sr = /* @__PURE__ */ r$1((n) => n.name === "literal", "isLiteral"), Er = /* @__PURE__ */ r$1((n) => n.value.replace(/['|"]/g, ""), "toEnumOp\
tion"), Nr = /* @__PURE__ */ r$1((n) => {
  switch (n.type) {
    case "function":
      return { name: "function" };
    case "object":
      let s = {};
      return n.signature.properties.forEach((a) => {
        s[a.key] = B$1(a.value);
      }), {
        name: "object",
        value: s
      };
    default:
      throw new br({ type: n, language: "Flow" });
  }
}, "convertSig"), B$1 = /* @__PURE__ */ r$1((n) => {
  let { name: s, raw: a } = n, p = {};
  switch (typeof a < "u" && (p.raw = a), n.name) {
    case "literal":
      return { ...p, name: "other", value: n.value };
    case "string":
    case "number":
    case "symbol":
    case "boolean":
      return { ...p, name: s };
    case "Array":
      return { ...p, name: "array", value: n.elements.map(B$1) };
    case "signature":
      return { ...p, ...Nr(n) };
    case "union":
      return n.elements?.every(Sr) ? { ...p, name: "enum", value: n.elements?.map(Er) } : { ...p, name: s, value: n.elements?.map(B$1) };
    case "intersection":
      return { ...p, name: s, value: n.elements?.map(B$1) };
    default:
      return { ...p, name: "other", value: s };
  }
}, "convert");

// ../node_modules/es-toolkit/dist/predicate/isPlainObject.mjs
function X(n) {
  if (!n || typeof n != "object")
    return !1;
  let s = Object.getPrototypeOf(n);
  return s === null || s === Object.prototype || Object.getPrototypeOf(s) === null ? Object.prototype.toString.call(n) === "[object Object]" :
  !1;
}
r$1(X, "isPlainObject");

// ../node_modules/es-toolkit/dist/object/mapValues.mjs
function Re(n, s) {
  let a = {}, p = Object.keys(n);
  for (let c = 0; c < p.length; c++) {
    let u = p[c], m = n[u];
    a[u] = s(m, u, n);
  }
  return a;
}
r$1(Re, "mapValues");

// src/docs-tools/argTypes/convert/utils.ts
var ot = /^['"]|['"]$/g, Dr = /* @__PURE__ */ r$1((n) => n.replace(ot, ""), "trimQuotes"), Or = /* @__PURE__ */ r$1((n) => ot.test(n), "includes\
Quotes"), ie = /* @__PURE__ */ r$1((n) => {
  let s = Dr(n);
  return Or(n) || Number.isNaN(Number(s)) ? s : Number(s);
}, "parseLiteral");

// src/docs-tools/argTypes/convert/proptypes/convert.ts
var vr = /^\(.*\) => /, C$1 = /* @__PURE__ */ r$1((n) => {
  let { name: s, raw: a, computed: p, value: c } = n, u = {};
  switch (typeof a < "u" && (u.raw = a), s) {
    case "enum": {
      let T = p ? c : c.map((g) => ie(g.value));
      return { ...u, name: s, value: T };
    }
    case "string":
    case "number":
    case "symbol":
      return { ...u, name: s };
    case "func":
      return { ...u, name: "function" };
    case "bool":
    case "boolean":
      return { ...u, name: "boolean" };
    case "arrayOf":
    case "array":
      return { ...u, name: "array", value: c && C$1(c) };
    case "object":
      return { ...u, name: s };
    case "objectOf":
      return { ...u, name: s, value: C$1(c) };
    case "shape":
    case "exact":
      let m = Re(c, (T) => C$1(T));
      return { ...u, name: "object", value: m };
    case "union":
      return { ...u, name: "union", value: c.map((T) => C$1(T)) };
    case "instanceOf":
    case "element":
    case "elementType":
    default: {
      if (s?.indexOf("|") > 0)
        try {
          let P = s.split("|").map((b) => JSON.parse(b));
          return { ...u, name: "enum", value: P };
        } catch {
        }
      let T = c ? `${s}(${c})` : s, g = vr.test(s) ? "function" : "other";
      return { ...u, name: g, value: T };
    }
  }
}, "convert");

// src/docs-tools/argTypes/convert/typescript/convert.ts
const { UnknownArgTypesError: kr } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;
var Ar = /* @__PURE__ */ r$1((n) => {
  switch (n.type) {
    case "function":
      return { name: "function" };
    case "object":
      let s = {};
      return n.signature.properties.forEach((a) => {
        s[a.key] = M$1(a.value);
      }), {
        name: "object",
        value: s
      };
    default:
      throw new kr({ type: n, language: "Typescript" });
  }
}, "convertSig"), M$1 = /* @__PURE__ */ r$1((n) => {
  let { name: s, raw: a } = n, p = {};
  switch (typeof a < "u" && (p.raw = a), n.name) {
    case "string":
    case "number":
    case "symbol":
    case "boolean":
      return { ...p, name: s };
    case "Array":
      return { ...p, name: "array", value: n.elements.map(M$1) };
    case "signature":
      return { ...p, ...Ar(n) };
    case "union":
      let c;
      return n.elements?.every((u) => u.name === "literal") ? c = {
        ...p,
        name: "enum",
        // @ts-expect-error fix types
        value: n.elements?.map((u) => ie(u.value))
      } : c = { ...p, name: s, value: n.elements?.map(M$1) }, c;
    case "intersection":
      return { ...p, name: s, value: n.elements?.map(M$1) };
    default:
      return { ...p, name: "other", value: s };
  }
}, "convert");

// src/docs-tools/argTypes/convert/index.ts
var pe = /* @__PURE__ */ r$1((n) => {
  let { type: s, tsType: a, flowType: p } = n;
  try {
    if (s != null)
      return C$1(s);
    if (a != null)
      return M$1(a);
    if (p != null)
      return B$1(p);
  } catch (c) {
    console.error(c);
  }
  return null;
}, "convert");

// src/docs-tools/argTypes/docgen/utils/defaultValue.ts
var Rr = ["null", "undefined"];
function K$1(n) {
  return Rr.some((s) => s === n);
}
r$1(K$1, "isDefaultValueBlacklisted");

// src/docs-tools/argTypes/docgen/utils/string.ts
var st = /* @__PURE__ */ r$1((n) => {
  if (!n)
    return "";
  if (typeof n == "string")
    return n;
  throw new Error(`Description: expected string, got: ${JSON.stringify(n)}`);
}, "str");

// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts
function at(n) {
  return !!n.__docgenInfo;
}
r$1(at, "hasDocgen");
function it(n) {
  return n != null && Object.keys(n).length > 0;
}
r$1(it, "isValidDocgenSection");
function pt(n, s) {
  return at(n) ? n.__docgenInfo[s] : null;
}
r$1(pt, "getDocgenSection");
function ct(n) {
  return at(n) ? st(n.__docgenInfo.description) : "";
}
r$1(ct, "getDocgenDescription");

// ../node_modules/comment-parser/es6/primitives.js
var v$1;
(function(n) {
  n.start = "/**", n.nostart = "/***", n.delim = "*", n.end = "*/";
})(v$1 = v$1 || (v$1 = {}));

// ../node_modules/comment-parser/es6/util.js
function je(n) {
  return /^\s+$/.test(n);
}
r$1(je, "isSpace");
function lt(n) {
  let s = n.match(/\r+$/);
  return s == null ? ["", n] : [n.slice(-s[0].length), n.slice(0, -s[0].length)];
}
r$1(lt, "splitCR");
function A$1(n) {
  let s = n.match(/^\s+/);
  return s == null ? ["", n] : [n.slice(0, s[0].length), n.slice(s[0].length)];
}
r$1(A$1, "splitSpace");
function ut(n) {
  return n.split(/\n/);
}
r$1(ut, "splitLines");
function mt(n = {}) {
  return Object.assign({ tag: "", name: "", type: "", optional: !1, description: "", problems: [], source: [] }, n);
}
r$1(mt, "seedSpec");
function Fe(n = {}) {
  return Object.assign({ start: "", delimiter: "", postDelimiter: "", tag: "", postTag: "", name: "", postName: "", type: "", postType: "", description: "",
  end: "", lineEnd: "" }, n);
}
r$1(Fe, "seedTokens");

// ../node_modules/comment-parser/es6/parser/block-parser.js
var jr = /^@\S+/;
function _e({ fence: n = "```" } = {}) {
  let s = Fr(n), a = /* @__PURE__ */ r$1((p, c) => s(p) ? !c : c, "toggleFence");
  return /* @__PURE__ */ r$1(function(c) {
    let u = [[]], m = !1;
    for (let T of c)
      jr.test(T.tokens.description) && !m ? u.push([T]) : u[u.length - 1].push(T), m = a(T.tokens.description, m);
    return u;
  }, "parseBlock");
}
r$1(_e, "getParser");
function Fr(n) {
  return typeof n == "string" ? (s) => s.split(n).length % 2 === 0 : n;
}
r$1(Fr, "getFencer");

// ../node_modules/comment-parser/es6/parser/source-parser.js
function Ve({ startLine: n = 0, markers: s = v$1 } = {}) {
  let a = null, p = n;
  return /* @__PURE__ */ r$1(function(u) {
    let m = u, T = Fe();
    if ([T.lineEnd, m] = lt(m), [T.start, m] = A$1(m), a === null && m.startsWith(s.start) && !m.startsWith(s.nostart) && (a = [], T.delimiter =
    m.slice(0, s.start.length), m = m.slice(s.start.length), [T.postDelimiter, m] = A$1(m)), a === null)
      return p++, null;
    let g = m.trimRight().endsWith(s.end);
    if (T.delimiter === "" && m.startsWith(s.delim) && !m.startsWith(s.end) && (T.delimiter = s.delim, m = m.slice(s.delim.length), [T.postDelimiter,
    m] = A$1(m)), g) {
      let P = m.trimRight();
      T.end = m.slice(P.length - s.end.length), m = P.slice(0, -s.end.length);
    }
    if (T.description = m, a.push({ number: p, source: u, tokens: T }), p++, g) {
      let P = a.slice();
      return a = null, P;
    }
    return null;
  }, "parseSource");
}
r$1(Ve, "getParser");

// ../node_modules/comment-parser/es6/parser/spec-parser.js
function Le({ tokenizers: n }) {
  return /* @__PURE__ */ r$1(function(a) {
    var p;
    let c = mt({ source: a });
    for (let u of n)
      if (c = u(c), !((p = c.problems[c.problems.length - 1]) === null || p === void 0) && p.critical)
        break;
    return c;
  }, "parseSpec");
}
r$1(Le, "getParser");

// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js
function ce() {
  return (n) => {
    let { tokens: s } = n.source[0], a = s.description.match(/\s*(@(\S+))(\s*)/);
    return a === null ? (n.problems.push({
      code: "spec:tag:prefix",
      message: 'tag should start with "@" symbol',
      line: n.source[0].number,
      critical: !0
    }), n) : (s.tag = a[1], s.postTag = a[3], s.description = s.description.slice(a[0].length), n.tag = a[2], n);
  };
}
r$1(ce, "tagTokenizer");

// ../node_modules/comment-parser/es6/parser/tokenizers/type.js
function le(n = "compact") {
  let s = Vr(n);
  return (a) => {
    let p = 0, c = [];
    for (let [T, { tokens: g }] of a.source.entries()) {
      let P = "";
      if (T === 0 && g.description[0] !== "{")
        return a;
      for (let b of g.description)
        if (b === "{" && p++, b === "}" && p--, P += b, p === 0)
          break;
      if (c.push([g, P]), p === 0)
        break;
    }
    if (p !== 0)
      return a.problems.push({
        code: "spec:type:unpaired-curlies",
        message: "unpaired curlies",
        line: a.source[0].number,
        critical: !0
      }), a;
    let u = [], m = c[0][0].postDelimiter.length;
    for (let [T, [g, P]] of c.entries())
      g.type = P, T > 0 && (g.type = g.postDelimiter.slice(m) + P, g.postDelimiter = g.postDelimiter.slice(0, m)), [g.postType, g.description] =
      A$1(g.description.slice(P.length)), u.push(g.type);
    return u[0] = u[0].slice(1), u[u.length - 1] = u[u.length - 1].slice(0, -1), a.type = s(u), a;
  };
}
r$1(le, "typeTokenizer");
var _r = /* @__PURE__ */ r$1((n) => n.trim(), "trim");
function Vr(n) {
  return n === "compact" ? (s) => s.map(_r).join("") : n === "preserve" ? (s) => s.join(`
`) : n;
}
r$1(Vr, "getJoiner");

// ../node_modules/comment-parser/es6/parser/tokenizers/name.js
var Lr = /* @__PURE__ */ r$1((n) => n && n.startsWith('"') && n.endsWith('"'), "isQuoted");
function ue() {
  let n = /* @__PURE__ */ r$1((s, { tokens: a }, p) => a.type === "" ? s : p, "typeEnd");
  return (s) => {
    let { tokens: a } = s.source[s.source.reduce(n, 0)], p = a.description.trimLeft(), c = p.split('"');
    if (c.length > 1 && c[0] === "" && c.length % 2 === 1)
      return s.name = c[1], a.name = `"${c[1]}"`, [a.postName, a.description] = A$1(p.slice(a.name.length)), s;
    let u = 0, m = "", T = !1, g;
    for (let b of p) {
      if (u === 0 && je(b))
        break;
      b === "[" && u++, b === "]" && u--, m += b;
    }
    if (u !== 0)
      return s.problems.push({
        code: "spec:name:unpaired-brackets",
        message: "unpaired brackets",
        line: s.source[0].number,
        critical: !0
      }), s;
    let P = m;
    if (m[0] === "[" && m[m.length - 1] === "]") {
      T = !0, m = m.slice(1, -1);
      let b = m.split("=");
      if (m = b[0].trim(), b[1] !== void 0 && (g = b.slice(1).join("=").trim()), m === "")
        return s.problems.push({
          code: "spec:name:empty-name",
          message: "empty name",
          line: s.source[0].number,
          critical: !0
        }), s;
      if (g === "")
        return s.problems.push({
          code: "spec:name:empty-default",
          message: "empty default value",
          line: s.source[0].number,
          critical: !0
        }), s;
      if (!Lr(g) && /=(?!>)/.test(g))
        return s.problems.push({
          code: "spec:name:invalid-default",
          message: "invalid default value syntax",
          line: s.source[0].number,
          critical: !0
        }), s;
    }
    return s.optional = T, s.name = m, a.name = P, g !== void 0 && (s.default = g), [a.postName, a.description] = A$1(p.slice(a.name.length)),
    s;
  };
}
r$1(ue, "nameTokenizer");

// ../node_modules/comment-parser/es6/parser/tokenizers/description.js
function me(n = "compact", s = v$1) {
  let a = Ue(n);
  return (p) => (p.description = a(p.source, s), p);
}
r$1(me, "descriptionTokenizer");
function Ue(n) {
  return n === "compact" ? Ur : n === "preserve" ? Mr : n;
}
r$1(Ue, "getJoiner");
function Ur(n, s = v$1) {
  return n.map(({ tokens: { description: a } }) => a.trim()).filter((a) => a !== "").join(" ");
}
r$1(Ur, "compactJoiner");
var Br = /* @__PURE__ */ r$1((n, { tokens: s }, a) => s.type === "" ? n : a, "lineNo"), Cr = /* @__PURE__ */ r$1(({ tokens: n }) => (n.delimiter ===
"" ? n.start : n.postDelimiter.slice(1)) + n.description, "getDescription");
function Mr(n, s = v$1) {
  if (n.length === 0)
    return "";
  n[0].tokens.description === "" && n[0].tokens.delimiter === s.start && (n = n.slice(1));
  let a = n[n.length - 1];
  return a !== void 0 && a.tokens.description === "" && a.tokens.end.endsWith(s.end) && (n = n.slice(0, -1)), n = n.slice(n.reduce(Br, 0)), n.
  map(Cr).join(`
`);
}
r$1(Mr, "preserveJoiner");

// ../node_modules/comment-parser/es6/parser/index.js
function Be({ startLine: n = 0, fence: s = "```", spacing: a = "compact", markers: p = v$1, tokenizers: c = [
  ce(),
  le(a),
  ue(),
  me(a)
] } = {}) {
  if (n < 0 || n % 1 > 0)
    throw new Error("Invalid startLine");
  let u = Ve({ startLine: n, markers: p }), m = _e({ fence: s }), T = Le({ tokenizers: c }), g = Ue(a);
  return function(P) {
    let b = [];
    for (let de of ut(P)) {
      let q = u(de);
      if (q === null)
        continue;
      let S = m(q), z = S.slice(1).map(T);
      b.push({
        description: g(S[0], p),
        tags: z,
        source: q,
        problems: z.reduce((Te, ge) => Te.concat(ge.problems), [])
      });
    }
    return b;
  };
}
r$1(Be, "getParser");

// ../node_modules/comment-parser/es6/stringifier/index.js
function Kr(n) {
  return n.start + n.delimiter + n.postDelimiter + n.tag + n.postTag + n.type + n.postType + n.name + n.postName + n.description + n.end + n.
  lineEnd;
}
r$1(Kr, "join");
function Ce() {
  return (n) => n.source.map(({ tokens: s }) => Kr(s)).join(`
`);
}
r$1(Ce, "getStringifier");

// ../node_modules/comment-parser/es6/index.js
function ft(n, s = {}) {
  return Be(s)(n);
}
r$1(ft, "parse");

// src/docs-tools/argTypes/jsdocParser.ts
var $ = Pr(dt());
function qr(n) {
  return n != null && n.includes("@");
}
r$1(qr, "containsJsDoc");
function Yr(n) {
  let p = `/**
` + (n ?? "").split(`
`).map((u) => ` * ${u}`).join(`
`) + `
*/`, c = ft(p, {
    spacing: "preserve"
  });
  if (!c || c.length === 0)
    throw new Error("Cannot parse JSDoc tags.");
  return c[0];
}
r$1(Yr, "parse");
var Wr = {
  tags: ["param", "arg", "argument", "returns", "ignore", "deprecated"]
}, Tt = /* @__PURE__ */ r$1((n, s = Wr) => {
  if (!qr(n))
    return {
      includesJsDoc: !1,
      ignore: !1
    };
  let a = Yr(n), p = Gr(a, s.tags);
  return p.ignore ? {
    includesJsDoc: !0,
    ignore: !0
  } : {
    includesJsDoc: !0,
    ignore: !1,
    // Always use the parsed description to ensure JSDoc is removed from the description.
    description: a.description.trim(),
    extractedTags: p
  };
}, "parseJsDoc");
function Gr(n, s) {
  let a = {
    params: null,
    deprecated: null,
    returns: null,
    ignore: !1
  };
  for (let p of n.tags)
    if (!(s !== void 0 && !s.includes(p.tag)))
      if (p.tag === "ignore") {
        a.ignore = !0;
        break;
      } else
        switch (p.tag) {
          // arg & argument are aliases for param.
          case "param":
          case "arg":
          case "argument": {
            let c = zr(p);
            c != null && (a.params == null && (a.params = []), a.params.push(c));
            break;
          }
          case "deprecated": {
            let c = Hr(p);
            c != null && (a.deprecated = c);
            break;
          }
          case "returns": {
            let c = Qr(p);
            c != null && (a.returns = c);
            break;
          }
        }
  return a;
}
r$1(Gr, "extractJsDocTags");
function Xr(n) {
  return n.replace(/[\.-]$/, "");
}
r$1(Xr, "normaliseParamName");
function zr(n) {
  if (!n.name || n.name === "-")
    return null;
  let s = ht(n.type);
  return {
    name: n.name,
    type: s,
    description: xt(n.description),
    getPrettyName: /* @__PURE__ */ r$1(() => Xr(n.name), "getPrettyName"),
    getTypeName: /* @__PURE__ */ r$1(() => s ? Jt(s) : null, "getTypeName")
  };
}
r$1(zr, "extractParam");
function Hr(n) {
  return n.name ? gt(n.name, n.description) : null;
}
r$1(Hr, "extractDeprecated");
function gt(n, s) {
  let a = n === "" ? s : `${n} ${s}`;
  return xt(a);
}
r$1(gt, "joinNameAndDescription");
function xt(n) {
  let s = n.replace(/^- /g, "").trim();
  return s === "" ? null : s;
}
r$1(xt, "normaliseDescription");
function Qr(n) {
  let s = ht(n.type);
  return s ? {
    type: s,
    description: gt(n.name, n.description),
    getTypeName: /* @__PURE__ */ r$1(() => Jt(s), "getTypeName")
  } : null;
}
r$1(Qr, "extractReturns");
var _ = (0, $.stringifyRules)(), Zr = _.JsdocTypeObject;
_.JsdocTypeAny = () => "any";
_.JsdocTypeObject = (n, s) => `(${Zr(n, s)})`;
_.JsdocTypeOptional = (n, s) => s(n.element);
_.JsdocTypeNullable = (n, s) => s(n.element);
_.JsdocTypeNotNullable = (n, s) => s(n.element);
_.JsdocTypeUnion = (n, s) => n.elements.map(s).join("|");
function ht(n) {
  try {
    return (0, $.parse)(n, "typescript");
  } catch {
    return null;
  }
}
r$1(ht, "extractType");
function Jt(n) {
  return (0, $.transform)(_, n);
}
r$1(Jt, "extractTypeName");
function Ke(n) {
  return n.length > 90;
}
r$1(Ke, "isTooLongForTypeSummary");
function wt(n) {
  return n.length > 50;
}
r$1(wt, "isTooLongForDefaultValueSummary");
function w$1(n, s) {
  return n === s ? { summary: n } : { summary: n, detail: s };
}
r$1(w$1, "createSummaryValue");

// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts
function Pt(n, s) {
  if (n != null) {
    let { value: a } = n;
    if (!K$1(a))
      return wt(a) ? w$1(s?.name, a) : w$1(a);
  }
  return null;
}
r$1(Pt, "createDefaultValue");

// src/docs-tools/argTypes/docgen/flow/createType.ts
function bt({ name: n, value: s, elements: a, raw: p }) {
  return s ?? (a != null ? a.map(bt).join(" | ") : p ?? n);
}
r$1(bt, "generateUnionElement");
function en({ name: n, raw: s, elements: a }) {
  return a != null ? w$1(a.map(bt).join(" | ")) : s != null ? w$1(s.replace(/^\|\s*/, "")) : w$1(n);
}
r$1(en, "generateUnion");
function tn({ type: n, raw: s }) {
  return s != null ? w$1(s) : w$1(n);
}
r$1(tn, "generateFuncSignature");
function rn({ type: n, raw: s }) {
  return s != null ? Ke(s) ? w$1(n, s) : w$1(s) : w$1(n);
}
r$1(rn, "generateObjectSignature");
function nn(n) {
  let { type: s } = n;
  return s === "object" ? rn(n) : tn(n);
}
r$1(nn, "generateSignature");
function on$1({ name: n, raw: s }) {
  return s != null ? Ke(s) ? w$1(n, s) : w$1(s) : w$1(n);
}
r$1(on$1, "generateDefault");
function St(n) {
  if (n == null)
    return null;
  switch (n.name) {
    case "union":
      return en(n);
    case "signature":
      return nn(n);
    default:
      return on$1(n);
  }
}
r$1(St, "createType");

// src/docs-tools/argTypes/docgen/flow/createPropDef.ts
var Et = /* @__PURE__ */ r$1((n, s) => {
  let { flowType: a, description: p, required: c, defaultValue: u } = s;
  return {
    name: n,
    type: St(a),
    required: c,
    description: p,
    defaultValue: Pt(u ?? null, a ?? null)
  };
}, "createFlowPropDef");

// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts
function Nt({ defaultValue: n }) {
  if (n != null) {
    let { value: s } = n;
    if (!K$1(s))
      return w$1(s);
  }
  return null;
}
r$1(Nt, "createDefaultValue");

// src/docs-tools/argTypes/docgen/typeScript/createType.ts
function Dt({ tsType: n, required: s }) {
  if (n == null)
    return null;
  let a = n.name;
  return s || (a = a.replace(" | undefined", "")), w$1(
    ["Array", "Record", "signature"].includes(n.name) ? n.raw : a
  );
}
r$1(Dt, "createType");

// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts
var Ot = /* @__PURE__ */ r$1((n, s) => {
  let { description: a, required: p } = s;
  return {
    name: n,
    type: Dt(s),
    required: p,
    description: a,
    defaultValue: Nt(s)
  };
}, "createTsPropDef");

// src/docs-tools/argTypes/docgen/createPropDef.ts
function sn(n) {
  return n != null ? w$1(n.name) : null;
}
r$1(sn, "createType");
function an(n) {
  let { computed: s, func: a } = n;
  return typeof s > "u" && typeof a > "u";
}
r$1(an, "isReactDocgenTypescript");
function pn(n) {
  return n ? n.name === "string" ? !0 : n.name === "enum" ? Array.isArray(n.value) && n.value.every(
    ({ value: s }) => typeof s == "string" && s[0] === '"' && s[s.length - 1] === '"'
  ) : !1 : !1;
}
r$1(pn, "isStringValued");
function cn(n, s) {
  if (n != null) {
    let { value: a } = n;
    if (!K$1(a))
      return an(n) && pn(s) ? w$1(JSON.stringify(a)) : w$1(a);
  }
  return null;
}
r$1(cn, "createDefaultValue");
function vt(n, s, a) {
  let { description: p, required: c, defaultValue: u } = a;
  return {
    name: n,
    type: sn(s),
    required: c,
    description: p,
    defaultValue: cn(u, s)
  };
}
r$1(vt, "createBasicPropDef");
function ye(n, s) {
  if (s?.includesJsDoc) {
    let { description: a, extractedTags: p } = s;
    a != null && (n.description = s.description);
    let c = {
      ...p,
      params: p?.params?.map(
        (u) => ({
          name: u.getPrettyName(),
          description: u.description
        })
      )
    };
    Object.values(c).filter(Boolean).length > 0 && (n.jsDocTags = c);
  }
  return n;
}
r$1(ye, "applyJsDocResult");
var ln = /* @__PURE__ */ r$1((n, s, a) => {
  let p = vt(n, s.type, s);
  return p.sbType = pe(s), ye(p, a);
}, "javaScriptFactory"), un = /* @__PURE__ */ r$1((n, s, a) => {
  let p = Ot(n, s);
  return p.sbType = pe(s), ye(p, a);
}, "tsFactory"), mn = /* @__PURE__ */ r$1((n, s, a) => {
  let p = Et(n, s);
  return p.sbType = pe(s), ye(p, a);
}, "flowFactory"), fn = /* @__PURE__ */ r$1((n, s, a) => {
  let p = vt(n, { name: "unknown" }, s);
  return ye(p, a);
}, "unknownFactory"), $e = /* @__PURE__ */ r$1((n) => {
  switch (n) {
    case "JavaScript":
      return ln;
    case "TypeScript":
      return un;
    case "Flow":
      return mn;
    default:
      return fn;
  }
}, "getPropDefFactory");

// src/docs-tools/argTypes/docgen/extractDocgenProps.ts
var kt = /* @__PURE__ */ r$1((n) => n.type != null ? "JavaScript" : n.flowType != null ? "Flow" : n.tsType != null ? "TypeScript" : "Unknown",
"getTypeSystem"), yn = /* @__PURE__ */ r$1((n) => {
  let s = kt(n[0]), a = $e(s);
  return n.map((p) => {
    let c = p;
    return p.type?.elements && (c = {
      ...p,
      type: {
        ...p.type,
        value: p.type.elements
      }
    }), At(c.name, c, s, a);
  });
}, "extractComponentSectionArray"), dn = /* @__PURE__ */ r$1((n) => {
  let s = Object.keys(n), a = kt(n[s[0]]), p = $e(a);
  return s.map((c) => {
    let u = n[c];
    return u != null ? At(c, u, a, p) : null;
  }).filter(Boolean);
}, "extractComponentSectionObject"), aa = /* @__PURE__ */ r$1((n, s) => {
  let a = pt(n, s);
  return it(a) ? Array.isArray(a) ? yn(a) : dn(a) : [];
}, "extractComponentProps");
function At(n, s, a, p) {
  let c = Tt(s.description);
  return c.includesJsDoc && c.ignore ? null : {
    propDef: p(n, s, c),
    jsDocTags: c.extractedTags,
    docgenInfo: s,
    typeSystem: a
  };
}
r$1(At, "extractProp");
function ia(n) {
  return n != null ? ct(n) : "";
}
r$1(ia, "extractComponentDescription");

// src/preview-api/modules/store/parameters.ts
var qe = /* @__PURE__ */ r$1((...n) => {
  let s = {}, a = n.filter(Boolean), p = a.reduce((c, u) => (Object.entries(u).forEach(([m, T]) => {
    let g = c[m];
    Array.isArray(T) || typeof g > "u" ? c[m] = T : X(T) && X(g) ? s[m] = !0 : typeof T < "u" && (c[m] = T);
  }), c), {});
  return Object.keys(s).forEach((c) => {
    let u = a.filter(Boolean).map((m) => m[c]).filter((m) => typeof m < "u");
    u.every((m) => X(m)) ? p[c] = qe(...u) : p[c] = u[u.length - 1];
  }), p;
}, "combineParameters");

// src/docs-tools/argTypes/enhanceArgTypes.ts
var ya = /* @__PURE__ */ r$1((n) => {
  let {
    component: s,
    argTypes: a,
    parameters: { docs: p = {} }
  } = n, { extractArgTypes: c } = p;
  if (!c || !s)
    return a;
  let u = c(s);
  return u ? qe(u, a) : a;
}, "enhanceArgTypes");

/**
* @vue/shared v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function genCacheKey(source, options) {
  return source + JSON.stringify(
    options,
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

/**
* @vue/reactivity v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= ~64;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= ~2;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= ~1;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= ~16;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  const dep = computed2.dep;
  computed2.flags |= 2;
  if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
    computed2.flags &= ~2;
    return;
  }
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= ~2;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= ~4;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const e = new ReactiveEffect(fn);
  if (options) {
    extend(e, options);
  }
  try {
    e.run();
  } catch (err) {
    e.stop();
    throw err;
  }
  const runner = e.run.bind(e);
  runner.effect = e;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0);
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function triggerRef(ref2) {
  if (ref2.dep) {
    {
      ref2.dep.trigger();
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return isFunction(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this["__v_isRef"] = true;
    this._value = void 0;
    const dep = this.dep = new Dep();
    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._value = this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (isObject(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function getCurrentWatcher() {
  return activeWatcher;
}
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
          oldValue = newValue;
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}

/**
* @vue/runtime-core v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack$1 = [];
function pushWarningContext(vnode) {
  stack$1.push(vnode);
}
function popWarningContext() {
  stack$1.pop();
}
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack$1[stack$1.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  return;
}
const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER",
  "COMPONENT_UPDATE": 15,
  "15": "COMPONENT_UPDATE",
  "APP_UNMOUNT_CLEANUP": 16,
  "16": "APP_UNMOUNT_CLEANUP"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush",
  [15]: "component update",
  [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= ~1;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= ~1;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= ~1;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let devtools$1;
let buffer = [];
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          if (parentComponent && parentComponent.isCE) {
            parentComponent.ce._teleportTarget = container2;
          }
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        queuePostRenderEffect(mountToTarget, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const disabled = isTeleportDisabled(vnode.props);
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetStart = targetNode;
        vnode.targetAnchor = targetNode && nextSibling(targetNode);
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getInnerChild$1(oldChild);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function useId() {
  const i = getCurrentInstance();
  if (i) {
    return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
  }
  return "";
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function useTemplateRef(key) {
  const i = getCurrentInstance();
  const r = shallowRef(null);
  if (i) {
    const refs = i.refs === EMPTY_OBJ ? i.refs = {} : i.refs;
    {
      Object.defineProperty(refs, key, {
        enumerable: true,
        get: () => r.value,
        set: (val) => r.value = val
      });
    }
  }
  const ret = r;
  return ret;
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasLoggedMismatchError = false;
const logMismatchError = () => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
};
const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
const getContainerType = (container) => {
  if (container.nodeType !== 1) return void 0;
  if (isSVGContainer(container)) return "svg";
  if (isMathMLContainer(container)) return "mathml";
  return void 0;
};
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp,
      createText,
      nextSibling,
      parentNode,
      remove: remove2,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref: ref3, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            logMismatchError();
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else ;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if (forcePatch || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(
          null,
          // no need check parentSuspense in hydration
          transition
        ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        while (next) {
          if (!isMismatchAllowed(
            el,
            1
            /* CHILDREN */
          )) {
            logMismatchError();
          }
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        let clientText = vnode.children;
        if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
          clientText = clientText.slice(1);
        }
        if (el.textContent !== clientText) {
          if (!isMismatchAllowed(
            el,
            0
            /* TEXT */
          )) {
            logMismatchError();
          }
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if (forcePatch || !optimized || patchFlag & (16 | 32)) {
          const isCustomElement = el.tagName.includes("-");
          for (const key in props) {
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
            key[0] === "." || isCustomElement) {
              patchProp(el, key, null, props[key], void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp(
            el,
            "onClick",
            null,
            props.onClick,
            void 0,
            parentComponent
          );
        } else if (patchFlag & 4 && isReactive(props.style)) {
          for (const key in props.style) props.style[key];
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      const isText = vnode.type === Text;
      if (node) {
        if (isText && !optimized) {
          if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {
            insert(
              createText(
                node.data.slice(vnode.children.length)
              ),
              container,
              nextSibling(node)
            );
            node.data = vnode.children;
          }
        }
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (isText && !vnode.children) {
        insert(vnode.el = createText(""), container);
      } else {
        if (!isMismatchAllowed(
          container,
          1
          /* CHILDREN */
        )) {
          logMismatchError();
        }
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      logMismatchError();
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    if (!isMismatchAllowed(
      node.parentElement,
      1
      /* CHILDREN */
    )) {
      logMismatchError();
    }
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open) match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = (node) => {
    return node.nodeType === 1 && node.tagName === "TEMPLATE";
  };
  return [hydrate, hydrateNode];
}
const allowMismatchAttr = "data-allow-mismatch";
const MismatchTypeString = {
  [
    0
    /* TEXT */
  ]: "text",
  [
    1
    /* CHILDREN */
  ]: "children",
  [
    2
    /* CLASS */
  ]: "class",
  [
    3
    /* STYLE */
  ]: "style",
  [
    4
    /* ATTRIBUTE */
  ]: "attribute"
};
function isMismatchAllowed(el, allowedType) {
  if (allowedType === 0 || allowedType === 1) {
    while (el && !el.hasAttribute(allowMismatchAttr)) {
      el = el.parentElement;
    }
  }
  const allowedAttr = el && el.getAttribute(allowMismatchAttr);
  if (allowedAttr == null) {
    return false;
  } else if (allowedAttr === "") {
    return true;
  } else {
    const list = allowedAttr.split(",");
    if (allowedType === 0 && list.includes("children")) {
      return true;
    }
    return allowedAttr.split(",").includes(MismatchTypeString[allowedType]);
  }
}
const requestIdleCallback = getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
const cancelIdleCallback = getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const hydrateOnIdle = (timeout = 1e4) => (hydrate) => {
  const id = requestIdleCallback(hydrate, { timeout });
  return () => cancelIdleCallback(id);
};
function elementIsVisibleInViewport(el) {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
}
const hydrateOnVisible = (opts) => (hydrate, forEach) => {
  const ob = new IntersectionObserver((entries) => {
    for (const e of entries) {
      if (!e.isIntersecting) continue;
      ob.disconnect();
      hydrate();
      break;
    }
  }, opts);
  forEach((el) => {
    if (!(el instanceof Element)) return;
    if (elementIsVisibleInViewport(el)) {
      hydrate();
      ob.disconnect();
      return false;
    }
    ob.observe(el);
  });
  return () => ob.disconnect();
};
const hydrateOnMediaQuery = (query) => (hydrate) => {
  if (query) {
    const mql = matchMedia(query);
    if (mql.matches) {
      hydrate();
    } else {
      mql.addEventListener("change", hydrate, { once: true });
      return () => mql.removeEventListener("change", hydrate);
    }
  }
};
const hydrateOnInteraction = (interactions = []) => (hydrate, forEach) => {
  if (isString(interactions)) interactions = [interactions];
  let hasHydrated = false;
  const doHydrate = (e) => {
    if (!hasHydrated) {
      hasHydrated = true;
      teardown();
      hydrate();
      e.target.dispatchEvent(new e.constructor(e.type, e));
    }
  };
  const teardown = () => {
    forEach((el) => {
      for (const i of interactions) {
        el.removeEventListener(i, doHydrate);
      }
    });
  };
  forEach((el) => {
    for (const i of interactions) {
      el.addEventListener(i, doHydrate, { once: true });
    }
  });
  return teardown;
};
function forEachElement(node, cb) {
  if (isComment(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment(next)) {
        if (next.data === "]") {
          if (--depth === 0) break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return /* @__PURE__ */ defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate) {
      const doHydrate = hydrateStrategy ? () => {
        const teardown = hydrateStrategy(
          hydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
      } : hydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref22, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref22;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && !filter(name)) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (cached && (!current || !isSameVNodeType(cached, current))) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return current = null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      if (vnode.type === Comment) {
        current = null;
        return vnode;
      }
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        vnode.shapeFlag &= ~256;
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray(pattern)) {
    return pattern.some((p) => matches(p, name));
  } else if (isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp(pattern)) {
    pattern.lastIndex = 0;
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  const sourceIsArray = isArray(source);
  if (sourceIsArray || isString(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? toReactive(source[i]) : source[i],
        i,
        void 0,
        cached && cached[i]
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i) ,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i) 
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has = key[0] !== "_" && !isGloballyAllowed(key);
    return has;
  }
});
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function defineOptions(options) {
}
function defineSlots() {
  return null;
}
function defineModel() {
}
function withDefaults(props, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if (isArray(opt) || isFunction(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else ;
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if (isArray(a) && isArray(b)) return a.concat(b);
  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject(data)) ; else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ; else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray$1,
  created: mergeAsArray$1,
  beforeMount: mergeAsArray$1,
  mounted: mergeAsArray$1,
  beforeUpdate: mergeAsArray$1,
  updated: mergeAsArray$1,
  beforeDestroy: mergeAsArray$1,
  beforeUnmount: mergeAsArray$1,
  destroyed: mergeAsArray$1,
  unmounted: mergeAsArray$1,
  activated: mergeAsArray$1,
  deactivated: mergeAsArray$1,
  errorCaptured: mergeAsArray$1,
  serverPrefetch: mergeAsArray$1,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray$1(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray$1(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ; else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) ; else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || key !== "_") {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode && type.__asyncHydrate) {
            type.__asyncHydrate(
              el,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= ~32;
    job.flags &= ~4;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "post" }
  );
}
function watchSyncEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "sync" }
  );
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function useModel(props, name, options = EMPTY_OBJ) {
  const i = getCurrentInstance();
  const camelizedName = camelize(name);
  const hyphenatedName = hyphenate(name);
  const modifiers = getModelModifiers(props, camelizedName);
  const res = customRef((track2, trigger2) => {
    let localValue;
    let prevSetValue = EMPTY_OBJ;
    let prevEmittedValue;
    watchSyncEffect(() => {
      const propValue = props[camelizedName];
      if (hasChanged(localValue, propValue)) {
        localValue = propValue;
        trigger2();
      }
    });
    return {
      get() {
        track2();
        return options.get ? options.get(localValue) : localValue;
      },
      set(value) {
        const emittedValue = options.set ? options.set(value) : value;
        if (!hasChanged(emittedValue, localValue) && !(prevSetValue !== EMPTY_OBJ && hasChanged(value, prevSetValue))) {
          return;
        }
        const rawProps = i.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
          localValue = value;
          trigger2();
        }
        i.emit(`update:${name}`, emittedValue);
        if (hasChanged(value, emittedValue) && hasChanged(value, prevSetValue) && !hasChanged(emittedValue, prevEmittedValue)) {
          trigger2();
        }
        prevSetValue = value;
        prevEmittedValue = emittedValue;
      }
    };
  });
  res[Symbol.iterator] = () => {
    let i2 = 0;
    return {
      next() {
        if (i2 < 2) {
          return { value: i2++ ? modifiers || EMPTY_OBJ : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove: remove2 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) === container2) {
            anchor = next(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render();
  ret.memo = memo.slice();
  ret.cacheIndex = index;
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (hasChanged(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version = "3.5.12";
const warn = NOOP;
const ErrorTypeStrings = ErrorTypeStrings$1;
const devtools = devtools$1 ;
const setDevtoolsHook = setDevtoolsHook$1 ;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode,
  getComponentPublicInstance,
  ensureValidVNode,
  pushWarningContext,
  popWarningContext
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;

/**
* @vue/runtime-dom v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION$1 = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      addTransitionClass(el, leaveActiveClass);
      forceReflow();
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION$1}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION$1}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION$1) {
    if (transitionTimeout > 0) {
      type = TRANSITION$1;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
    propCount = type ? type === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION$1 && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION$1}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
const CSS_VAR_TEXT = Symbol("");
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    if (instance.ce) {
      setVarsOnNode(instance.ce, vars);
    } else {
      setVarsOnVNode(instance.subTree, vars);
    }
    updateTeleports(vars);
  };
  onBeforeMount(() => {
    watchPostEffect(setVars);
  });
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const REMOVAL = {};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, extraOptions, _createApp) {
  const Comp = defineComponent(options, extraOptions);
  if (isPlainObject(Comp)) extend(Comp, extraOptions);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, _createApp);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
  return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, _createApp = createApp) {
    super();
    this._def = _def;
    this._props = _props;
    this._createApp = _createApp;
    this._isVueCE = true;
    this._instance = null;
    this._app = null;
    this._nonce = this._def.nonce;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._styleChildren = /* @__PURE__ */ new WeakSet();
    this._ob = null;
    if (this.shadowRoot && _createApp !== createApp) {
      this._root = this.shadowRoot;
    } else {
      if (_def.shadowRoot !== false) {
        this.attachShadow({ mode: "open" });
        this._root = this.shadowRoot;
      } else {
        this._root = this;
      }
    }
    if (!this._def.__asyncLoader) {
      this._resolveProps(this._def);
    }
  }
  connectedCallback() {
    if (!this.isConnected) return;
    if (!this.shadowRoot) {
      this._parseSlots();
    }
    this._connected = true;
    let parent = this;
    while (parent = parent && (parent.parentNode || parent.host)) {
      if (parent instanceof VueElement) {
        this._parent = parent;
        break;
      }
    }
    if (!this._instance) {
      if (this._resolved) {
        this._setParent();
        this._update();
      } else {
        if (parent && parent._pendingResolve) {
          this._pendingResolve = parent._pendingResolve.then(() => {
            this._pendingResolve = void 0;
            this._resolveDef();
          });
        } else {
          this._resolveDef();
        }
      }
    }
  }
  _setParent(parent = this._parent) {
    if (parent) {
      this._instance.parent = parent._instance;
      this._instance.provides = parent._instance.provides;
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        this._app && this._app.unmount();
        if (this._instance) this._instance.ce = void 0;
        this._app = this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve) {
      return;
    }
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve = (def, isAsync = false) => {
      this._resolved = true;
      this._pendingResolve = void 0;
      const { props, styles } = def;
      let numberProps;
      if (props && !isArray(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def);
      }
      if (this.shadowRoot) {
        this._applyStyles(styles);
      }
      this._mount(def);
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      this._pendingResolve = asyncDef().then(
        (def) => resolve(this._def = def, true)
      );
    } else {
      resolve(this._def);
    }
  }
  _mount(def) {
    this._app = this._createApp(def);
    if (def.configureApp) {
      def.configureApp(this._app);
    }
    this._app._ceVNode = this._createVNode();
    this._app.mount(this._root);
    const exposed = this._instance && this._instance.exposed;
    if (!exposed) return;
    for (const key in exposed) {
      if (!hasOwn(this, key)) {
        Object.defineProperty(this, key, {
          // unwrap ref to be consistent with public instance behavior
          get: () => unref(exposed[key])
        });
      }
    }
  }
  _resolveProps(def) {
    const { props } = def;
    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key]);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val, true, true);
        }
      });
    }
  }
  _setAttr(key) {
    if (key.startsWith("data-v-")) return;
    const has = this.hasAttribute(key);
    let value = has ? this.getAttribute(key) : REMOVAL;
    const camelKey = camelize(key);
    if (has && this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false, true);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
    if (val !== this._props[key]) {
      if (val === REMOVAL) {
        delete this._props[key];
      } else {
        this._props[key] = val;
        if (key === "key" && this._app) {
          this._app._ceVNode.key = val;
        }
      }
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render$1(this._createVNode(), this._root);
  }
  _createVNode() {
    const baseProps = {};
    if (!this.shadowRoot) {
      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
    }
    const vnode = createVNode(this._def, extend(baseProps, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.ce = this;
        instance.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(
              event,
              isPlainObject(args[0]) ? extend({ detail: args }, args[0]) : { detail: args }
            )
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        this._setParent();
      };
    }
    return vnode;
  }
  _applyStyles(styles, owner) {
    if (!styles) return;
    if (owner) {
      if (owner === this._def || this._styleChildren.has(owner)) {
        return;
      }
      this._styleChildren.add(owner);
    }
    const nonce = this._nonce;
    for (let i = styles.length - 1; i >= 0; i--) {
      const s = document.createElement("style");
      if (nonce) s.setAttribute("nonce", nonce);
      s.textContent = styles[i];
      this.shadowRoot.prepend(s);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const slots = this._slots = {};
    let n;
    while (n = this.firstChild) {
      const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
      (slots[slotName] || (slots[slotName] = [])).push(n);
      this.removeChild(n);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const outlets = (this._teleportTarget || this).querySelectorAll("slot");
    const scopeId = this._instance.type.__scopeId;
    for (let i = 0; i < outlets.length; i++) {
      const o = outlets[i];
      const slotName = o.getAttribute("name") || "default";
      const content = this._slots[slotName];
      const parent = o.parentNode;
      if (content) {
        for (const n of content) {
          if (scopeId && n.nodeType === 1) {
            const id = scopeId + "-s";
            const walker = document.createTreeWalker(n, 1);
            n.setAttribute(id, "");
            let child;
            while (child = walker.nextNode()) {
              child.setAttribute(id, "");
            }
          }
          parent.insertBefore(n, o);
        }
      } else {
        while (o.firstChild) parent.insertBefore(o.firstChild, o);
      }
      parent.removeChild(o);
    }
  }
  /**
   * @internal
   */
  _injectChildStyle(comp) {
    this._applyStyles(comp.styles, comp);
  }
  /**
   * @internal
   */
  _removeChildStyle(comp) {
  }
}
function useHost(caller) {
  const instance = getCurrentInstance();
  const el = instance && instance.ce;
  if (el) {
    return el;
  }
  return null;
}
function useShadowRoot() {
  const el = useHost();
  return el && el.shadowRoot;
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      return createVNode(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  let checked;
  if (isArray(value)) {
    checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    checked = value.has(vnode.props.value);
  } else {
    if (value === oldValue) return;
    checked = looseEqual(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray(value);
  if (isMultiple && !isArrayValue && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = looseIndexOf(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if (looseEqual(getValue(option), value)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render$1 = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, resolveRootNamespace(container));
    }
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};

const runtimeDom = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  DeprecationTypes,
  EffectScope,
  ErrorCodes,
  ErrorTypeStrings,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  TrackOpTypes,
  Transition,
  TransitionGroup,
  TriggerOpTypes,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compatUtils,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  devtools,
  effect,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  getCurrentWatcher,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  hasInjectionContext,
  hydrate,
  hydrateOnIdle,
  hydrateOnInteraction,
  hydrateOnMediaQuery,
  hydrateOnVisible,
  initCustomFormatter,
  initDirectivesForSSR,
  inject,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  onWatcherCleanup,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render: render$1,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toRefs,
  toValue,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useHost,
  useId,
  useModel,
  useSSRContext,
  useShadowRoot,
  useSlots,
  useTemplateRef,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: 'Module' }));

/**
* @vue/compiler-core v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const FRAGMENT = Symbol(``);
const TELEPORT = Symbol(``);
const SUSPENSE = Symbol(``);
const KEEP_ALIVE = Symbol(``);
const BASE_TRANSITION = Symbol(
  ``
);
const OPEN_BLOCK = Symbol(``);
const CREATE_BLOCK = Symbol(``);
const CREATE_ELEMENT_BLOCK = Symbol(
  ``
);
const CREATE_VNODE = Symbol(``);
const CREATE_ELEMENT_VNODE = Symbol(
  ``
);
const CREATE_COMMENT = Symbol(
  ``
);
const CREATE_TEXT = Symbol(
  ``
);
const CREATE_STATIC = Symbol(
  ``
);
const RESOLVE_COMPONENT = Symbol(
  ``
);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(
  ``
);
const RESOLVE_DIRECTIVE = Symbol(
  ``
);
const RESOLVE_FILTER = Symbol(
  ``
);
const WITH_DIRECTIVES = Symbol(
  ``
);
const RENDER_LIST = Symbol(``);
const RENDER_SLOT = Symbol(``);
const CREATE_SLOTS = Symbol(``);
const TO_DISPLAY_STRING = Symbol(
  ``
);
const MERGE_PROPS = Symbol(``);
const NORMALIZE_CLASS = Symbol(
  ``
);
const NORMALIZE_STYLE = Symbol(
  ``
);
const NORMALIZE_PROPS = Symbol(
  ``
);
const GUARD_REACTIVE_PROPS = Symbol(
  ``
);
const TO_HANDLERS = Symbol(``);
const CAMELIZE = Symbol(``);
const CAPITALIZE = Symbol(``);
const TO_HANDLER_KEY = Symbol(
  ``
);
const SET_BLOCK_TRACKING = Symbol(
  ``
);
const PUSH_SCOPE_ID = Symbol(``);
const POP_SCOPE_ID = Symbol(``);
const WITH_CTX = Symbol(``);
const UNREF = Symbol(``);
const IS_REF = Symbol(``);
const WITH_MEMO = Symbol(``);
const IS_MEMO_SAME = Symbol(``);
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
const locStub = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, needPauseTracking = false) {
  return {
    type: 20,
    index,
    value,
    needPauseTracking,
    needArraySpread: false,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
const defaultDelimitersOpen = new Uint8Array([123, 123]);
const defaultDelimitersClose = new Uint8Array([125, 125]);
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
const Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
class Tokenizer {
  constructor(stack2, cbs) {
    this.stack = stack2;
    this.cbs = cbs;
    this.state = 1;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.entityStart = 0;
    this.baseState = 1;
    this.inRCDATA = false;
    this.inXML = false;
    this.inVPre = false;
    this.newlines = [];
    this.mode = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
    this.delimiterIndex = -1;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1;
    this.mode = 0;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = 1;
    this.inRCDATA = false;
    this.currentSequence = void 0;
    this.newlines.length = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(index) {
    let line = 1;
    let column = index + 1;
    for (let i = this.newlines.length - 1; i >= 0; i--) {
      const newlineIndex = this.newlines[i];
      if (index > newlineIndex) {
        line = i + 2;
        column = index - newlineIndex;
        break;
      }
    }
    return {
      column,
      line,
      offset: index
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(c) {
    if (c === 60) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!this.inVPre && c === this.delimiterOpen[0]) {
      this.state = 2;
      this.delimiterIndex = 0;
      this.stateInterpolationOpen(c);
    }
  }
  stateInterpolationOpen(c) {
    if (c === this.delimiterOpen[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const start = this.index + 1 - this.delimiterOpen.length;
        if (start > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, start);
        }
        this.state = 3;
        this.sectionStart = start;
      } else {
        this.delimiterIndex++;
      }
    } else if (this.inRCDATA) {
      this.state = 32;
      this.stateInRCDATA(c);
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInterpolation(c) {
    if (c === this.delimiterClose[0]) {
      this.state = 4;
      this.delimiterIndex = 0;
      this.stateInterpolationClose(c);
    }
  }
  stateInterpolationClose(c) {
    if (c === this.delimiterClose[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterClose.length - 1) {
        this.cbs.oninterpolation(this.sectionStart, this.index + 1);
        if (this.inRCDATA) {
          this.state = 32;
        } else {
          this.state = 1;
        }
        this.sectionStart = this.index + 1;
      } else {
        this.delimiterIndex++;
      }
    } else {
      this.state = 3;
      this.stateInterpolation(c);
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.inRCDATA = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = 6;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === 62 || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        this.inRCDATA = false;
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
        if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      } else if (this.fastForwardTo(60)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === 60);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = 28;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = 23;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length) {
      const cc = this.buffer.charCodeAt(this.index);
      if (cc === 10) {
        this.newlines.push(this.index);
      }
      if (cc === c) {
        return true;
      }
    }
    this.index = this.buffer.length - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index - 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index - 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = 1;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  startSpecial(sequence, offset) {
    this.enterRCDATA(sequence, offset);
    this.state = 31;
  }
  enterRCDATA(sequence, offset) {
    this.inRCDATA = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
  }
  stateBeforeTagName(c) {
    if (c === 33) {
      this.state = 22;
      this.sectionStart = this.index + 1;
    } else if (c === 63) {
      this.state = 24;
      this.sectionStart = this.index + 1;
    } else if (isTagStartChar(c)) {
      this.sectionStart = this.index;
      if (this.mode === 0) {
        this.state = 6;
      } else if (this.inSFCRoot) {
        this.state = 34;
      } else if (!this.inXML) {
        if (c === 116) {
          this.state = 30;
        } else {
          this.state = c === 115 ? 29 : 6;
        }
      } else {
        this.state = 6;
      }
    } else if (c === 47) {
      this.state = 8;
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.handleTagName(c);
    }
  }
  stateInSFCRootTagName(c) {
    if (isEndOfTagSection(c)) {
      const tag = this.buffer.slice(this.sectionStart, this.index);
      if (tag !== "template") {
        this.enterRCDATA(toCharCodes(`</` + tag), 0);
      }
      this.handleTagName(c);
    }
  }
  handleTagName(c) {
    this.cbs.onopentagname(this.sectionStart, this.index);
    this.sectionStart = -1;
    this.state = 11;
    this.stateBeforeAttrName(c);
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) ;
    else if (c === 62) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    } else {
      this.state = isTagStartChar(c) ? 9 : 27;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === 62 || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = 10;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === 62) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttrName(c) {
    if (c === 62) {
      this.cbs.onopentagend(this.index);
      if (this.inRCDATA) {
        this.state = 32;
      } else {
        this.state = 1;
      }
      this.sectionStart = this.index + 1;
    } else if (c === 47) {
      this.state = 7;
    } else if (c === 60 && this.peek() === 47) {
      this.cbs.onopentagend(this.index);
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!isWhitespace(c)) {
      this.handleAttrStart(c);
    }
  }
  handleAttrStart(c) {
    if (c === 118 && this.peek() === 45) {
      this.state = 13;
      this.sectionStart = this.index;
    } else if (c === 46 || c === 58 || c === 64 || c === 35) {
      this.cbs.ondirname(this.index, this.index + 1);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 12;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === 62) {
      this.cbs.onselfclosingtag(this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
      this.inRCDATA = false;
    } else if (!isWhitespace(c)) {
      this.state = 11;
      this.stateBeforeAttrName(c);
    }
  }
  stateInAttrName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    }
  }
  stateInDirName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 58) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else if (c === 46) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDirArg(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 91) {
      this.state = 15;
    } else if (c === 46) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDynamicDirArg(c) {
    if (c === 93) {
      this.state = 14;
    } else if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index + 1);
      this.handleAttrNameEnd(c);
    }
  }
  stateInDirModifier(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 46) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.sectionStart = this.index + 1;
    }
  }
  handleAttrNameEnd(c) {
    this.sectionStart = this.index;
    this.state = 17;
    this.cbs.onattribnameend(this.index);
    this.stateAfterAttrName(c);
  }
  stateAfterAttrName(c) {
    if (c === 61) {
      this.state = 18;
    } else if (c === 47 || c === 62) {
      this.cbs.onattribend(0, this.sectionStart);
      this.sectionStart = -1;
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(0, this.sectionStart);
      this.handleAttrStart(c);
    }
  }
  stateBeforeAttrValue(c) {
    if (c === 34) {
      this.state = 19;
      this.sectionStart = this.index + 1;
    } else if (c === 39) {
      this.state = 20;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = 21;
      this.stateInAttrValueNoQuotes(c);
    }
  }
  handleInAttrValue(c, quote) {
    if (c === quote || this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(
        quote === 34 ? 3 : 2,
        this.index + 1
      );
      this.state = 11;
    }
  }
  stateInAttrValueDoubleQuotes(c) {
    this.handleInAttrValue(c, 34);
  }
  stateInAttrValueSingleQuotes(c) {
    this.handleInAttrValue(c, 39);
  }
  stateInAttrValueNoQuotes(c) {
    if (isWhitespace(c) || c === 62) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(1, this.index);
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (c === 39 || c === 60 || c === 61 || c === 96) {
      this.cbs.onerr(
        18,
        this.index
      );
    } else ;
  }
  stateBeforeDeclaration(c) {
    if (c === 91) {
      this.state = 26;
      this.sequenceIndex = 0;
    } else {
      this.state = c === 45 ? 25 : 23;
    }
  }
  stateInDeclaration(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === 45) {
      this.state = 28;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 23;
    }
  }
  stateInSpecialComment(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.oncomment(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    if (c === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (c === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  stateBeforeSpecialT(c) {
    if (c === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (c === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  startEntity() {
  }
  stateInEntity() {
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(input) {
    this.buffer = input;
    while (this.index < this.buffer.length) {
      const c = this.buffer.charCodeAt(this.index);
      if (c === 10) {
        this.newlines.push(this.index);
      }
      switch (this.state) {
        case 1: {
          this.stateText(c);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(c);
          break;
        }
        case 3: {
          this.stateInterpolation(c);
          break;
        }
        case 4: {
          this.stateInterpolationClose(c);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case 32: {
          this.stateInRCDATA(c);
          break;
        }
        case 26: {
          this.stateCDATASequence(c);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(c);
          break;
        }
        case 12: {
          this.stateInAttrName(c);
          break;
        }
        case 13: {
          this.stateInDirName(c);
          break;
        }
        case 14: {
          this.stateInDirArg(c);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(c);
          break;
        }
        case 16: {
          this.stateInDirModifier(c);
          break;
        }
        case 28: {
          this.stateInCommentLike(c);
          break;
        }
        case 27: {
          this.stateInSpecialComment(c);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(c);
          break;
        }
        case 6: {
          this.stateInTagName(c);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(c);
          break;
        }
        case 9: {
          this.stateInClosingTagName(c);
          break;
        }
        case 5: {
          this.stateBeforeTagName(c);
          break;
        }
        case 17: {
          this.stateAfterAttrName(c);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(c);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(c);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(c);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(c);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case 23: {
          this.stateInDeclaration(c);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case 25: {
          this.stateBeforeComment(c);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
    this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.sectionStart !== this.index) {
      if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === 19 || this.state === 20 || this.state === 21) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  finish() {
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === 28) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex);
      }
    } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ;
    else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
  }
}
function getCompatValue(key, { compatConfig }) {
  const value = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  return enabled;
}
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = `https://vuejs.org/error-reference/#compiler-${code}`;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
const isStaticExp = (p) => p.type === 4 && p.isStatic;
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
const isMemberExpressionBrowser = (exp) => {
  const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
  let state = 0;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i);
    switch (state) {
      case 0:
        if (char === "[") {
          stateStack.push(state);
          state = 1;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpression = isMemberExpressionBrowser;
const fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
const isFnExpression = isFnExpressionBrowser;
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly) continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
const defaultParserOptions = {
  parseMode: "base",
  ns: 0,
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  isVoidTag: NO,
  isPreTag: NO,
  isIgnoreNewlineTag: NO,
  isCustomElement: NO,
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: false,
  prefixIdentifiers: false
};
let currentOptions = defaultParserOptions;
let currentRoot = null;
let currentInput = "";
let currentOpenTag = null;
let currentProp = null;
let currentAttrValue = "";
let currentAttrStartIndex = -1;
let currentAttrEndIndex = -1;
let inPre = 0;
let inVPre = false;
let currentVPreBoundary = null;
const stack = [];
const tokenizer = new Tokenizer(stack, {
  onerr: emitError,
  ontext(start, end) {
    onText(getSlice(start, end), start, end);
  },
  ontextentity(char, start, end) {
    onText(char, start, end);
  },
  oninterpolation(start, end) {
    if (inVPre) {
      return onText(getSlice(start, end), start, end);
    }
    let innerStart = start + tokenizer.delimiterOpen.length;
    let innerEnd = end - tokenizer.delimiterClose.length;
    while (isWhitespace(currentInput.charCodeAt(innerStart))) {
      innerStart++;
    }
    while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
      innerEnd--;
    }
    let exp = getSlice(innerStart, innerEnd);
    if (exp.includes("&")) {
      {
        exp = currentOptions.decodeEntities(exp, false);
      }
    }
    addNode({
      type: 5,
      content: createExp(exp, false, getLoc(innerStart, innerEnd)),
      loc: getLoc(start, end)
    });
  },
  onopentagname(start, end) {
    const name = getSlice(start, end);
    currentOpenTag = {
      type: 1,
      tag: name,
      ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: getLoc(start - 1, end),
      codegenNode: void 0
    };
  },
  onopentagend(end) {
    endOpenTag(end);
  },
  onclosetag(start, end) {
    const name = getSlice(start, end);
    if (!currentOptions.isVoidTag(name)) {
      let found = false;
      for (let i = 0; i < stack.length; i++) {
        const e = stack[i];
        if (e.tag.toLowerCase() === name.toLowerCase()) {
          found = true;
          if (i > 0) {
            emitError(24, stack[0].loc.start.offset);
          }
          for (let j = 0; j <= i; j++) {
            const el = stack.shift();
            onCloseTag(el, end, j < i);
          }
          break;
        }
      }
      if (!found) {
        emitError(23, backTrack(start, 60));
      }
    }
  },
  onselfclosingtag(end) {
    const name = currentOpenTag.tag;
    currentOpenTag.isSelfClosing = true;
    endOpenTag(end);
    if (stack[0] && stack[0].tag === name) {
      onCloseTag(stack.shift(), end);
    }
  },
  onattribname(start, end) {
    currentProp = {
      type: 6,
      name: getSlice(start, end),
      nameLoc: getLoc(start, end),
      value: void 0,
      loc: getLoc(start)
    };
  },
  ondirname(start, end) {
    const raw = getSlice(start, end);
    const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
    if (!inVPre && name === "") {
      emitError(26, start);
    }
    if (inVPre || name === "") {
      currentProp = {
        type: 6,
        name: raw,
        nameLoc: getLoc(start, end),
        value: void 0,
        loc: getLoc(start)
      };
    } else {
      currentProp = {
        type: 7,
        name,
        rawName: raw,
        exp: void 0,
        arg: void 0,
        modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
        loc: getLoc(start)
      };
      if (name === "pre") {
        inVPre = tokenizer.inVPre = true;
        currentVPreBoundary = currentOpenTag;
        const props = currentOpenTag.props;
        for (let i = 0; i < props.length; i++) {
          if (props[i].type === 7) {
            props[i] = dirToAttr(props[i]);
          }
        }
      }
    }
  },
  ondirarg(start, end) {
    if (start === end) return;
    const arg = getSlice(start, end);
    if (inVPre) {
      currentProp.name += arg;
      setLocEnd(currentProp.nameLoc, end);
    } else {
      const isStatic = arg[0] !== `[`;
      currentProp.arg = createExp(
        isStatic ? arg : arg.slice(1, -1),
        isStatic,
        getLoc(start, end),
        isStatic ? 3 : 0
      );
    }
  },
  ondirmodifier(start, end) {
    const mod = getSlice(start, end);
    if (inVPre) {
      currentProp.name += "." + mod;
      setLocEnd(currentProp.nameLoc, end);
    } else if (currentProp.name === "slot") {
      const arg = currentProp.arg;
      if (arg) {
        arg.content += "." + mod;
        setLocEnd(arg.loc, end);
      }
    } else {
      const exp = createSimpleExpression(mod, true, getLoc(start, end));
      currentProp.modifiers.push(exp);
    }
  },
  onattribdata(start, end) {
    currentAttrValue += getSlice(start, end);
    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribentity(char, start, end) {
    currentAttrValue += char;
    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribnameend(end) {
    const start = currentProp.loc.start.offset;
    const name = getSlice(start, end);
    if (currentProp.type === 7) {
      currentProp.rawName = name;
    }
    if (currentOpenTag.props.some(
      (p) => (p.type === 7 ? p.rawName : p.name) === name
    )) {
      emitError(2, start);
    }
  },
  onattribend(quote, end) {
    if (currentOpenTag && currentProp) {
      setLocEnd(currentProp.loc, end);
      if (quote !== 0) {
        if (currentAttrValue.includes("&")) {
          currentAttrValue = currentOptions.decodeEntities(
            currentAttrValue,
            true
          );
        }
        if (currentProp.type === 6) {
          if (currentProp.name === "class") {
            currentAttrValue = condense(currentAttrValue).trim();
          }
          if (quote === 1 && !currentAttrValue) {
            emitError(13, end);
          }
          currentProp.value = {
            type: 2,
            content: currentAttrValue,
            loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
          };
          if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
            tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
          }
        } else {
          let expParseMode = 0;
          currentProp.exp = createExp(
            currentAttrValue,
            false,
            getLoc(currentAttrStartIndex, currentAttrEndIndex),
            0,
            expParseMode
          );
          if (currentProp.name === "for") {
            currentProp.forParseResult = parseForExpression(currentProp.exp);
          }
          let syncIndex = -1;
          if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(
            (mod) => mod.content === "sync"
          )) > -1 && checkCompatEnabled(
            "COMPILER_V_BIND_SYNC",
            currentOptions,
            currentProp.loc,
            currentProp.rawName
          )) {
            currentProp.name = "model";
            currentProp.modifiers.splice(syncIndex, 1);
          }
        }
      }
      if (currentProp.type !== 7 || currentProp.name !== "pre") {
        currentOpenTag.props.push(currentProp);
      }
    }
    currentAttrValue = "";
    currentAttrStartIndex = currentAttrEndIndex = -1;
  },
  oncomment(start, end) {
    if (currentOptions.comments) {
      addNode({
        type: 3,
        content: getSlice(start, end),
        loc: getLoc(start - 4, end + 3)
      });
    }
  },
  onend() {
    const end = currentInput.length;
    for (let index = 0; index < stack.length; index++) {
      onCloseTag(stack[index], end - 1);
      emitError(24, stack[index].loc.start.offset);
    }
  },
  oncdata(start, end) {
    if (stack[0].ns !== 0) {
      onText(getSlice(start, end), start, end);
    } else {
      emitError(1, start - 9);
    }
  },
  onprocessinginstruction(start) {
    if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
      emitError(
        21,
        start - 1
      );
    }
  }
});
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 : 0
      /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  {
    const tag = stack[0] && stack[0].tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns, children } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(children);
  }
  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
    const first = children[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
      const parent = stack[0] || currentRoot;
      const index = parent.children.indexOf(el);
      parent.children.splice(index, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function lookAhead(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
  return i;
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
  return i;
}
const specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p.loc
        )) {
          return true;
        }
      }
    } else if (
      // :is on plain element - only treat as component in compat mode
      p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        currentOptions,
        p.loc
      )
    ) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
const windowsNewlineRE = /\r\n/g;
function condenseWhitespace(nodes, tag) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function cloneLoc(loc) {
  return getLoc(loc.start.offset, loc.end.offset);
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index))
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = extend({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}
function cacheStatic(root, context) {
  walk(
    root,
    void 0,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
  const { children } = node;
  const toCache = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1;
          toCache.push(child);
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = codegenNode.patchFlag;
          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType >= 2) {
        toCache.push(child);
        continue;
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, node, context, false, inFor);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, node, context, child.children.length === 1, true);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          node,
          context,
          child.branches[i2].children.length === 1,
          inFor
        );
      }
    }
  }
  let cachedAsArray = false;
  if (toCache.length === children.length && node.type === 1) {
    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
      node.codegenNode.children = getCacheExpression(
        createArrayExpression(node.codegenNode.children)
      );
      cachedAsArray = true;
    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {
      const slot = getSlotNode(node.codegenNode, "default");
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
      const slotName = findDir(node, "slot", true);
      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    }
  }
  if (!cachedAsArray) {
    for (const child of toCache) {
      child.codegenNode = context.cache(child.codegenNode);
    }
  }
  function getCacheExpression(value) {
    const exp = context.cache(value);
    if (inFor && context.hmr) {
      exp.needArraySpread = true;
    }
    return exp;
  }
  function getSlotNode(node2, name) {
    if (node2.children && !isArray(node2.children) && node2.children.type === 15) {
      const slot = node2.children.properties.find(
        (p) => p.key === name || p.key.content === name
      );
      return slot && slot.value;
    }
  }
  if (toCache.length && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
        return 0;
      }
      if (codegenNode.patchFlag === void 0) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    case 20:
      return 2;
    default:
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      const cacheExp = createCacheExpression(
        context.cached.length,
        exp,
        isVNode
      );
      context.cached.push(cacheExp);
      return cacheExp;
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    cacheStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child)) continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
const PURE_ANNOTATION = `/*@__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push(
      "\n" + `  `.repeat(n),
      0
      /* Start */
    );
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1
        /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(
      `
`,
      0
      /* Start */
    );
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(
        `const _Vue = ${VueBinding}
`,
        -1
        /* End */
      );
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(
          `const { ${staticHelpers} } = _Vue
`,
          -1
          /* End */
        );
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = `);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || false;
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(
        node,
        -3
        /* Unknown */
      );
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(
      node,
      -3
      /* Unknown */
    );
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3, node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure) push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(
        child,
        -3
        /* Unknown */
      );
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2, node);
  } else {
    push(`[${node.content}]`, -3, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node;
  let patchFlagString;
  if (patchFlag) {
    {
      patchFlagString = String(patchFlag);
    }
  }
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, -2, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2, node);
    return;
  }
  const multilines = properties.length > 1 || false;
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  const { needPauseTracking, needArraySpread } = node;
  if (needArraySpread) {
    push(`[...(`);
  }
  push(`_cache[${node.index}] || (`);
  if (needPauseTracking) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
    push(`(`);
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (needPauseTracking) {
    push(`).cacheIndex = ${node.index},`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
  if (needArraySpread) {
    push(`)]`);
  }
}
new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
);
const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      const siblings = context.parent.children;
      let i = siblings.indexOf(ifNode);
      let key = 0;
      while (i-- >= 0) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 9) {
          key += sibling.branches.length;
        }
      }
      return () => {
        if (isRoot) {
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch,
            key,
            context
          );
        } else {
          const parentCondition = getParentCondition(ifNode.codegenNode);
          parentCondition.alternate = createCodegenNodeForBranch(
            branch,
            key + ifNode.branches.length - 1,
            context
          );
        }
      };
    });
  }
);
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: cloneLoc(node.loc),
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
const transformBind = (dir, _node, context) => {
  const { modifiers, loc } = dir;
  const arg = dir.arg;
  let { exp } = dir;
  if (exp && exp.type === 4 && !exp.content.trim()) {
    {
      exp = void 0;
    }
  }
  if (!exp) {
    if (arg.type !== 4 || !arg.isStatic) {
      context.onError(
        createCompilerError(
          52,
          arg.loc
        )
      );
      return {
        props: [
          createObjectProperty(arg, createSimpleExpression("", true, loc))
        ]
      };
    }
    transformBindShorthand(dir);
    exp = dir.exp;
  }
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers.some((mod) => mod.content === "camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = camelize(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.some((mod) => mod.content === "prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.some((mod) => mod.content === "attr")) {
      injectPrefix(arg, "^");
    }
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const transformBindShorthand = (dir, context) => {
  const arg = dir.arg;
  const propName = camelize(arg.content);
  dir.exp = createSimpleExpression(propName, false, arg.loc);
};
const injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};
const transformFor = createStructuralDirectiveTransform(
  "for",
  (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, (forNode) => {
      const renderExp = createCallExpression(helper(RENDER_LIST), [
        forNode.source
      ]);
      const isTemplate = isTemplateNode(node);
      const memo = findDir(node, "memo");
      const keyProp = findProp(node, `key`, false, true);
      if (keyProp && keyProp.type === 7 && !keyProp.exp) {
        transformBindShorthand(keyProp);
      }
      const keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
      const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
      forNode.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        renderExp,
        fragmentFlag,
        void 0,
        void 0,
        true,
        !isStableFragment,
        false,
        node.loc
      );
      return () => {
        let childBlock;
        const { children } = forNode;
        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
        if (slotOutlet) {
          childBlock = slotOutlet.codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
        } else if (needFragmentWrapper) {
          childBlock = createVNodeCall(
            context,
            helper(FRAGMENT),
            keyProperty ? createObjectExpression([keyProperty]) : void 0,
            node.children,
            64,
            void 0,
            void 0,
            true,
            void 0,
            false
          );
        } else {
          childBlock = children[0].codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
          if (childBlock.isBlock !== !isStableFragment) {
            if (childBlock.isBlock) {
              removeHelper(OPEN_BLOCK);
              removeHelper(
                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
              );
            } else {
              removeHelper(
                getVNodeHelper(context.inSSR, childBlock.isComponent)
              );
            }
          }
          childBlock.isBlock = !isStableFragment;
          if (childBlock.isBlock) {
            helper(OPEN_BLOCK);
            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        if (memo) {
          const loop = createFunctionExpression(
            createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ])
          );
          loop.body = createBlockStatement([
            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
            createCompoundExpression([
              `if (_cached`,
              ...keyExp ? [` && _cached.key === `, keyExp] : [],
              ` && ${context.helperString(
                IS_MEMO_SAME
              )}(_cached, _memo)) return _cached`
            ]),
            createCompoundExpression([`const _item = `, childBlock]),
            createSimpleExpression(`_item.memo = _memo`),
            createSimpleExpression(`return _item`)
          ]);
          renderExp.arguments.push(
            loop,
            createSimpleExpression(`_cache`),
            createSimpleExpression(String(context.cached.length))
          );
          context.cached.push(null);
        } else {
          renderExp.arguments.push(
            createFunctionExpression(
              createForLoopParams(forNode.parseResult),
              childBlock,
              true
            )
          );
        }
      };
    });
  }
);
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit) onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized) return;
  result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return () => {
        context.scopes.vSlot--;
      };
    }
  }
};
const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
  props,
  children,
  false,
  true,
  children.length ? children[0].loc : loc
);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, /^(else-)?if$/)) {
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (``),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props } = node;
    const isComponent2 = node.tagType === 1;
    let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = (
      // dynamic component may resolve to plain elements
      isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
      // updates inside get proper isSVG flag at runtime. (#639, #643)
      // This is technically web-specific, but splitting the logic out of core
      // leads to too much unnecessary complexity.
      (tag === "svg" || tag === "foreignObject" || tag === "math")
    );
    if (props.length > 0) {
      const propsBuildResult = buildProps(
        node,
        context,
        void 0,
        isComponent2,
        isDynamicComponent
      );
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(
        directives.map((dir) => buildDirectiveArgs(dir, context))
      ) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
      }
      const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (dynamicPropNames && dynamicPropNames.length) {
      vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
    }
    node.codegenNode = createVNodeCall(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      patchFlag === 0 ? void 0 : patchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      !!shouldUseBlock,
      false,
      isComponent2,
      node.loc
    );
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.arg.loc);
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg) mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushRefVForMarker();
            pushMergeArg();
            {
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
const transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(
      context.helper(RENDER_SLOT),
      slotArgs,
      loc
    );
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) {
          slotName = p.exp;
        } else if (p.arg && p.arg.type === 4) {
          const name = camelize(p.arg.content);
          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
        }
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}
const transformOn$1 = (dir, node, context, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        toHandlerKey(camelize(rawName))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${rawName}`
      );
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp);
    const isInlineStatement = !(isMemberExp || isFnExpression(exp));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(
        eventName,
        exp || createSimpleExpression(`() => {}`, false, loc)
      )
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p) => p.key.isHandlerKey = true);
  return ret;
};
const transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child)) {
          hasText = true;
          for (let j = i + 1; j < children.length; j++) {
            const next = children[j];
            if (isText$1(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression(
                  [child],
                  child.loc
                );
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !node.props.find(
        (p) => p.type === 7 && !context.directiveTransforms[p.name]
      ) && // in compat mode, <template> tags with no special directives
      // will be rendered as a fragment so its children must be
      // converted into vnodes.
      !(node.tag === "template"))) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(
              1 + (``)
            );
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(
              context.helper(CREATE_TEXT),
              callArgs
            )
          };
        }
      }
    };
  }
};
const seen$1 = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen$1.has(node) || context.inVOnce || context.inSSR) {
      return;
    }
    seen$1.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(
          cur.codegenNode,
          true
          /* isVNode */
        );
      }
    };
  }
};
const transformModel$1 = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(
      createCompilerError(41, dir.loc)
    );
    return createTransformProps();
  }
  const rawExp = exp.loc.source.trim();
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  const maybeRef = false;
  if (!expString.trim() || !isMemberExpression(exp) && !maybeRef) {
    context.onError(
      createCompilerError(42, exp.loc)
    );
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props = [
    // modelValue: foo
    createObjectProperty(propName, dir.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    createObjectProperty(eventName, assignmentExp)
  ];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(
      createObjectProperty(
        modifiersKey,
        createSimpleExpression(
          `{ ${modifiers} }`,
          false,
          dir.loc,
          2
        )
      )
    );
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return { props };
}
const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
  if (!isCompatEnabled("COMPILER_FILTERS", context)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context);
  } else if (node.type === 1) {
    node.props.forEach((prop) => {
      if (prop.type === 7 && prop.name !== "for" && prop.exp) {
        rewriteFilter(prop.exp, context);
      }
    });
  }
};
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object") continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92) inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92) inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92) inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92) inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ") break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
    node.ast = void 0;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
const seen = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen.has(node)) {
      return;
    }
    seen.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          convertToBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context.cached.length)
        ]);
        context.cached.push(null);
      }
    };
  }
};
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...[],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn$1,
      bind: transformBind,
      model: transformModel$1
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend({}, options, {
    prefixIdentifiers
  });
  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}
const noopDirectiveTransform = () => ({ props: [] });

/**
* @vue/compiler-dom v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const V_MODEL_RADIO = Symbol(``);
const V_MODEL_CHECKBOX = Symbol(
  ``
);
const V_MODEL_TEXT = Symbol(``);
const V_MODEL_SELECT = Symbol(
  ``
);
const V_MODEL_DYNAMIC = Symbol(
  ``
);
const V_ON_WITH_MODIFIERS = Symbol(
  ``
);
const V_ON_WITH_KEYS = Symbol(
  ``
);
const V_SHOW = Symbol(``);
const TRANSITION = Symbol(``);
const TRANSITION_GROUP = Symbol(
  ``
);
registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
const parserOptions = {
  parseMode: "html",
  isVoidTag,
  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
  isPreTag: (tag) => tag === "pre",
  isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
  decodeEntities: decodeHtmlBrowser,
  isBuiltInComponent: (tag) => {
    if (tag === "Transition" || tag === "transition") {
      return TRANSITION;
    } else if (tag === "TransitionGroup" || tag === "transition-group") {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent, rootNamespace) {
    let ns = parent ? parent.ns : rootNamespace;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some(
          (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
        )) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  }
};
const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p, i) => {
      if (p.type === 6 && p.name === "style" && p.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText);
  return createSimpleExpression(
    JSON.stringify(normalized),
    false,
    loc,
    3
  );
};
function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc);
}
const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(53, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(54, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`innerHTML`, true, loc),
        exp || createSimpleExpression("", true)
      )
    ]
  };
};
const transformVText = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(55, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(56, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`textContent`, true),
        exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
          context.helperString(TO_DISPLAY_STRING),
          [exp],
          loc
        ) : createSimpleExpression("", true)
      )
    ]
  };
};
const transformModel = (dir, node, context) => {
  const baseResult = transformModel$1(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(
      createDOMCompilerError(
        58,
        dir.arg.loc
      )
    );
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = findProp(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(
                createDOMCompilerError(
                  59,
                  dir.loc
                )
              );
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else ;
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else ;
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(
      createDOMCompilerError(
        57,
        dir.loc
      )
    );
  }
  baseResult.props = baseResult.props.filter(
    (p) => !(p.key.type === 4 && p.key.content === "modelValue")
  );
  return baseResult;
};
const isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ makeMap(
  // event propagation management
  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
);
const maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
const isKeyboardEvent = /* @__PURE__ */ makeMap(`onkeyup,onkeydown,onkeypress`);
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i].content;
    if (modifier === "native" && checkCompatEnabled(
      "COMPILER_V_ON_NATIVE",
      context)) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content.toLowerCase())) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
const transformOn = (dir, node, context) => {
  return transformOn$1(dir, node, context, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length) return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
    (!isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [createObjectProperty(key, handlerExp)]
    };
  });
};
const transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(61, loc)
    );
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};
const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
    context.removeNode();
  }
};
const DOMNodeTransforms = [
  transformStyle,
  ...[]
];
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  // override compiler-core
  on: transformOn,
  // override compiler-core
  show: transformShow
};
function compile(src, options = {}) {
  return baseCompile(
    src,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}

/**
* vue v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const compileCache = /* @__PURE__ */ Object.create(null);
function compileToFunction(template, options) {
  if (!isString(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
      return NOOP;
    }
  }
  const key = genCacheKey(template, options);
  const cached = compileCache[key];
  if (cached) {
    return cached;
  }
  if (template[0] === "#") {
    const el = document.querySelector(template);
    template = el ? el.innerHTML : ``;
  }
  const opts = extend(
    {
      hoistStatic: true,
      onError: void 0,
      onWarn: NOOP
    },
    options
  );
  if (!opts.isCustomElement && typeof customElements !== "undefined") {
    opts.isCustomElement = (tag) => !!customElements.get(tag);
  }
  const { code } = compile(template, opts);
  const render = new Function("Vue", code)(runtimeDom);
  render._rc = true;
  return compileCache[key] = render;
}
registerRuntimeCompiler(compileToFunction);

const { sanitizeStoryContextUpdate } = __STORYBOOK_MODULE_PREVIEW_API__;

var entry_preview_exports={};__export$1(entry_preview_exports,{applyDecorators:()=>decorateStory,argTypesEnhancers:()=>argTypesEnhancers,mount:()=>mount,parameters:()=>parameters$1,render:()=>render,renderToCanvas:()=>renderToCanvas});var ARG_TYPE_SECTIONS=["props","events","slots","exposed","expose"],extractArgTypes=component=>{if(!at(component))return null;let usedDocgenPlugin="exposed"in component.__docgenInfo?"vue-component-meta":"vue-docgen-api",argTypes={};return ARG_TYPE_SECTIONS.forEach(section=>{aa(component,section).forEach(extractedProp=>{let argType;if(usedDocgenPlugin==="vue-docgen-api"){let docgenInfo=extractedProp.docgenInfo;argType=extractFromVueDocgenApi(docgenInfo,section,extractedProp);}else {let docgenInfo=extractedProp.docgenInfo;argType=extractFromVueComponentMeta(docgenInfo,section);}if(!argType||argTypes[argType.name])return;["events","expose","exposed"].includes(section)&&(argType.control={disable:!0}),argTypes[argType.name]=argType;});}),argTypes},extractFromVueDocgenApi=(docgenInfo,section,extractedProp)=>{let type,sbType;if(section==="events"&&(type=docgenInfo.type?.names.join(),sbType={name:"other",value:type??"",required:!1}),section==="slots"){let slotBindings=docgenInfo.bindings?.filter(binding=>!!binding.name).map(binding=>`${binding.name}: ${binding.type?.name??"unknown"}`).join("; ");type=slotBindings?`{ ${slotBindings} }`:void 0,sbType={name:"other",value:type??"",required:!1};}if(section==="props"){let propInfo=docgenInfo;if(type=propInfo.type?.name,sbType=extractedProp?pe(extractedProp.docgenInfo):{name:"other",value:type},propInfo.type&&"elements"in propInfo.type&&Array.isArray(propInfo.type.elements)&&propInfo.type.elements.length>0){let elements=propInfo.type.elements.map(i=>i.name);type==="Array"&&(type=`${elements.length===1?elements[0]:`(${elements.join(" | ")})`}[]`),type==="union"?type=elements.join(" | "):type==="intersection"&&(type=elements.join(" & "));}}let required="required"in docgenInfo?docgenInfo.required??!1:!1;return {name:docgenInfo.name,description:docgenInfo.description,type:sbType?{...sbType,required}:{name:"other",value:type??""},table:{type:type?{summary:type}:void 0,defaultValue:extractedProp?.propDef.defaultValue??void 0,jsDocTags:extractedProp?.propDef.jsDocTags,category:section}}},extractFromVueComponentMeta=(docgenInfo,section)=>{if("global"in docgenInfo&&docgenInfo.global)return;let tableType={summary:docgenInfo.type.replace(" | undefined","")};if(section==="props"){let propInfo=docgenInfo,defaultValue=propInfo.default?{summary:propInfo.default}:void 0;return {name:propInfo.name,description:formatDescriptionWithTags(propInfo.description,propInfo.tags),defaultValue,type:convertVueComponentMetaProp(propInfo),table:{type:tableType,defaultValue,category:section}}}else return {name:docgenInfo.name,description:"description"in docgenInfo?docgenInfo.description:"",type:{name:"other",value:docgenInfo.type},table:{type:tableType,category:section}}},convertVueComponentMetaProp=propInfo=>{let schema=propInfo.schema,required=propInfo.required,fallbackSbType={name:"other",value:propInfo.type,required},KNOWN_SCHEMAS=["string","number","function","boolean","symbol"];if(typeof schema=="string")return KNOWN_SCHEMAS.includes(schema)?{name:schema,required}:fallbackSbType;switch(schema.kind){case"enum":{let definedSchemas=schema.schema?.filter(item=>item!=="undefined")??[];return isBooleanSchema(definedSchemas)?{name:"boolean",required}:isLiteralUnionSchema(definedSchemas)||isEnumSchema(definedSchemas)?{name:"enum",value:definedSchemas.map(literal=>literal.replace(/"/g,"")),required}:definedSchemas.length===1?convertVueComponentMetaProp({schema:definedSchemas[0],type:propInfo.type,required}):(definedSchemas.length>2&&definedSchemas.includes("true")&&definedSchemas.includes("false")&&(definedSchemas=definedSchemas.filter(i=>i!=="true"&&i!=="false"),definedSchemas.push("boolean")),{name:"union",value:definedSchemas.map(i=>convertVueComponentMetaProp(typeof i=="object"?{schema:i,type:i.type,required:!1}:{schema:i,type:i,required:!1})),required})}case"array":{let definedSchemas=schema.schema?.filter(item=>item!=="undefined")??[];return definedSchemas.length===0?fallbackSbType:definedSchemas.length===1?{name:"array",value:convertVueComponentMetaProp({schema:definedSchemas[0],type:propInfo.type,required:!1}),required}:{name:"union",value:definedSchemas.map(i=>convertVueComponentMetaProp(typeof i=="object"?{schema:i,type:i.type,required:!1}:{schema:i,type:i,required:!1})),required}}case"object":return {name:"object",value:{},required};default:return fallbackSbType}},formatDescriptionWithTags=(description,tags)=>!tags?.length||!description?description??"":`${tags.map(tag=>`@${tag.name}: ${tag.text}`).join("<br>")}<br><br>${description}`,isLiteralUnionSchema=schemas=>schemas.every(schema=>typeof schema=="string"&&schema.startsWith('"')&&schema.endsWith('"')),isEnumSchema=schemas=>schemas.every(schema=>typeof schema=="string"&&schema.includes(".")),isBooleanSchema=schemas=>schemas.length===2&&schemas.includes("true")&&schemas.includes("false");var render=(props,context)=>{let{id,component:Component}=context;if(!Component)throw new Error(`Unable to render story ${id} as the component annotation is missing from the default export`);return ()=>h(Component,props,getSlots(props,context))},runSetupFunctions=async(app,storyContext)=>{globalThis&&globalThis.PLUGINS_SETUP_FUNCTIONS&&await Promise.all([...globalThis.PLUGINS_SETUP_FUNCTIONS].map(fn=>fn(app,storyContext)));},map=new Map;async function renderToCanvas({storyFn,forceRemount,showMain,showException,storyContext,id},canvasElement){let existingApp=map.get(canvasElement);if(existingApp&&!forceRemount){let element=storyFn(),args=getArgs(element,storyContext);return updateArgs(existingApp.reactiveArgs,args),()=>{teardown(existingApp.vueApp,canvasElement);}}existingApp&&forceRemount&&teardown(existingApp.vueApp,canvasElement);let vueApp=createApp({setup(){storyContext.args=reactive(storyContext.args);let rootElement=storyFn(),args=getArgs(rootElement,storyContext),appState={vueApp,reactiveArgs:reactive(args)};return map.set(canvasElement,appState),()=>h(rootElement)}});return vueApp.config.errorHandler=(e,instance,info)=>{window.__STORYBOOK_PREVIEW__?.storyRenders.some(renderer=>renderer.id===id&&renderer.phase==="playing")?setTimeout(()=>{throw e},0):showException(e);},await runSetupFunctions(vueApp,storyContext),vueApp.mount(canvasElement),showMain(),()=>{teardown(vueApp,canvasElement);}}function getSlots(props,context){let{argTypes}=context,slots=Object.entries(props).filter(([key])=>argTypes[key]?.table?.category==="slots").map(([key,value])=>[key,typeof value=="function"?value:()=>value]);return Object.fromEntries(slots)}function getArgs(element,storyContext){return element.props&&isVNode(element)?element.props:storyContext.args}function updateArgs(reactiveArgs,nextArgs){if(Object.keys(nextArgs).length===0)return;let currentArgs=isReactive(reactiveArgs)?reactiveArgs:reactive(reactiveArgs);Object.keys(currentArgs).forEach(key=>{key in nextArgs||delete currentArgs[key];}),Object.assign(currentArgs,nextArgs);}function teardown(storybookApp,canvasElement){storybookApp?.unmount(),map.has(canvasElement)&&map.delete(canvasElement);}function normalizeFunctionalComponent(options){return typeof options=="function"?{render:options,name:options.name}:options}function prepare(rawStory,innerStory){let story=rawStory;return story===null?null:typeof story=="function"?story:innerStory?{...normalizeFunctionalComponent(story),components:{...story.components||{},story:innerStory}}:{render(){return h(story)}}}function decorateStory(storyFn,decorators){return decorators.reduce((decorated,decorator)=>context=>{let story,decoratedStory=decorator(update=>{let sanitizedUpdate=sanitizeStoryContextUpdate(update);return update&&(sanitizedUpdate.args=Object.assign(context.args,sanitizedUpdate.args)),story=decorated({...context,...sanitizedUpdate}),story},context);return story||(story=decorated(context)),decoratedStory===story?story:prepare(decoratedStory,()=>h(story))},context=>prepare(storyFn(context)))}var mount=context=>async(Component,options)=>(Component&&(context.originalStoryFn=()=>()=>h(Component,options?.props,options?.slots)),await context.renderToCanvas(),context.canvas);var parameters$1={renderer:"vue3",docs:{story:{inline:!0},extractArgTypes,extractComponentDescription: ia}},argTypesEnhancers=[ya];

const entry_preview_20087 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  applyDecorators: decorateStory,
  argTypesEnhancers,
  mount,
  parameters: parameters$1,
  render,
  renderToCanvas
}, Symbol.toStringTag, { value: 'Module' }));

const { STORY_CHANGED, SELECT_STORY } = __STORYBOOK_MODULE_CORE_EVENTS__;
const { global: global$1 } = __STORYBOOK_MODULE_GLOBAL__;
const { makeDecorator, addons: addons$1 } = __STORYBOOK_MODULE_PREVIEW_API__;

var PARAM_KEY$1="links";var{document: document$1,HTMLElement: HTMLElement$1}=global$1;var navigate=params=>addons$1.getChannel().emit(SELECT_STORY,params);var linksListener=e=>{let{target}=e;if(!(target instanceof HTMLElement$1))return;let element=target,{sbKind:kind,sbStory:story}=element.dataset;(kind||story)&&(e.preventDefault(),navigate({kind,story}));},hasListener=!1,on=()=>{hasListener||(hasListener=!0,document$1.addEventListener("click",linksListener));},off=()=>{hasListener&&(hasListener=!1,document$1.removeEventListener("click",linksListener));},withLinks=makeDecorator({name:"withLinks",parameterName:PARAM_KEY$1,wrapper:(getStory,context)=>(on(),addons$1.getChannel().once(STORY_CHANGED,off),getStory(context))});var decorators$1=[withLinks];

const preview_21536 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  decorators: decorators$1
}, Symbol.toStringTag, { value: 'Module' }));

var GLOBAL_KEY$1="theme";var initialGlobals$1={[GLOBAL_KEY$1]:""};

const preview_21972 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  initialGlobals: initialGlobals$1
}, Symbol.toStringTag, { value: 'Module' }));

function dedent(templ) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    var strings = Array.from(typeof templ === 'string' ? [templ] : templ);
    strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, '');
    var indentLengths = strings.reduce(function (arr, str) {
        var matches = str.match(/\n([\t ]+|(?!\s).)/g);
        if (matches) {
            return arr.concat(matches.map(function (match) { var _a, _b; return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0; }));
        }
        return arr;
    }, []);
    if (indentLengths.length) {
        var pattern_1 = new RegExp("\n[\t ]{" + Math.min.apply(Math, indentLengths) + "}", 'g');
        strings = strings.map(function (str) { return str.replace(pattern_1, '\n'); });
    }
    strings[0] = strings[0].replace(/^\r?\n/, '');
    var string = strings[0];
    values.forEach(function (value, i) {
        var endentations = string.match(/(?:^|\n)( *)$/);
        var endentation = endentations ? endentations[1] : '';
        var indentedValue = value;
        if (typeof value === 'string' && value.includes('\n')) {
            indentedValue = String(value)
                .split('\n')
                .map(function (str, i) {
                return i === 0 ? str : "" + endentation + str;
            })
                .join('\n');
        }
        string += indentedValue + strings[i + 1];
    });
    return string;
}

var react_production_min = {};

/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l=Symbol.for("react.element"),n=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z=Symbol.iterator;function A(a){if(null===a||"object"!==typeof a)return null;a=z&&a[z]||a["@@iterator"];return "function"===typeof a?a:null}
var B={isMounted:function(){return !1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B;}E.prototype.isReactComponent={};
E.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState");};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B;}var H=G.prototype=new F;
H.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f;}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return {$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}
function N(a,b){return {$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return "object"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={"=":"=0",":":"=2"};return "$"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g;function Q(a,b){return "object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}
function R(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l:case n:h=!0;}}if(h)return h=a,c=c(h),a=""===d?"."+Q(h,0):d,I(c)?(e="",null!=a&&(e=a.replace(P,"$&/")+"/"),R(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I(a))for(var g=0;g<a.length;g++){k=
a[g];var f=d+Q(k,g);h+=R(k,b,e,f,c);}else if(f=A(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}
function S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b;},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b;});-1===a._status&&(a._status=0,a._result=b);}if(1===a._status)return a._result.default;throw a._result;}
var U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};react_production_min.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments);},e);},count:function(a){var b=0;S(a,function(){b++;});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};react_production_min.Component=E;react_production_min.Fragment=p;
react_production_min.Profiler=r;react_production_min.PureComponent=G;react_production_min.StrictMode=q;react_production_min.Suspense=w;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;
react_production_min.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f]);}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);
for(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g;}return {$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};react_production_min.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};react_production_min.createElement=M;react_production_min.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};react_production_min.createRef=function(){return {current:null}};
react_production_min.forwardRef=function(a){return {$$typeof:v,render:a}};react_production_min.isValidElement=O;react_production_min.lazy=function(a){return {$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};react_production_min.memo=function(a,b){return {$$typeof:x,type:a,compare:void 0===b?null:b}};react_production_min.startTransition=function(a){var b=V.transition;V.transition={};try{a();}finally{V.transition=b;}};react_production_min.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.");};
react_production_min.useCallback=function(a,b){return U.current.useCallback(a,b)};react_production_min.useContext=function(a){return U.current.useContext(a)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(a){return U.current.useDeferredValue(a)};react_production_min.useEffect=function(a,b){return U.current.useEffect(a,b)};react_production_min.useId=function(){return U.current.useId()};react_production_min.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};
react_production_min.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};react_production_min.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};react_production_min.useMemo=function(a,b){return U.current.useMemo(a,b)};react_production_min.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};react_production_min.useRef=function(a){return U.current.useRef(a)};react_production_min.useState=function(a){return U.current.useState(a)};react_production_min.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};
react_production_min.useTransition=function(){return U.current.useTransition()};react_production_min.version="18.2.0";

const { useParameter, addons, useEffect, useMemo } = __STORYBOOK_MODULE_PREVIEW_API__;
const { deprecate } = __STORYBOOK_MODULE_CLIENT_LOGGER__;

var __defProp=Object.defineProperty;var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:!0});};var preview_exports={};__export(preview_exports,{initialGlobals:()=>initialGlobals});var PARAM_KEY="themes",ADDON_ID=`storybook/${PARAM_KEY}`,GLOBAL_KEY="theme";var DEFAULT_THEME_PARAMETERS={},THEMING_EVENTS={REGISTER_THEMES:`${ADDON_ID}/REGISTER_THEMES`};var initialGlobals={[GLOBAL_KEY]:""};var helpers_exports={};__export(helpers_exports,{initializeThemeState:()=>initializeThemeState,pluckThemeFromContext:()=>pluckThemeFromContext,useThemeParameters:()=>useThemeParameters});function pluckThemeFromContext({globals}){return globals[GLOBAL_KEY]||""}function useThemeParameters(context){return deprecate(dedent`The useThemeParameters function is deprecated. Please access parameters via the context directly instead e.g.
    - const { themeOverride } = context.parameters.themes ?? {};
    `),context?context.parameters[PARAM_KEY]??DEFAULT_THEME_PARAMETERS:useParameter(PARAM_KEY,DEFAULT_THEME_PARAMETERS)}function initializeThemeState(themeNames,defaultTheme){addons.getChannel().emit(THEMING_EVENTS.REGISTER_THEMES,{defaultTheme,themes:themeNames});}var DEFAULT_ELEMENT_SELECTOR="html",classStringToArray=classString=>classString.split(" ").filter(Boolean),withThemeByClassName=({themes,defaultTheme,parentSelector=DEFAULT_ELEMENT_SELECTOR})=>(initializeThemeState(Object.keys(themes),defaultTheme),(storyFn,context)=>{let{themeOverride}=context.parameters[PARAM_KEY]??{},selected=pluckThemeFromContext(context);return useEffect(()=>{let selectedThemeName=themeOverride||selected||defaultTheme,parentElement=document.querySelector(parentSelector);if(!parentElement)return;Object.entries(themes).filter(([themeName])=>themeName!==selectedThemeName).forEach(([themeName,className])=>{let classes=classStringToArray(className);classes.length>0&&parentElement.classList.remove(...classes);});let newThemeClasses=classStringToArray(themes[selectedThemeName]);newThemeClasses.length>0&&parentElement.classList.add(...newThemeClasses);},[themeOverride,selected]),storyFn()});

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const _sfc_main = {};
const _hoisted_1 = {
    class: "main"
};
const _hoisted_2 = {
    class: "content"
};
function _sfc_render(_ctx, _cache) {
    return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
            renderSlot(_ctx.$slots, "default", {}, undefined, true)
        ])
    ]);
}
const StoryWrapper = /*#__PURE__*/ _export_sfc(_sfc_main, [
    [
        'render',
        _sfc_render
    ],
    [
        '__scopeId',
        "data-v-7255af95"
    ]
]);
_sfc_main.__docgenInfo = {"displayName":"StoryWrapper","description":"","tags":{},"slots":[{"name":"default"}],"sourceFiles":["/Users/k.ayvazov/Desktop/Projects/ui-components/src/components/story-wrapper/StoryWrapper.vue"]};

const parameters = {
    layout: "fullscreen",
    actions: {
        argTypesRegex: "^on[A-Z].*"
    },
    controls: {
        matchers: {
            color: /(background|color)$/i,
            date: /Date$/
        }
    }
};
const decorators = [
    withThemeByClassName({
        themes: {
            light: "",
            dark: "dark"
        },
        defaultTheme: "light",
        parentSelector: "#storybook-root"
    }),
    ({ story })=>({
            components: {
                StoryWrapper,
                story
            },
            template: `
      <StoryWrapper>
        <story />
      </StoryWrapper>
      <div id="teleport" />
    `
        })
];

const index_7672 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  decorators,
  parameters
}, Symbol.toStringTag, { value: 'Module' }));

Pwe();
const { composeConfigs, PreviewWeb } = __STORYBOOK_MODULE_PREVIEW_API__;
const getProjectAnnotations = (hmrPreviewAnnotationModules = []) => {
  const configs = [
    hmrPreviewAnnotationModules[0] ?? entry_preview_20087,
    hmrPreviewAnnotationModules[1] ?? preview_21536,
    hmrPreviewAnnotationModules[2] ?? preview_21972,
    hmrPreviewAnnotationModules[3] ?? index_7672
  ];
  return composeConfigs(configs);
};
window.__STORYBOOK_PREVIEW__ = window.__STORYBOOK_PREVIEW__ || new PreviewWeb(importFn, getProjectAnnotations);
window.__STORYBOOK_STORY_STORE__ = window.__STORYBOOK_STORY_STORE__ || window.__STORYBOOK_PREVIEW__.storyStore;

export { withKeys as $, toDisplayString as A, shallowRef as B, triggerRef as C, onScopeDispose as D, defineComponent as E, Fragment as F, toRaw as G, h as H, cloneVNode as I, defineAsyncComponent as J, __vitePreload as K, withDirectives as L, vShow as M, normalizeProps as N, guardReactiveProps as O, withModifiers as P, Teleport as Q, getCurrentInstance as R, createTextVNode as S, Transition as T, useCssModule as U, createSlots as V, pushScopeId as W, popScopeId as X, withScopeId as Y, resolveComponent as Z, _export_sfc as _, reactive as a, vModelRadio as a0, mergeModels as a1, useModel as a2, createStaticVNode as a3, onMounted as b, computed as c, onBeforeUnmount as d, watch as e, openBlock as f, createElementBlock as g, createBaseVNode as h, createBlock as i, withCtx as j, inject as k, createVNode as l, normalizeClass as m, nextTick as n, onUnmounted as o, provide as p, renderSlot as q, ref as r, mergeProps as s, toRefs as t, unref as u, normalizeStyle as v, watchEffect as w, resolveDynamicComponent as x, createCommentVNode as y, renderList as z };
